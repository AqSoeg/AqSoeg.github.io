{"pages":[{"title":"关于我","text":"懒得写，以后再说","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"2015年の荒川へ","text":"課程デザインと期末テストが終わり、日付は7月に変わった。 私にとって、7月は一年中最も悲しい時期である。 火であり、斜陽であり、別れでもある。 あれから一年が過ぎ、そろそろ何か書こうと思って、あなたの誕生日の今日で、私はこの文章を書くと決めた。 東京生活記録あれは2015年の夏。 ビリビリのホームページで「東京生活記録」というタイトルの動画が見つかった。あの動画のサムネイルは一つの変な人形だった。私は好奇心であの動画を再生した。 それが私とあなたの出合い。 一人の十五歳で二次元にハマっていた少年にとっては、「東京」という言葉の魅力が言うもなく大きい。 最初は東京に誘われ、西日暮里、荒川、スカイツリーなど見知らぬところに私は興味が持ち、毎回も動画を見る。 しかし、見れば見るほど、私は「本当に面白い人だなぁ」と思い始めた。 道に歩いながら、なんだかんだ喋るところが好きだった。 今も思い出せる、あなたが行った場所。 荒川沿い、自転車に乗っていた人々。 秋葉原、歩行者天国、ビッグマック。 東京大学、部活室。 スカイツリー、東京タワー。 そして、西日暮里、屋上。 あなたはギブリが好きで、私もあれからギブリが好きになった。 あなたは三島由紀夫が好きで、動画まで撮って紹介した。私もあれから三島を読み始めた。 私はあなたの振る舞いや、言葉や最高にかっこいいと思い、とても好きだった。 考えたら、今の私には、大体半分くらいはあなたに影響された。 人生の先生と言っても過言ではないね。 東京から南京へ「いつか皆さんは私の動画を見ないことが私にとって嬉しいです。」とあなたが言った。 高校生になってから、学業に勉強していた一方で、生活はなんとなく充実になったかもしれない、私はあなたの動画を見なくなった。 時間がどんどん進んでいく。 運命とか、縁起とか、私は信じない。 しかし、私は南京の大学に受けた。あなたの、故郷の大学。 こうして、私はあなたと繋がってる感じがした。 あなたが遊んだあの公園、あの階段、あのピンポンボール、いつか行ってみたいだね。 三島由紀夫と羊をめぐる冒険去年の春、あなたは一つの動画をアップした。 あの動画で、大好きな三島由紀夫を紹介し、三島さんの本の読む順番も推薦した。 その後、あなたはウェイボーで「江蘇のどこかで羊が見えるの？」と。 数日後、あなたは羊の群れの写真をアップした。 「いいなぁ、あなたは相変わらずかっこいい。」私はこう思った。 そして、7月5日。 2020年7月4日凌晨，叶修于南京结束了自己的生命 あなたの最後の一言。 その後、私は村上春樹の「羊をめぐる冒険」を読んだ。 その本の中で、「活到25岁，然后死掉」という言葉がある。 それが、あなたの思い込みなのか。 Guaranteed Don’t come closer or I’ll have to go あなたはきっと、色々考えたから、死に選ぶことが決まったのが私は信じている。 だから、私はその点を否定しない。それだけでなく、私は「おめでとう」と、苦難から逃げられたことに祝う。 ね、ヨウさん、航海に行きたいってあなたが言っただろう？ あれから一年、どう、あの広くて青い海の景色は？ 「行かないで」とか、「どうしてそんな事を」とか、私は言わない。 ただ時々、あなたのことが私は思い出し、悲しくなる。 後悔はもちろんしちゃうよ、そんなに近かったのに、あったこと一回もない。機会があったのに… ありがとう、たくさんの風景を私に見させて。 ありがとう、今の私を作り上げて。 ありがとう、叶修。","link":"/2021/07/05/2015-arakawa/"},{"title":"KMP Algotirhm","text":"IntroductionPresume we have a string S (length is m) and a pattern P (length is n) given as follow: 123index: 1 2 3 4 5 6 7 8 9 10 11 12S: a b a b a a b a a b a cP: a b a a b a c Now we want to find out is there a sub-string in S that matchs P exactly, which in this case is S[6:12]. That is what KMP algorithm does. Proper Prefix &amp; Proper SuffixBefore learning KMP, let’s make this clear first: what is proper prefix and proper suffix? Proper prefix: All the characters in a string, with one or more cut off the end. “S”, “Sn”, “Sna”, and “Snap” are all the proper prefixes of “Snape”. Proper suffix: All the characters in a string, with one or more cut off the beginning. “agrid”, “grid”, “rid”, “id”, and “d” are all proper suffixes of “Hagrid”. Partial Match TableThe key to KMP, it’s the Partial Match Table. Let’s see a example. 123char: | a | b | a | a | b | a | c |index: | 1 | 2 | 3 | 4 | 5 | 6 | 7 |value: | 0 | 0 | 1 | 1 | 2 | 3 | 0 | I see, there’s a table. But what do these values mean? The length of the longest proper prefix in the (sub)pattern that matches a proper suffix in the same (sub)pattern. For example, at index 1, we have a sub-string “a”. Its proper prefix and proper suffix are both null, so it’s value is 0. At index 2, we have a sub-string “ab”, with proper prefix “a”, and proper suffix “b”, and they do not match each other, there’s another 0. At index 3, we have a sub-string “aba”, with proper prefix “a” and “ab”, and proper suffix “a”, “ba”. We can see that they both contains “a”, which we call “match”. And the length of “a” is 1, so its value is 1. At index 4, we have a sub-string “abab”, proper prefix “a”, “ab”, “aba”, and proper suffix “a”, “aa”, “baa”. They both cotains “a”, which legth is 1, so there’s 1s in its value. etc. How to use Next ArrayThe next array is baes on the pattern. What is cofusing is that on the internet, most blogs and videos, next array and PMT table are just the same thing, but in Wangdao’s text book, the PMT is different from next array. Well, I’ll just make them be the same. In bruce force searching, we search the S one letter by one letter, like this: 12345678910First run:S: a b a b a a b a a b a cP: a b a a &lt;- mismatchSecond run:S: a b a b a a b a a b a cP: a &lt;- mismatchThird run:S: a b a b a a b a a b a cP: a b a a b a c &lt;- mismatch... Obviously, it is very slow, and its time complexity is $O(mn)$. Check this: 123456789First run:S: a b a |b| a a b a a b a cP: a b a |a| &lt;- mismatchSecond run:S: a b a b a a b a |a| b a cP: a b a a b a |c| &lt;- mismatchThird run:S: a b a b a a b a a b a cP: a b a a b a c &lt;- match! We can see that after mismatch, P is not going forward one letter by one letter., but jumps forward. And through the next array we can know where should P jump to. In the first run, P[4] and S[4] mismatch, and next[4 - 1] is 1 which means in the substring from P[0:4], the prefix and subfix of 1 letter are the same, so we move P and make it match the S with its proper prefix instead the subfix that mismatched. In the second run, P[7] and S[9] mismatch, and next[7 - 1] is 3, which means the first and the last 3 letters in the substring from P[0:7] are the same, in this case is “aba”. So we move P forward till the first 3 letters take place of the last 3 letters. etc. Construct a Next Array123456789101112void get_next(String P, int next[]) { int i = 1, j = 0; next[0] = 0; while(i &lt; P.length) { if(j==0 || P[i] == P[j]) { i++; j++; next[i] = j; } else { j = next[j - 1]; } }} PracticeAcwing: 831.KMP字符串 ReferencesYoutube: Abdul Bari - Knuth-Morris-Pratt KMP String Matching Algorithm Zhihu: 阮行止 - 如何更好地理解和掌握 KMP 算法? Blog: The Knuth-Morris-Pratt Algorithm in my own words","link":"/2021/07/08/KMP-Algotirhm/"},{"title":"从零开始的LeetCode题解","text":"始まりと終わりのプロローグ -Turning Point- 数组二分704. 二分查找35. 搜索插入位置 在数组中搜索元素的题通常都可以用二分。但要注意前提是该数组有序。 关于二分的边界条件：在二分的过程中，要保证每次分的区间都满足一开始的定义。而区间的定义一般有两种：左闭右闭 和 左闭右开。以左闭右闭为例： while(left &lt;= right) 必须是 &lt;= ，因为 left 和 right 是有可能相等的。 同理left 更新时是 mid + 1 ， right 更新时是 mid - 1 。 704. 二分查找1234567891011121314151617class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int n = nums.size(); int l = 0, r = n - 1; int mid = 0; while (l &lt;= r) { mid = (l + r) / 2; if (nums[mid] &gt; target) { r = mid - 1; } else if (nums[mid] &lt; target) { l = mid + 1; } else return mid; } return -1; }}; 双指针27. 移除元素977. 有序数组的平方 这类题往往用暴力需要两层 for 循环。如果在第一层循环时能够记录一些信息提供给第二层循环，则可以考虑使用双指针。 27. 移除元素12345678910111213class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int l = 0; int n = nums.size(); for (int r = 0; r &lt; n; r ++) { if (val != nums[r]) { nums[l++] = nums[r]; } } return r; }}; 但双指针不一定要是都向同一个方向运动，也可以是从数组两端向中间走。 977. 有序数组的平方12345678910111213141516171819202122class Solution {public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int k = n - 1; vector&lt;int&gt; ans(n, 0); int l = 0, r = n - 1; while (l != r) { int a = nums[l] * nums[l]; int b = nums[r] * nums[r]; if (a &gt;= b) { ans[k --] = a; l ++; } else { ans[k --] = b; r --; } } ans[0] = nums[l] * nums[l]; return ans; }}; 滑动窗口209. 长度最小的子数组 本质也是双指针。适用于求解数组中的子数组的情况。 209. 长度最小的子数组12345678910111213141516171819class Solution {public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int n = nums.size(); int l = 0, r = 0; int sum = 0, res = 0; int len = INT_MAX; // 窗口的长度 for (r = 0; r &lt; n; r ++) { sum += nums[r]; while (sum &gt;= target) { len = min(len, r - l + 1); sum -= nums[l ++]; } } if (len == INT_MAX) return 0; return len; }}; 链表链表定义1234567struct ListNode { int val; ListNode* next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {}}; 删除元素203. 移除链表元素 对链表进行删除时一定要注意判断链表是否为空，以及对头结点的特殊操作。另外这题用到了虚拟头结点，这样就不用针对头结点特判，也是一个实用的技巧。 203. 移除链表元素12345678910111213141516171819class Solution {public: ListNode* removeElements(ListNode* head, int val) { ListNode* dummyHead = new ListNode(0, head); // 新建一个虚拟头结点，next指向head ListNode* cur = dummyHead; while (cur-&gt;next != nullptr) { ListNode* tmp = cur-&gt;next; if (tmp-&gt;val == val) { cur-&gt;next = tmp-&gt;next; delete tmp; } else { cur = cur-&gt;next; } } head = dummyHead-&gt;next; delete dummyHead; return head; }}; 反转链表206. 反转链表 原本想的是定义一个新链表，然后把旧链表元素依次插到新表头。但是显然复杂度比较高。好的办法依然是双指针。从头开始直接改变 next 指针的朝向。 206. 反转链表123456789101112131415class Solution {public: ListNode* reverseList(ListNode* head) { ListNode* pre = nullptr; ListNode* cur = head; ListNode* tmp; while (cur) { tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; // pre 前进 cur = tmp; // cur 前进 } return pre; }}; 交换结点24. 两两交换链表中的节点 用到了前面提到的虚拟头结点。没啥难的，主要是要自己画图模拟一下。 24. 两两交换链表中的节点12345678910111213141516171819class Solution {public: ListNode* swapPairs(ListNode* head) { ListNode* dummyHead = new ListNode(0, head); ListNode* cur = dummyHead; while (cur-&gt;next != nullptr &amp;&amp; cur-&gt;next-&gt;next != nullptr) { ListNode* t = cur-&gt;next; ListNode* t1 = cur-&gt;next-&gt;next-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; cur-&gt;next-&gt;next = t; cur-&gt;next-&gt;next-&gt;next = t1; cur = cur-&gt;next-&gt;next; } // 注意不要直接返回head，因为被cur修改过了，head不再指向表头了 return dummyHead-&gt;next; }}; 链表中的双指针19.删除链表的倒数第 N 个结点 双指针的经典应用。fast 先移动 n 个位置，再让 slow 指针一起移动。虚拟头结点依然很方便，不用特别处理头结点。 19. 删除链表的倒数第 N 个结点123456789101112131415161718192021222324class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummyHead = new ListNode(0, head); ListNode* fast = dummyHead; ListNode* slow = dummyHead; while (n-- &amp;&amp; fast-&gt;next != nullptr) { fast = fast-&gt;next; } while (fast-&gt;next != nullptr) { fast = fast-&gt;next; slow = slow-&gt;next; } if (n == 1) { delete fast; return head; } ListNode* tmp = slow-&gt;next; slow-&gt;next = tmp-&gt;next; delete tmp; return dummyHead-&gt;next; }} 142. 环形链表 II 两种解法：1、数学题。详解看这里2、哈希表。遍历每个结点，并加入哈希表。遇到的第一个遍历过的结点就是环的入口。 142. 环形链表 II解法一 123456789101112131415161718192021class Solution {public: ListNode *detectCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while (fast != NULL &amp;&amp; fast-&gt;next != NULL) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (slow == fast) { ListNode* p = head; ListNode* t = fast; while (p != t) { p = p-&gt;next; t = t-&gt;next; } return p; } } return NULL; }}; 解法二 123456789101112class Solution {public: ListNode *detectCycle(ListNode *head) { unordered_set&lt;ListNode*&gt; visited; while(head != NULL) { if (visited.count(head)) return head; visited.insert(head); head = head-&gt;next; } return NULL; }}; 设计链表707. 设计链表 模拟，注意 index 从 0 开始。 class MyLinkedList { public: struct ListNode { int val; ListNode* next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} }; MyLinkedList() { dummyHead = new ListNode(0); size = 0; } int get(int index) { if (index &lt; 0 || index &gt; size - 1) return -1; ListNode* cur = dummyHead-&gt;next; while (index --) cur = cur-&gt;next; return cur-&gt;val; } void addAtHead(int val) { ListNode* node = new ListNode(val, dummyHead-&gt;next); dummyHead-&gt;next = node; size ++; } void addAtTail(int val) { ListNode* cur = dummyHead; while (cur-&gt;next != nullptr) { cur = cur-&gt;next; } ListNode* node = new ListNode(val); cur-&gt;next = node; size ++; } void addAtIndex(int index, int val) { if (index &gt; size) return; ListNode* cur = dummyHead; ListNode* node = new ListNode(val); while (index --) cur = cur-&gt;next; node-&gt;next = cur-&gt;next; cur-&gt;next = node; size ++; } void deleteAtIndex(int index) { if (index &lt; 0 || index &gt; size - 1) return; ListNode* cur = dummyHead; while (index --) cur = cur-&gt;next; ListNode* tmp = cur-&gt;next; cur-&gt;next = tmp-&gt;next; delete tmp; size --; } private: int size; ListNode* dummyHead; };","link":"/2022/04/05/LeetCode/"},{"title":"考研数据结构算法题笔记","text":"一寸先が闇なら、二寸先は明るい未来 线性表反向输出链表递归 1234function print_values_in_reverse(ListNode head) if head is NOT null print_values_in_reverse(head.next) print head.val 单链表逆转双指针 不是交换结点中的元素，而是把指针逆转。定义两个指针pre和cur，每次操作先让cur的next指向前驱节点，再令pre前进到cur的位置，然后cur再前进一位，最后pre会前进到尾结点，这时指针就全部逆转了。 12345678910111213List Reverse (List L){ PtrToNode temp; // 保存cur的下一个节点 PtrToNode cur = L; PtrToNode pre = NULL; while (cur) { temp = cur -&gt; Next; cur -&gt; Next = pre; pre = cur; cur = temp; } return pre;} 链式表的按序号查找没啥好说的。 创建的指针cur一定要记得初始化cur = L，不然不知道指向哪。 123456789ElementType FindKth (List L, int K) { List cur = L; int i; for (i = 1; cur != NULL &amp;&amp; i &lt; K; i ++) { cur = cur -&gt; Next; } if (cur == NULL || i &gt; K) return ERROR; else return cur -&gt; Data;} 两数相加模拟 遍历两个链表，每次值相加后赋值给新链表的尾结点，记录下进位值留给下次运算。 注意两个链表长度不一定相等，以及如果最高位产生了进位，需要再新建一个结点用来存。 1234567891011121314151617181920212223class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *head = nullptr, *tail = nullptr; int carry = 0; while(l1 || l2) { int x = l1 ? l1-&gt;val : 0; int y = l2 ? l2-&gt;val : 0; int sum = x + y + carry; if (!head) { head = tail = new ListNode(sum % 10); } else { tail-&gt;next = new ListNode(sum % 10); tail = tail-&gt;next; } carry = sum / 10; if (l1) l1 = l1-&gt;next; if (l2) l2 = l2-&gt;next; } if (carry) tail-&gt;next = new ListNode(1); return head; }}; 350. 两个数组的交集 II排序 + 双指针 12345678910111213141516171819class Solution {public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); int n1 = nums1.size(), n2 = nums2.size(); int i = 0, j = 0; vector&lt;int&gt; res; while (i &lt; n1 &amp;&amp; j &lt; n2) { if (nums1[i] &lt; nums2[j]) i ++; else if (nums2[j] &lt; nums1[i]) j ++; if (i &lt; n1 &amp;&amp; j &lt; n2 &amp;&amp; nums1[i] == nums2[j]) { res.push_back(nums1[i]); i ++, j ++; } } return res; }}; 二叉树翻转二叉树第一眼就想到了层序遍历。不过递归也可以，而且代码更短，考试的时候还是写递归吧。 也是一个启示，树的题目基本上都可以往递归上面想。 层序遍历 12345678910111213141516171819class Solution {public: TreeNode* invertTree(TreeNode* root) { queue&lt;TreeNode*&gt; q; if (root != nullptr) q.push(root); while (!q.empty()) { int size = q.size(); for (int i = 0; i &lt; size; i ++) { TreeNode* cur = q.front(); q.pop(); swap(cur -&gt; left, cur -&gt; right); // 交换左右子树 // 入队的顺序和层序遍历相反。这里是先右孩子入队，再左孩子入队。 if (cur -&gt; right != nullptr) q.push(cur -&gt; right); if (cur -&gt; left != nullptr) q.push(cur -&gt; left); } } return root; }}; 递归 在前序遍历的基础上，把访问中间结点的操作改为交换左右子树。因为前序遍历是中左右的顺序，所以在原本访问中间结点的时候交换左右孩子，就能实现翻转二叉树。形象理解就是从上至下的递归。 后序遍历是左右中的顺序，所以同理，这里把swap放到后面，变成后序遍历也可以。形象理解就是从下至上的递归。 但是中序不行。有些结点会被翻转两遍。 1234567891011class Solution {public: TreeNode* invertTree(TreeNode* root) { if (root == nullptr) return root; // 终止条件 swap(root -&gt; left, root -&gt; right); // 每次递归，交换左右子树 invertTree(root -&gt; left); invertTree(root -&gt; right); // swap语句放到这个位置也可以 return root; }}; 在每个树行中找最大值这种涉及到“行”的，当然很自然就想到层序遍历。直接默写板子。 123456789101112131415161718192021class Solution {public: vector&lt;int&gt; largestValues(TreeNode* root) { queue&lt;TreeNode*&gt; q; if (root != nullptr) q.push(root); vector&lt;int&gt; res; while (!q.empty()) { int size = q.size(); int maxVal = INT_MIN; for (int i = 0; i &lt; size; i ++) { TreeNode* cur = q.front(); maxVal = max(cur -&gt; val, maxVal); q.pop(); if (cur -&gt; left != nullptr) q.push(cur -&gt; left); if (cur -&gt; right != nullptr) q.push(cur -&gt; right); } res.push_back(maxVal); } return res; }}; 对称二叉树递归，递归，还是递归！ 判断一棵二叉树是否对称，我们先把这棵树从根结点分开，看作左右两颗树。将左树的左边结点、右树的右边结点称为“外”，左树的右边结点和右树的左边结点称为“内”。如果两边的内外结点互相相等，则两棵树对称。 123456789101112131415161718192021class Solution {public: bool isSymmetric(TreeNode *root) { if (root == nullptr) // 如果是空树，对称 return true; return compare(root-&gt;left, root-&gt;right); // 从根结点的两颗子树开始由上至下判断 } bool compare(TreeNode *p, TreeNode *q) { if (!p &amp;&amp; !q) // 如果两个结点都是空的，对称 return true; else if (!p || !q) // 如果两个结点只有一个是空的，不对称 return false; else if (p-&gt;val != q-&gt;val) // 如果两个结点都不空，比较它们的值，如果不等，则不对称 return false; bool inside = compare(p-&gt;right, q-&gt;left); // 比较内结点 bool outside = compare(p-&gt;left, q-&gt;right); // 比较外结点 return (inside &amp;&amp; outside); // 只有二者都为true时才对称 }} 二叉树的最大深度模板题 层序遍历（迭代） 12345678910111213141516171819class Solution {public: int maxDepth(TreeNode* root) { if (root == nullptr) return 0; int height = 0; queue&lt;TreeNode*&gt; q; q.push(root); while (!q.empty()) { int size = q.size(); for (int i = 0; i &lt; size; i ++) { if (q.front()-&gt;left != nullptr) q.push(q.front()-&gt;left); if (q.front()-&gt;right != nullptr) q.push(q.front()-&gt;right); q.pop(); } height ++; } return height; }} 先序遍历（递归） 首先确定这个递归函数是要干什么：求树的高度。所以返回值是int类型； 然后确定终止条件：root == null，空树，树高为0； 最后确定单层递归的逻辑：树的最大深度等于max(左子树深度，右子树深度) + 1。 123456789class Solution {public: int maxDepth(TreeNode* root) { if (root == nullptr) return 0; int lheight = maxDepth(root-&gt;left); int rheight = maxDepth(root-&gt;right); return (max(lheight, rheight) + 1); }}; 二叉树的最小深度和上一题类似，但是这一题要求的是“从根结点到最近叶子结点的最短路径”，所以如果一棵树的左/右结点为空，其最小深度不是1，而是“非空子树的最小深度+1”。如果沿用上一题的写法，那就会在这里出错。 以下给出递归解法。当然也可以层序遍历，这里就不写了。 1234567891011class Solution {public: int minDepth(TreeNode* root) { if (!root) return 0; int lheight = minDepth(root-&gt;left); int rheight = minDepth(root-&gt;right); if (!root-&gt;left &amp;&amp; root-&gt;right) return rheight + 1; if (root-&gt;left &amp;&amp; !root-&gt;right) return lheight + 1; return (min(lheight, rheight) + 1); }}; 平衡二叉树和求二叉树最大深度那题类似。 递归三部曲： 确定参数和返回值类型 传入根结点，如果这棵树是平衡二叉树，则返回树高度；如果不是，则返回-1；所以返回值类型为int 确定终止条件 如果为空树，返回0；如果左/右子树高度为-1（说明不是平衡二叉树），返回-1。 确定单层递归的目的 如果左右子树高度差大于1，返回-1，否则返回树高度。 123456789101112131415class Solution {public: int getHeight(TreeNode* root) { if (root == nullptr) return 0; int lheight = getHeight(root-&gt;left); if (lheight == -1) return -1; int rheight = getHeight(root-&gt;right); if (rheight == -1) return -1; if (abs(lheight - rheight) &gt; 1) return -1; else return(max(lheight, rheight) + 1); } bool isBalanced(TreeNode* root) { return (getHeight(root) &gt;= 0); }}; 652. 寻找重复的子树序列化 将每一棵子树都「序列化」成一个字符串，并且保证： 相同的子树会被序列化成相同的子串； 不同的子树会被序列化成不同的子串。 那么我们只要使用一个哈希表存储所有子树的序列化结果，如果某一个结果出现了超过一次，我们就发现了一类重复子树。 12345678910111213141516171819202122232425262728class Solution {private: unordered_map&lt;string, int&gt; umap; vector&lt;TreeNode*&gt; ans; public: string dfs(TreeNode* root) { if (!root) return &quot;&quot;; // 注意这一行两个dfs前的“ ”不能删掉 string str = to_string(root-&gt;val) + &quot; &quot; + dfs(root-&gt;left) + &quot; &quot; + dfs(root-&gt;right); umap[str] ++; if (umap[str] == 2) ans.push_back(root); return str; } vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) { dfs(root); return ans; }};/* 1 2 31 2 1考虑这样一棵树，当遍历到2时，如果没有&quot; &quot;用来分隔根和左右孩子的值的话，左右两个以2为根的子树都会被序列化为&quot;21&quot;，但是这两棵树不是相同的。而有&quot; &quot;进行分隔的话，左边就被序列化为&quot;2 1 &quot;，右边是&quot;2 1&quot;，二者不同。*/ 动态规划","link":"/2022/07/14/DS-Kaoyan-algorithm/"},{"title":"考研操作系统笔记","text":"Through the storm, we will find a way. 第一章 导论1.1 什么是操作系统定义 操作系统是内核（Kernel）：一直运行在计算机上的程序，内核不运行则计算机无法运行。 目的 核心目标：运行程序 面向系统：高效使用计算机 面向用户：方便使用计算机 功能 操作系统是资源分配器 管理所有资源 面对冲突的资源请求，决定如何分配资源，以便系统能有效公平运行 操作系统是控制程序 管理用户程序运行，以防计算机资源的错误使用或使用不当 操作系统是计算机最底层的软件 现代计算机系统 现代计算机系统通常包含一个或多个CPU和内存、若干通过总线相连的设备控制器及其设备、总线、CPU和设备控制器可以并行工作，并竞争内存。 CPU和设备间的交互 每个设备控制器有一个本地缓冲 CPU在内存和本地缓冲之间传输数据 I/O控制器从设备到本地缓冲之间传输数据 控制器通过中断通知CPU完成操作 中断是指当出现需要时，CPU暂时停止当前进程的执行，转而处理新情况的中断处理程序。 1.2 多道程序设计和分时简单批处理系统（单道程序设计）用户将一批作业（批处理作业）提交给操作系统后就不再干预，由操作系统控制它们自动运行。 每个时刻只执行一个作业，自动从一个运行完的作业切换到下一个作业 实现了自动化作业调度（由常驻监控程序Monitor（简单批处理系统的核心）实现） 控制作业传输 调度作业运行 自动从一个运行完的作业转换到下一个作业 可以在无需人工干预的条件下运行作业（不具有交互性） 多道程序系统（多道程序设计）在内存中同时存在多道作业，在管理程序控制下相互穿插运行。 目的：提高CPU利用率 并行和并发并行：微观上，两个或多个作业在同一时刻运行 并发：宏观上，两个或多个作业在同时运行；但微观上，同一时刻只有一个作业在运行，不同作业在不同时间段依次运行 分时系统分时系统是针对交互作业设计出来的，是多道程序设计的延伸。e.g. Unix 联机的多用户交互式操作系统 采用时间片轮转方式使一台计算机为多个用户服务 在单位时间内，每个用户获得一个时间片并运行 保证用户获得足够小的响应时间，并提供交互能力 1.3 操作系统类型 大型机系统 简单批处理系统 多道程序系统 分时系统 桌面系统 适用于PC 嵌入式系统 完全嵌入受控器件内部，为特定应用设计的专用计算机系统 手持（移动）系统 适用于手持设备，如手机、平板 分布式系统 又称松耦合系统 通过网络通信：TCP/IP 目前没有真正意义上的分布式操作系统 多处理器系统 有多个紧密通信的处理器的系统。多个处理器共享计算机总线、内存和外设等。紧耦合系统。 优点：节省资金（因为共享其他设备）、增加可靠性、增加吞吐量 对称多处理（SMP）：每个处理器运行操作系统的相同副本 非对称多处理（ASMP）：各个处理器不对等，一个主处理器，若干从处理器（如骁龙820） 集群系统 通过专用网络连接一群计算机，将这些计算机虚拟化为一台有超强算力的计算机。 1.4 操作系统操作和功能操作双模式用户模式和内核模式 用以解决程序运行中出现的问题：除以零、死循环等，允许OS保护自身和其他系统部件 双模式需要CPU的支持，如果CPU有模式位，则可以在操作系统中实现双模式 内核模式的模式位为0，用户模式的模式位为1 在用户模式中，只能运行用户自编的应用程序 在内核模式中，可以运行OS内核程序（特权指令），包括I/O指令、置中断指令等 用户可以通过系统调用和软件中断执行特权指令 I/O保护I/O指令都是特权指令，防止用户执行非法I/O 内存保护通过硬件支持（基址寄存器+限长寄存器）的存储保护机制，防止内存非法访问 定时器如果用户程序死循环或不调用系统调用，那么操作系统就无法获得CPU的控制权并对系统进行管理 所以引入定时器，在一段时间后发生中断，将CPU控制权返回给操作系统 也需要硬件支持 功能进程管理、内存管理、文件管理、I/O系统管理、其他 第二章 操作系统结构2.1 操作系统服务和接口操作系统以服务形式向程序和用户提供环境执行程序 三种基本服务形式提供给程序的服务形式：系统调用 系统调用可以供程序通过应用程序接口（API）访问 三种常用API：Windows的Win32 API、POSIX系统的POSIX API、Java虚拟机的Java API 提供给用户的服务形式：用户接口、系统程序 用户接口：命令行接口（CLI）、图形接口（GUI） 智能手机采用的人机交互接口有：命令行接口、图形接口、声控接口 系统程序：用以管理、维护操作系统 文件管理（文件资源管理器）、状态信息（这台电脑-&gt;管理）、通信等 2.2 操作系统结构 简单结构（无结构）：MS-DOS、早期Unix 层次结构：每层只能使用相邻低层次的功能和服务（THE、iOS） 微内核（Mach、Windows NT、 Windows 2000） 便于移植、更稳定、更安全（适合服务器） 用户空间和内核空间通信的系统开销增加 ——&gt; 提出了消息传递机制 模块结构：大部分现代操作系统采用（Linux、Solaris） 每个核心部件分开 每个模块在需要时被加载到内核 混合结构：MacOS 2.3 虚拟机定义：虚拟机是通过软件模拟实现，具有完整硬件系统功能，并运行在一个完全隔离环境中的完整计算机系统 常见的虚拟机有三种 高级语言虚拟机（JVM） 用以模拟代码运行，实现跨平台 运行在操作系统上 工作站虚拟机（VMWare Workstation、Virtual Box） 面向工作站和PC，使得多个操作系统可以在一个计算机上使用 客户操作系统运行在宿主操作系统上 服务器虚拟机（阿里云、腾讯云等） 多用户、多操作系统并存 把服务器的物理资源抽象成逻辑资源，让一个物理计算机虚拟化为多个相互隔离的虚拟服务器 直接运行在硬件上 第三章 进程3.1 进程概念进程：一个程序在一个数据集上的一次运行 进程和程序的区别 进程是程序的一个实例，是程序的一次执行；程序是进程的代码部分 进程是动态的，程序是静态的 进程在内存中，程序在外存中 进程的组成进程包括 代码（程序段） 当前活动：程序计数器PC、堆栈(包括函数参数、返回地址、局部变量）、数据（包括全局变量）、堆（进程运行时动态分配的内存） 进程的状态运行态：指令在执行 等待态：等待资源或某些事件发生，满足条件后转化为就绪态 就绪态：等待分配处理器（时间片），满足条件后转化为运行态 新建态：创建进程 终止态：进程执行完毕 进程控制块（PCB）PCB在内核空间中，是进程在操作系统中的唯一标志 PCB中包含了和进程有关的信息：进程状态、程序计数器、CPU寄存器、CPU调度信息、内存管理信息、记账信息、I/O状态信息 进程的上下文切换需要PCB保护和恢复现场 3.2 进程操作进程创建父进程创建子进程，如此轮流创建进程，构成一棵进程树 资源共享方式 父进程子进程共享所有资源 子进程共享父进程资源的子集 父进程和子进程之间无资源共享 执行顺序 父进程和子进程并发执行（默认） 父进程等待，直到子进程执行完成为止（父进程调用wait系统调用） 地址空间 子进程复制父进程的空间（与父进程具有相同的程序和数据）（fork） 子进程装入另一个新程序 fork Linux中用系统调用fork()来创建子进程。fork()创建的子进程和父进程有不同的PID ，但是它们共享相同的代码空间和资源（通过虚拟存储的写时复制技术实现），相当于复制了父进程。 通过fork()的返回值区分父子进程： 如果子进程创建失败，fork()返回-1 如果创建成功，fork()在父进程中返回新创建的子进程的PID，在子进程中返回0 进程终止当进程完成执行最后语句并且通过系统调用exit()请求操作系统删除自身时，进程终止。 进程结束的方式 进程执行最后一项并退出（exit） 进程执行完最后一项并退出 操作系统收回进程的资源 父进程终止子进程的执行（abort） 通常使用这种方式结束进程是由于以下几种原因 子进程超量分配资源 赋予子进程的任务不再需要 父进程终止 父进程可等待子进程的结束（abort） 父进程通过调用wait()系统调用来等待子进程结束 fork()创建子进程之后，父进程和子进程的运行顺序是不固定的，有可能还没有执行子进程，父进程就先结束了。我们需要让子进程先执行，然后再执行父进程，就要用wait()，让父进程等子进程运行完。 进程通信独立与协同进程 独立进程：不会影响另一个进程的执行或被另一个进程执行影响 协同进程：可能影响另一个进程的执行或被另一个进程执行影响 进程间通信（IPC）的两种模式 共享内存：一块内存在多个进程间共享 以最快的速度进行方便的通信，一般用于大数据通信 生产者-消费者 消息传递：建立连接后使用send和receive操作交换信息 用以交换较少数量的数据 消息传递分为直接通信和间接通信 直接通信：需要通信的每个进程必须明确指定通信的接收者或发送者 间接通信：消息导向至信箱并从信箱接收，两个进程只有拥有一个共享信箱时才能通信 进程间采用间接通信方式时，在消息中必须给出信箱名 消息传递分为阻塞（同步）和非阻塞（异步） 阻塞send：发送进程阻塞，直到消息被接收 阻塞receive：接收者进程阻塞，直到有消息可用 非阻塞send：发送进程发送消息并继续操作 非阻塞receive：接收者收到一个有效消息或无效消息 其他Tips 进程的创建和终止都是原子操作 原子性必须需要硬件的支持 进程创建时，进程将被设置为就绪态，不会为其分配CPU 单任务操作系统不需要进行进程上下文切换 第四章 线程4.1 什么是线程线程是在CPU上运行的基本执行单位；进程上的一个代码片段可以被创建为一个线程 进程仍然是资源分配的基本单位；线程本身不拥有系统资源，而是向进程申请资源 引入线程的原因性能角度 操作进程对系统而言开销大 应用角度 进程代码并行执行的需求 硬件角度 充分利用多核处理器的并行特性 加速进程运行 线程和进程的联系和区别代码 进程包含线程 线程是进程中的一段代码 资源 进程是资源分配的基本单位 线程不拥有资源，共享使用进程的资源 调度 线程是基本的调度单位 同一进程中的线程切换不引起进程切换 切换 进程：重量级，上下文切换代价大 线程：轻量级，切换代价小 生命期 进程撤销会导致它的所有线程被撤销 线程撤销不影响进程 线程数据结构线程控制块（TCB） TCB包含在PCB中 含有：线程ID，程序计数器，寄存器集，栈空间 线程的优点 响应度高：线程创建开销小。（e.g. Web服务器） 资源共享 经济性：线程创建和上下文切换比进程快 充分利用多处理（MP）结构 4.2 线程模型用户线程定义：由用户线程库进行管理的线程 用户线程的创建和调度在用户空间中，不需要内核的干预 内核看不见用户线程 内核线程定义：由内核进行管理的线程 需要内核支持，由内核完成调度 由内核进行创建和撤销 多线程模型多对一模型：多个用户线程对应一个内核中的用户进程，用于不支持内核线程的操作系统 内核只看到一个进程，多个线程不能并行运行在多个处理器上 进程内线程切换不会导致进程切换（减少系统开销） 一个线程的系统调用会导致整个进程阻塞 一对一模型：用户线程映射到内核线程（Windows中普遍采用） 并发性好：多个线程可以并行运行在多个处理器上 内核开销大 多对多模型：多个用户线程映射为相等或更小数目的内核线程 并发性和效率兼顾，但增加了复杂度 4.3 线程库线程库为程序员提供API来创建和管理线程 两种模式 用户库（用户线程） 存在于用户空间 调用线程库不会产生系统调用 内核库（内核线程） 存在于内核 操作系统支持 调用线程库会产生系统调用 常见线程库PThreads线程库 线程的POSIX标准 Java线程库 两种创建方法 扩展java.lang.Thread类 实现Runnable接口 由JVM管理 Win32线程库 可能会产生系统调用 Tips 同一个进程中的线程，不能共享堆栈 ‌线程是比进程更小的能独立运行的基本单位 第五章 CPU调度5.1 CPU调度概述三种调度长程调度又称作业调度、高级调度 长程调度将作业由新建状态转换到就绪状态 控制内存中运行进程的数量 处于新建状态的进程一般首先被放到外存的进程池中，经过长程调度放入内存，转换为就绪状态 短程调度又称CPU调度、低级调度 调度程序选择下一个执行进程 中程调度又称交换 将进程在内存和外存之间换进换出，目的是节省内存空间 调度过程调度程序（Scheduler） 根据某种策略（调度算法）选择内存中的一个就绪进程 分派程序（Dispatcher） 负责具体的进程切换工作： 负责把CPU的控制权转交CPU调度程序 切换上下文 切换到用户态 跳转到用户程序的适当位置并重新运行 调度方式非抢占式调度一旦把CPU分配给某进程之后，系统不可以抢占已分配的CPU并分配给其他进程 特点：易实现、系统开销小、适合批处理系统；响应时间长，不适合交互式系统 发生时机： 从运行转到等待 进程终止运行 抢占式调度调度程序可根据某种原则暂停某个正在执行的进程，将已分配给它的CPU重新分配给其他进程 特点：可防止单一进程长时间独占CPU；系统开销大 发生时机： 从运行转到就绪 从等待转到就绪 5.2 先来先服务和短作业优先先来先服务（FCFS）短作业优先（SJF） SJF算法的就绪队列是按照进程的下一个CPU脉冲时间排列 非抢占式 抢占式 被称为最短剩余时间优先调度，缩写为SRTF SJF调度算法拥有最短的平均等待时间 但是存在饥饿问题 5.3 优先级调度和时间片轮转优先级调度（PR）目前主流的操作系统调度算法 优先级类型 静态优先级 进程创建时确定优先级，运行期间不变 可能产生饥饿问题 动态优先级 进程的优先级随着进程推进或等待时间增加而改变 高响应比优先调度算法 抢占式 非抢占式 高相应比优先调度算法 响应比 = 等待时间/运行时间 时间片轮转（RR）一般来说时间片轮转调度算法能够获得最短响应时间 5.4 多级队列和多处理器调度多级队列调度（MLQ）针对不同的进程使用不同的调度算法：允许系统中存在多个就绪队列，每个就绪队列有自己的调度算法 核心问题 队列数 每个队列的调度算法（每个队列的调度算法可以相同、可以不同） 决定新进程将进入哪个队列的方法 多级反馈队列调度（MLFQ）进程在其运行过程中，能在不同队列间移动 Unix, Solaris, Windows的调度算法都是MLFQ的变种 核心问题 MLQ需要考虑的问题 决定进程升级（低级队列到高级队列）和降级（高级队列到低级队列）的方法 多处理器调度适用多核处理器的CPU调度 亲和性：进程在某个给定的CPU上尽量长时间运行而不被迁移到其他处理器的倾向性 软亲和性：操作系统试图保证进程运行在同一处理器上（但不保证一定） 进程通常不会在处理器之间频繁迁移 硬亲和性：操作系统提供系统调用支持硬亲和性，使得进程运行在某个处理器子集上 进程不会在处理器之间迁移 负载平衡将负载平均分配到SMP系统的所有处理器 对于有些系统（处理器具有私有的可执行进程的队列），负载平衡是必需的；对于具有公共队列的系统，负载平衡通常没有必要，因为一旦处理器空闲，就可以从公共队列中取出一个可执行进程。 单队列调度方法（SQMP）系统有一个公共就绪队列；当任意一个CPU空闲时，就从就绪队列中选择一个到该CPU上运行 优点 容易从单核调度算法推广到多核/多处理器 实现简单，负载均衡 缺点 不具有亲和性 加锁问题 多队列调度方法（MQMP）系统有多个队列，每个CPU一个；每个就绪队列有自己的调度算法，并且调度相对独立 优点 亲和性好 不需要加锁 缺点 负载不均衡 Tips 为了照顾紧迫型进程，应采用PR调度策略 一般来说，能够获得最短响应时间的调度算法是RR算法 一般来说，能够获得最短平均等待时间的调度算法是SJF算法 SJF算法的就绪队列是按照进程的下一个CPU脉冲时间排列 第六章 进程同步6.1 临界区同步和互斥同步：协调进程的执行次序，使并发进程间能够有效地共享资源、相互合作，保证数据一致性 互斥：进程排他性地运行某段代码，任何时候只有一个进程能够运行 临界资源：一次只允许一个进程使用的资源 共享资源：一次允许多个进程使用的资源 临界区：涉及临界资源的代码片段；由程序员确定 互斥准则 有空让进 有限等待 6.2 信号量整型信号量wait(S) / P(s) signal(S) / v(S)：V操作唤醒的进程状态可能会变为就绪态 存在忙等问题 记录型信号量分为计数信号量和二值信号量 在整型信号量的基础上增加了一个等待队列 通过加入了阻塞和唤醒机制，消除了忙等 互斥信号量的使用 12345Semaphore *S; S-&gt;value = 1; // 初始化为1wait(S);CriticalSection(); // 临界区signal(S); 同步信号量使用 123456789// 例如P1和P2需要比C1和C2先运行Semaphore S;S-&gt;value = 0; //初始化为0P1: C1; signal(S);P2: wait(S); C2; 6.3 经典问题生产者消费者读者写者 允许多个读者同时读 不允许多个写者同时写 不允许读者、写者同时读写 1234567891011121314151617181920// rc是读者计数器，当第一个读者开始读时，给临界区加锁，写者无法写，但其他读者依然可以读// 当最后一个读者读完，rc == 0时，释放临界区，写者可以写// rc本身也是临界资源，使用互斥信号量MReader(): P(M); rc++; if(rc == 1) P(W); V(M); read(); P(M); rc--; if(rc == 0) V(W); V(M);Writer(): P(W); write(); V(W); 哲学家就餐防止死锁可采取的措施 最多允许（筷子数 - 1）个哲学家同时坐在 仅当一个哲学家左右两边筷子都可用时，才允许他拿筷子 给所有哲学家编号，奇数哲学家必须先拿左边筷子，偶数哲学家反之 6.4 管程由编程语言解决同步和互斥问题；引入管程可以方便程序员在代码中实现同步 第七章 死锁7.1 死锁概念及其资源分配图死锁的必要条件互斥 占有并等待 非抢占 循环等待 资源分配图 如果资源分配图没有环，那么系统就不处于死锁状态 如果资源分配图有环，那么系统可能处于死锁状态 如果每个资源类型刚好有一个实例，那么有环就意味着已经出现死锁（充分必要）；如果每个资源类型有多个实例，那么有环并不意味着出现了死锁（必要非充分）。 死锁处理方法一般来说，处理死锁问题有三种方法： 通过协议来预防或避免死锁，确保系统不会进入死锁状态 可以允许系统进入死锁状态，然后检测并恢复 忽略这个问题（被大多数操作系统所采用） 忽略死锁的可能性要比其他方法更便宜。对于许多系统，死锁很少发生（如一年一次），发生之后人工重启系统即可。所以和死锁预防、死锁避免和死锁检测与恢复相比，这种方法更便宜。 7.2 死锁预防死锁预防是一组方法，确保至少一个上述的必要条件不成立 通过限制资源申请的方法来预防死锁，降低了设备使用率和系统吞吐量 互斥如系统存在互斥资源，不能改变这个条件来预防死锁 占有并等待必须保证进程申请资源的时候没有占有其他资源 静态分配策略 要求进程在执行前一次性申请全部的资源或要求进程只有在没有资源时才可申请资源 利用率低，可能出现饥饿 非抢占当一个进程处于等待时，如果其他进程申请其拥有的资源，那么该进程的部分资源可以被抢占 循环等待对所有的资源类型排序进行总排序，并且要求进程按照递增顺序申请资源 7.3 死锁避免获得以后如何申请资源的附加信息来决定是否分配资源 资源分配图算法适用于每个资源类型只有一个实例的系统 如果有环存在，那么分配会导致系统处于非安全状态 银行家算法适用于每个资源类型有多个实例的系统 7.4 死锁检测和恢复死锁检测单个实例 —— 资源等待图资源等待图是资源分配图的简化，适用于每种资源类型只有单个实例的系统 若等待图中有环，则系统一定产生了死锁 为检测死锁，系统需要维护等待图，并周期调用环检测算法，复杂度为$O(n^2)$ 多个实例类似银行家算法，只不过把Need换成Request 死锁恢复 操作员人工恢复 自动恢复 终止进程 中断所有的死锁进程 一次中断一个进程直到死锁消失 抢占资源 Tips 死锁避免方法不会限制用户申请资源的顺序；死锁预防的破坏循环等待条件才会 所有进程都被挂起时，系统不一定陷入死锁 每个死锁进程必然占据了某类资源 &lt;–错误，因为可能有的资源本身没有占有资源，但是在等待被占有的资源，此时它也处于死锁中。比如汽车过桥问题中，不在桥上但不能过桥的汽车。 第八章 内存管理8.1 内存管理背景内存管理的目的 提高内存利用率 提高内存数据访问的速度 进行存储保护 基本硬件CPU可以直接访问的通用存储只有内存和处理器内置的寄存器 程序必须装入内存才能被执行 内存保护保护用户进程不会相互影响 内存保护通过硬件来实现，因为操作系统通常不干预CPU对内存的访问（会导致性能损失） 内存保护的一种可能方案： 确保每个进程都有一个单独的内存空间。 基址寄存器：含有最小的合法的物理内存地址 界限寄存器：指定了范围的大小 只有操作系统可以通过特殊的特权指令，才能加载基址寄存器和界限寄存器 地址绑定程序以二进制可执行文件的形式存储在磁盘上，为了执行，程序被调入内存并放在进程中。 地址绑定通常发生在以下三个时期： 编译时：如果在编译时就已经知道进程将在内存中的驻留地址，那么就可以生成绝对代码 加载时：如果在编译时不知道进程将驻留在何处，那么编译器就生成可重定位代码 执行时：如果进程在执行时可以从一个内存段移到另一个内存段，那么绑定应延迟到执行时才进行（绝大多数操作系统采用） 逻辑地址和物理地址逻辑地址（虚拟地址）：CPU生成的地址 物理地址（实地址）：内存单元看到的地址 从逻辑地址到物理地址的运行时映射是由内存管理单元（MMU）的硬件设备来完成 动态加载为了获得更好的内存空间利用率，可以使用动态加载。此时，一个程序只有在调用时才会加载，所有程序都以可重定位加载格式保存在磁盘上。 动态加载不需要操作系统提供特别支持。 动态链接库动态链接库为系统库，将各种库文件的连接被推迟到执行时期。 与动态加载不同，动态链接通常需要操作系统的帮助。 8.2 连续内存分配连续内存分配是早期内存分配方式，运用于内存较少的系统 涉及三种类型：单一连续分配、固定分区分配、可变分区分配 单一连续分配单道程序环境下，仅装有一道用户程序，整个内存的用户空间由该程序独占，这种分配方案称为单一连续分配 固定分区分配预先把可分配的主存空间分割成若干个连续的区域，称为一个分区 每个分区的大小可以相同也可以不同，但分区大小固定不变，每个分区只能装入一个程序 可变分区分配可变分区分配是固定分配分区的延伸，主要用于批处理系统 对于可变分区方案，操作系统有一个表，用于记录哪些内存可用和哪些内存已用。开始，所有内存都可用于用户进程，因此可以作为一大块的可用内存，称为孔。最后，内存中会有一个集合，包含各种大小的孔。 存储分配算法 首次适应：分配首个足够大的孔 最佳适应：分配最小的足够大的孔 最差适应：分配最大的孔 在速度和存储空间的利用上，首次适应和最佳适应要好于最差适应（但是会产生外部碎片） 减少碎片的方法：紧缩，把小的空闲内存结合成一个大的块（必须得到动态重定位的支持才能采用） 8.3 分页内存管理由连续分配方式发展为分页存储管理方式的主要动力是：提高内存利用率 每个进程拥有一张页表，且进程的页表驻留在内存中（不是只有执行进程的页表驻留） 允许进程的物理地址空间可能不连续 将物理内存分成大小固定的块，称为帧 将逻辑内存分成同样大小的块，称为页 地址转换机制CPU生成的每个地址分为两部分：页码和页偏移。页码作为页表的索引，页表包含每页在物理内存的基地址，这个基地址和页偏移的组合就成了物理内存地址，可发送到物理单元。 注意页表项中只有帧号，所以一个32位的页表项可以指向$2^32$个物理帧的任意一个 硬件支持如果页表比较小，可以将页表存放于寄存器中。但如果页表较大（例如100万个条目），就只能存放于内存中 页表基地址寄存器（PTBR）指向页表，改变页表时只需要改变这一寄存器即可，这大大降低了上下文切换的时间 转换表缓冲区（TLB）中存放页码和帧码 8.4 页表结构层次页表哈希页表虚拟页号被散列到一个页表中，这种页表的每一个条目都包括了一个链表元素（拉链法处理碰撞），这些元素哈希成同一位置 页表中每个元素有三个域：虚拟页号、所映射的帧号、指向下一个元素的指针 反向页表（倒置页表）反向页表适用于进程较多的系统 通常来说，每个进程都有一个页表，而每个页表有很多项，需要消耗大量物理内存。为了解决这个问题，可以使用反向页表。反向页表对于每个真正的内存页或帧才有一个条目。每个条目保存在真正内存位置的页的虚拟地址，以及拥有这个页的进程的信息。 整个系统只有一个页表，对每个物理内存的页也只有一条对应的条目 8.5 分段内存管理分段的特点 支持用户观点的内存管理机制 逻辑地址空间是由一组段组成的，每个段都有名称和长度，地址指明了段名称和段内偏移 可以实现有意义的共享 方便进行地址转换 程序不需要连续的内存 在段式存储管理中，一个段是不定长的连续区域 会产生外部碎片（两个段中间的空闲区有可能过小而无法分配给其他程序段） 地址 由谁确定 存储 分页 逻辑地址连续，一维 操作系统 各页可以分散存放在主存 分段 逻辑地址不连续，二维 用户 每段必须采用连续的主存空间 8.6 内存“扩充”技术为了解决内存空间不足的问题所产生的技术 虚拟内存覆盖在程序执行过程中，程序的不同部分相互替换，只在内存中保留那些在任何时间都需要的指令和数据 现代操作系统一般不用 交换把内存中暂时不能运行的进程或者暂时不用的程序和数据调出到外存上的备份区，再把已具备运行条件的进程或进程所需的程序或数据调入内存 交换较为耗时（100MB大约4S） 交换时间的主要部分是转移时间，总的转移时间直接同交换的内存数量成正比 标准交换技术在现代操作系统中一般很少使用 其他Tips 采用覆盖和交换技术的目的是减少程序占用的主存空间 采用覆盖技术不需要操作系统的支持 采用交换技术需要I/O支持 每个进程拥有一张页表，且进程的页表驻留在内存中 存在内部碎片的存储管理方式：固定分区分配、页式存储管理、段页式存储管理 存在外部碎片的存储管理方式：可变分区分配、段式存储管理 实现进程间数据共享最方便的存储管理技术是分段 在页式存储管理中，引入快表可以减少每一次的内存访问时间（错误，引入快表只能减少平均的内存访问时间，而不是每次内存访问时间） 第九章 虚拟内存内存不够进程运行 -&gt; 虚拟内存技术 虚拟内存使用请求分页技术实现 -&gt; 如何处理缺页、页置换、给进程分配页框数等问题 页置换问题 -&gt; 页置换算法 给进程分配页框 -&gt; 固定分配、优先级分配；颠簸问题 9.1 虚拟存储技术局部性原理 虚拟存储技术 当进程运行时，先将其一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动将它们从磁盘调入内存执行 虚拟内存大小由：操作系统字长和内外存容量和共同决定 使用虚拟内存的共享库 通过将共享对象映射到虚拟地址空间，系统库可以被多个进程所共享 虚拟内存允许进程共享内存 虚拟内存可允许在创建进程期间共享页，从而加快进程创建（fork） 写时复制(Copy on Write) 允许父进程和子进程在初始化时共享页面 虚拟内存的实现 虚拟页式 请求分页 预调页 虚拟段式 9.2 请求分页进程开始运行之前，不是装入全部页面，而是装入一个或零个页面。运行之后，根据进程需要而动态装入其它页面。当内存空间已满，需要装入新的页面时，则根据某种算法置换内存中的某个页面，以便装入新的页面。 有效-无效位请求分页的实现需要在页表的表项中增加一个“有效-无效位”，1表示在该页在内存，0表示不在内存。在所有的表项中，这个位被初始化为0 缺页中断如果访问的页不在内存，系统陷入缺页中断。此时系统决定终止执行指令或将该页从外存中调入内存，再更改页表，然后重启指令 缺页中断属于程序中断 请求分页讨论极端情况下，进程创建时未被分配内存，导致进程执行第一行代码开始就不断产生缺页中断。这种情况被称为纯请求分页 请求分页性能缺页率： $0&lt;= p &lt;= 1$ 有效访问时间（EAT）： $$EAT = (1-p) \\times 内存访问时间 + p \\times 页错误时间$$ 9.3 页面置换页置换过程 将待置换的帧换出至磁盘 修改页表，将换出的帧有效位设置为i 将待换入的页换入内存 修改页表，将换入的帧有效位设置为v 页置换讨论 如果发生页置换，则缺页处理时间加倍 通过修改位或脏位来防止页面转移过多（只有修改过的页面才换出到磁盘，否则直接舍弃） 页置换算法1. 先进先出算法（FIFO）：可能会导致Belady异常（页框更多-&gt;缺页更多）。使用FIFO队列来管理内存中所有的页。 2. 最优置换算法（OPT）：置换将来不再需要的页（无法实现） 3. 最近最少使用算法（LRU）：置换最长时间没有使用的页。需要一个计数器或栈来实现（开销大，需要硬件支持） 4. 不经常使用算法（NFU） 5. 二次机会算法 9.4 页框分配和颠簸固定分配平均分配：100个页框，5个进程，每个进程分配20个页 按比例分配：根据每个进程的大小来分配 优先级分配按照优先级而不是进程大小来使用比率分配策略 如果进程Pi产生一个缺页： 可能选择替换Pi自己的页框 可能从一个较低优先级的进程中选择一个页面来替换 全局置换和局部置换全局置换：进程在所有的页框（包括其他进程的）中选择一个替换页面 局部置换：每个进程只从属于自己的页框中选择 颠簸（抖动）颠簸：一个进程的页面经常换入换出 工作集（Working Set）假如进程Pi最近的10个引用（称为工作集窗口）是：2 6 1 5 7 7 7 7 5 1，那么在这10个引用中，它的工作集就是${1,2,5,6,7}$ 缺页率（PFF）策略设置一个可接受的缺页率，如果缺页率太低，回收一些进程的页框；如果缺页率太高，就分给进程一些页框 9.5 内核内存分配内核内存不同于用户内存，通常从空闲内存池中获取，因为： 内核需要为不同大小的数据结构分配内存 一些内核内存需要连续的物理页 占用内存块的时间比较短 伙伴（Buddy）系统主要思想：内存按2的幂的大小进行划分，组成若干空闲块链表；查找链表找到满足进程要求的最佳匹配块。 当分配需求小于现在可用内存时，当前段就分为两个更小的2的幂段（伙伴），继续上述操作直到合适的段大小。 主要用于Linux早期版本中内核底层内存管理 从物理上连续的大小固定的段上分配内存 优点：可通过合并而快速形成更大的段 缺点：容易产生碎片 Slab分配主要思想： Slab层把不同的对象划分为所谓的Cache组，每个Cache都存放不同类型的对象（例如一个Cache存放task_struct结构体，另一个Cache存放struct_inode结构体）。 Slab是由一个或多个物理上连续的页组成，每个Cache又由一个或多个slab组成。 每个内核数据结构都有一个Cache（如进程描述符、文件对象、信号量等）。 Slab分配：当创建cache时，包括若干个标记为空闲的对象，对象的数量与slab的大小有关。当需要内核对象时，从cache上直接获取，并标记对象为使用。当一个slab充满了已使用的对象时，下一个对象的分配从空的slab开始分配。 优点： 没有因碎片引起的内存浪费 内存请求可以快速满足（因为对象预先创建，需要使用时只需要标记为使用） 9.6 虚拟内存中的其他考虑预先调页在纯请求调页中，进程启动初期会有大量的缺页中断 预先调页在引用前，调入进程的所有或一些需要的页面，从而减少缺页 页面尺寸没有最佳答案，取决于考虑的方面。但总的来说，现代操作系统趋向更大的页 页表大小：需要大的页，从而减少页表项 碎片：需要小的页 I/O开销：需要大的页，因为磁盘的寻道时间和延迟时间远超传输时间 程序局部：需要小的页，从而精确匹配程序局部 缺页次数：需要大的页，因为每次缺页会产生大量的额外开销 TLB的命中率TLB范围：通过TLB所访问的内存量 $$TLB范围=（TLB大小）\\times （页大小）$$ 理想情况下，一个进程的工作集应存放在TLB中，否则会有大量的缺页中断 反向页表I/O互锁允许某些页在内存中被锁住 为了防止I/O出错，有两种解决方案： 不允许用户内存进行I/O 允许页锁在内部，锁住的页不能被置换 其他Tips 可以实现虚拟存储的存储管理方法：分页、分段、段页式 缺页中断属于程序中断 程序部分装入技术可带来的好处有：1.更多的进程可以并发执行，提高了CPU的利用率 2.每个进程所需的内存量更小 3.载入或交换每个用户进程到内存所需的I/O会更少 4.进程大小不再受到物理内存大小的限制 请求式分页的优点：1.系统能够快速响应 2.需要很少的物理内存 3.可以支持多用户 4.需要很少的I/O 在采用虚存的系统中，要求程序运行前不必全部装入内存且在运行过程中不必一直驻留在内存 第十章 文件系统接口10.1 文件文件概念文件是计算机中信息存储的基本组织形式；是具有文件名的相关信息集合。 文件结构是指文件内信息的组织方式。 目的是便于程序理解文件内容。操作系统和应用程序决定了文件的结构。 常用文件结构 无结构：字节流等 简单记录结构：线性、固定长度、可变长度等 复杂结构：格式化文档、多媒体文件等 一般可执行文件采用的文件结构是字符流 文件类型文件类型一般由扩展名决定，如.txt .doc等 文件属性文件名、文件位置、文件类型、文件大小、保护、时间 文件操作创建文件、写、读、打开、关闭、截断、删除等 打开文件操作不是一个文件系统中必须具有的操作 系统中的数据结构 打开文件表：跟踪打开文件 文件指针：指向最后一次读写的位置，每个进程有一个 打开文件计数器：打开文件（调用open()）次数 访问控制 10.2 逻辑文件及其访问方法文件访问文件系统的主要功能是文件访问，也就是检索、读写等操作 逻辑文件逻辑文件指文件呈现在用户面前的组织结构，又称为文件逻辑结构 逻辑文件决定了文件访问方法，不同的逻辑文件有不同的访问方式 顺序访问：按照存放顺序依次访问，如磁带 直接（随机）访问：可以随机访问，如磁盘、光盘 顺序文件顺序文件是最常用的文件组织形式，由一系列不等长记录按照某种顺序排列形成。只能顺序访问 优点：记录存储紧凑 缺点：访问效率差 直接（随机）文件采用直接访问方式，直接文件一般组织为记录等长的文件 优点：访问效率高，可直接定位到某条记录 缺点：浪费存储空间（因为记录可能不等长，要使记录等长，就要把每条都扩充到最长记录的大小） 索引文件为了结合顺序文件和直接文件的优点，为顺序文件建立索引表，表项等长以便随机访问，表中每项中有指针指向文件中的记录 索引文件广泛用于组织需要频繁检索的文件，如数据库文件等 10.3 文件目录文件控制块FCB用以保存文件的各种属性信息 必须通过文件控制块来访问文件 目录目录由目录项有序构成，一个目录中的目录项组成了目录文件，每个目录项存放了一个文件的各类属性 在有的操作系统中，目录项 = 文件控制块 目录是用户和文件之间的桥梁，负责把文件名转换为文件在存储设备上的位置 inode为了减小目录项的大小，提升文件访问的效率，产生了inode Unix为每个文件控制块建立一个索引项，内容为文件名和指向文件控制块的指针，类似于索引文件，称为Inode 10.4 目录结构目录设计的目标：访问效率、同名文件、文件分组 单层目录只有一个根目录“/” 结构简单，检索效率差，不允许重名，不能分组 双层目录为每个用户建立自己的目录 不同用户可有相同命名的文件；每个用户的文件无法分组，同一用户文件无法重名 树型目录把双层目录进行扩展 检索高效、可以分组、允许重名 图型目录无环图目录：有向边无环，不同目录内可以指向同一文件，实现文件共享 通用图（有环图）目录：允许图中有环，会出现目录内的文件又指回目录的情况 文件共享硬链接：硬链接文件具有相同inode的节点号。硬链接文件是普通文件。 新建一个文件f1，内容为”this is file1”，再ln f1 f2，创建f1的硬链接f2。此时f2中的内容也为”this is f1”。将f1或f2删除，不影响另一个文件。f1和f2的inode相同。 符号链接（软链接）：就是快捷方式。软连接文件和源文件是不同的文件，文件类型不同，inode号也不同。 新建一个文件f1，内容为”this is file1”，再ln -s f1 f3，创建f1的符号链接f3。此时f3中的内容也为”this is f1”。将f1删除，f3依然存在，但无法访问。f1和f3的inode不同。 Tips 一般可执行文件采用的文件结构是字符流 打开文件操作不是一个文件系统中必须具有的操作 在文件系统中，打开文件的主要操作是创建一个目录项（错） 可以实现文件共享的目录结构是图型目录 文件的逻辑结构一般可能由应用程序、操作系统、用户决定 第十一章 文件系统实现11.1 文件系统文件系统是操作系统中负责管理和存储文件信息的模块，提供了在存储设备上组织文件的方法和数据结构 在系统角度上 文件系统对存储设备的空间进行组织和分配，负责文件检索、读写等操作 目标：存取速度和存储空间效率 在用户角度上： 文件系统提供按名存取的文件访问机制、文件的组织管理 目标：方便的文件存取机制 文件系统的层次架构从低到高：设备-&gt;I/O控制-&gt;基本文件系统-&gt;文件组织模块-&gt;逻辑文件系统-&gt;应用程序 基本文件系统：物理块读写、向设备驱动程序发送控制命令 文件组织模块：管理文件、逻辑块和物理块；把文件的逻辑地址转为物理地址；管理空闲空间；为文件分配物理块 逻辑文件系统：文件按名存取；文件目录组织管理；把文件名转换为文件ID、文件句柄；管理FCB 文件系统实现磁盘文件系统 引导控制块：只有安装操作系统的分区才有 分区控制块：包含分区信息 目录和FCB 用户文件 内存文件系统 分区表：所有安装分区信息 目录缓冲结构：保存最近访问的目录信息 进程打开文件表 系统打开文件表 虚拟文件系统 把多个文件系统整合成一个目录结构，为用户屏蔽各个文件系统的差异 网络文件系统 通过LAN（或WAN）访问远程文件系统 常用文件系统Window：FAT, NTFS Linux：Ext(Ext2, Ext3, Ext4) （Ext：基于扩展的文件系统） MacOS：HFS 11.2 连续分配物理块：存储设备的基本分配单位。系统以物理块为单位为文件分配存储空间。物理块的大小和页面大小相对应 逻辑块：在文件空间中的块。大小和物理块一致，一个逻辑块存储在一个物理块中。块号从0开始 连续分配：每个文件在磁盘上占用一组连续的物理块。访问文件时，FCB只需给出&lt;起始块号，长度&gt; 地址映射：将逻辑地址（一维）映射到物理地址（二维）。 优点：支持随机访问、存取速度快、适用一次性写入操作 缺点：浪费空间（小空间无法分配）、文件不能动态增长、不利于文件的插入和删除 11.3 链接分配链接分配：文件信息存放在若干个不连续的物理块中，所有物理块通过指针链接成链表结构 优点：提高磁盘的利用率、可以动态扩充文件大小、便于文件的插入和删除 缺点：无法实现随机访问、可靠性差 分类 隐式链接：链表的指针分散存放在物理块中 为了读入一个指针需要读入整个物理块 显示链接：指针集中存放，把所有指针存放在一张链接表中 链接表一般在文件系统装载时装入内存 不适合大容量磁盘（因为此时链接表会非常大） 例子：FAT 11.4 索引分配索引块：存放指向每个物理块块号的物理块 访问文件时，先访问该文件的索引块，再从索引块中找到文件所占的物理块 优点：支持随机访问（先访问索引块，再访问具体块）、离散存储，没有碎片 缺点：需要额外空间存放索引表、磁盘访问时间增加（物理块分布在磁盘各地） 多级索引大文件无法用单级索引实现，于是产生了多级索引 例如，物理块大小4KB，表项大小4B，每个索引块中可以存放4KB/4B=1K个表项，所以单级目录支持的最大文件是1K*4KB=4MB n级索引文件大小：$(1K)^n\\times 4KB$ 联合策略Unix中采用多种索引混合的策略 11.5 空闲空间管理空闲表空闲区：连续的未分配物理块集合 空闲表：&lt;首块块号, 长度&gt;。每个表项对应一个空闲区。适用连续分配 空闲链表将磁盘上所有空闲块链接在一个链表中 分配：从链表头依次摘下适当数目的空闲块 回收：空闲块加入链表尾部 位示图利用二进制一位来表示一个块的使用情况，1代表盘块空闲，0代表盘块已分配 所有块都有一个二进制位与之对应 位示图需要额外的空间，存放在物理块中。分配时，将1改成0，回收时，将0改成1 成组链接结合了空闲表和空闲链表 例如Unix系统中： 将空闲块分成若干组，每100块为一组 每组第一个空闲块中包括：空闲块总数、下一组空闲块首块的块号、本组其它空闲块的块号列表 一致性检查将目录结构数据与磁盘空闲块结构相比较，纠正发现的不一致 空闲空间整理把不连续的空闲块集合在一起 有利于给文件分配连续的物理块 Tips 采用离散分配的磁盘空间分配方法有：链接分配、索引分配、基于扩展的文件系统（Ext） 文件信息隐藏在若干个不连续物理块中的链接分配模式是隐式链接 第十二章 大容量存储器结构12.1 磁盘结构和管理磁盘结构盘片、磁头、主轴；接口、磁盘控制器、缓冲区 盘片结构磁道、扇区、柱面 地址映射关系块号 LBA 磁盘地址（CHS）格式：&lt;柱面Cylinder，磁头/面Head，扇区Sector&gt; $$柱面号 = 块号 / (每个磁道扇区数 \\times 扇面数)$$ $$磁头号 = (块号 / 每个磁道扇区数)\\mod 扇面数$$ $$扇区号 = (块号\\mod 每个磁道扇区数) + 1$$ 磁盘访问时间$$磁盘访问时间 = 寻道时间 + 寻道延迟时间 + 传输时间 + 系统开销时间$$ 例：4KB块，7200 RPM磁盘， 5ms平均寻道时间，1Gb/sec传输率，0 .1ms 控制开销： 5ms + 0.5 * (7200 / 60)s + 4KB / 1Gb/s + 0.1ms = 9.30ms 磁盘管理低级格式化（物理格式化）：将磁盘分成扇区，以便磁盘控制器读写 分区：将磁盘分成分区，主分区和扩展分区 高级格式化（逻辑格式化：创建文件系统 引导块 12.2 磁盘调度和RAID磁盘调度目标是减少磁盘访问时间，使寻道时间最小化 调度算法先来先服务 FCFS 最短寻道时间优先 SSTF 饥饿 扫描算法/电梯算法 SCAN 到达另一端时，磁头改变移动方向 饥饿 循环扫描算法 C-SCAN 从起始位置移动到一端，中间处理请求。然后从一端回到另一端，这个过程不处理请求 单向处理请求 磁头从硬盘外道（0道）移动到内道的过程中处理请求 内道移动到外道的过程中不处理请求 具有更加均匀的等待时间 循环LOOK算法 C-LOOK C-SCAN的变形，磁头只移动到一个方向上最远请求为止，而不是继续移动到磁盘尽头 实际上，SSTF 较为普遍而且很有吸引力，SCAN和C-SCAN适合磁盘大负荷系统（数据库） RAID结构由很多价格较便宜的磁盘，组合成一个大容量的磁盘组，利用个别磁盘提供数据所产生的加成效果提升整个磁盘系统效能和可靠性 可靠性：引入冗余 性能：数据分散在多个磁盘，并行读写 RAID级别RAID 0 数据分散在多个磁盘上 提高读写性能 不具有容错功能 RAID 1 磁盘镜像 提高可靠性 RAID 5 分散 + 校验 校验信息分散在各个磁盘 RAID 01 / RAID 10 RAID 0 重视性能，RAID 1 重视可靠性 RAID 01 先做分散，再镜像，性能好 RAID 10 先镜像，再分散，可靠性好 Tips 不具有容错功能的RAID技术是RAID 0 数据库服务器的磁盘一般采用的磁盘调度算法是SCAN 具有更加均匀的等待时间的磁盘调度算法是C-SCAN 可能存在饥饿现象的磁盘调度算法是SCAN、SSTF 操作系统的引导程序一般存放在ROM中（错误，自举程序存放在ROM中，引导程序在磁盘中） 第十三章 I/O系统13.1 I/O基本概念I/O系统的基本功能隐藏物理设备的细节、与设备的无关性、提高处理机和I/O设备的利用率、对I/O设备进行控制、确保对设备的正确共享、错误处理 设备独立性引入逻辑设备和物理设备 在应用程序中，使用逻辑设备名来请求使用某类设备，而系统在实际执行时使用物理设备名 内核I/O结构从低到高：硬件 -&gt; 设备驱动程序 -&gt; I/O驱动结构 -&gt; 内核I/O子系统 -&gt; I/O应用接口 -&gt; 应用程序 I/O硬件端口 总线 控制器 I/O硬件控制控制设备方法 直接I/O指令 内存映射I/O I/O寄存器 状态寄存器 控制寄存器 数据输入寄存器 数据输出寄存器 I/O设备的类型按使用特性分类：存储设备、I/O设备 按传输速率分类：低速设备（键盘、鼠标）、中速设备（打印机）、高速设备（磁带、磁盘） 低速设备一般被设置成独占设备 按信息交换的单位分类：块设备、字符设备 按设备的共享属性分类：独占设备、共享设备 独占设备应该采用静态分配策略 13.2 I/O控制方式轮询又称“可编程I/O” 由用户程序自己控制的I/O控制方式 流程：由设备定时发出询问，询问设备是否忙，忙则进程进入忙等，不忙则进行I/O 特点：容易实现，但效率偏低；CPU会长期处于忙等状态。实际上基本不用。 中断CPU硬件有一根中断请求线IRL 流程： CPU执行完每条指令后，检测IRL 如检测到信号，CPU保存当前状态，并跳转到中断处理程序 执行中断处理程序 执行完毕，清除中断，返回 中断（interrupt）和陷入（trap） 中断是CPU对I/O设备发来的中断信号的一种响应 陷入是指CPU内部事件所引起的中断（除以0等） 中断向量表 中断向量表存放每个设备的中断处理程序的入口地址 中断处理程序 检测是否有未响应的中断信号 保护被终端进程的CPU环境 转入相应的设备处理程序 中断处理 恢复CPU的现场并退出中断 DMA直接内存访问（Direct Memory Access） 绕过CPU，直接在I/O设备和内存之间传输数据 13.3 I/O内核子系统内核提供与I/O相关的许多服务，如调度、缓冲、缓存、假脱机等，建立在硬件和设备驱动程序的基础设施之上，还保护自己免受错误进程和恶意用户的危害 I/O改善计算机效率的一个方法是进行I/O调度，另一个方法是使用主存或磁盘上的存储空间的技术，如缓冲、高速缓存、假脱机等 I/O调度操作系统开发人员通过为每个设备维护一个请求队列来实现调度 缓冲（Buffering）缓冲区是一个存储区域，可以由专门的硬件组成；更多的是利用内存 缓冲的用途： 解决设备之间的速度差异 协调传输数据大小不一样的设备 支持应用程序I/O的复制语义 高速缓存（Cache）假脱机（SPOOLing）为了缓和CPU的高速性与I/O设备的低速性之间的矛盾而引入了脱机输入、脱机输出技术 原理：程序模拟脱机输入，把低速I/O设备上的数据传送到高速磁盘上；另一程序模拟脱机输出，把数据从磁盘传送到低速输出设备 输入进程模拟脱机输入时的外围控制机，将用户要求的数据从输入设备通过输入缓冲区再送入输入井，当CPU需要输入数据时，直接从输入井读入内存。输出同理。 特点：提高了I/O的速度；将独占设备改造为共享设备，实现了虚拟设备的功能 错误处理Tips 一个设备控制器可以连接多个设备 需要CPU干预最少的I/O控制方式是SPOOLING 使用SPOOLing系统的目的是为了提高I/O设备的使用效率 操作系统使用的缓冲技术，多数通过使用内存来实现 低速设备一般被设置成独占设备 独占设备应该采用静态分配策略 基于中断机制的I/O方式是一种同步的I/O方式（错误）","link":"/2022/08/24/OS-Kaoyan/"},{"title":"考研数据结构笔记","text":"With renewed hope, we continue forward. 第一章 绪论1.1 数据结构的基本概念数据结构三要素 数据的逻辑结构 线性结构：线性表（包含栈、队列、数组） 非线性结构：集合、树、图 数据的存储结构 顺序存储：可以实现随机存取；如顺序表 链式存储：只能实现顺序存取；如邻接表 索引存储 散列存储 数据的运算 1.2 算法和算法评价一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它长。 算法原地工作指的是所需的额外辅助空间是常量，而不是指不需要任何额外辅助空间。 第二章 线性表2.1 线性表的定义和基本操作线性表是具有相同数据类型的n个数据元素的有限序列。是一种逻辑结构。 2.2 线性表的顺序表示（顺序表）线性表中元素的位序是从1开始的，而数组中元素下标是从0开始的。 2.2.1 基本操作 定义 12345#define InitSize 100typedef struct { ElemType *data; int MaxSize, length;} SqList; 插入 在顺序表的第i个位置插入新元素e。 平均时间复杂度为$O(n)$。 12345678910bool ListInsert(SqList &amp;L, int i, ElemType e) { if (i &lt; 1 || i &gt; L.length + 1) return false; // i == 1，即插入到最前面；i == length + 1，即插入到最后面 if (L.length &gt;= MaxSize) return false; // 满了 for (int j = L.length; j &gt;= i; j --) { // 顺序表的第i个位置，即为数组的第i - 1个位置 L.data[j] = L.data[j - 1]; } L.data[j - 1] = e; L.length ++; return true;} 删除 删除顺序表L中第i$（1&lt;=i&lt;=L.length）$个位置的元素，用引用变量e返回。 平均时间复杂度为$O(n)$。 123456789bool delete(SqList &amp;L, int i, ELemType &amp;e) { if (i &lt; 1 || i &gt; L.length) return false; // 判断i的范围是否有效 e = L.data[i - 1]; for (int j = i; j &lt; L.length; j ++) { L.data[j - 1] = L.data[j]; } L.length --; return true;} 按值查找 在顺序表L中查找第一个元素值等于e的元素，返回其位序。 平均时间复杂度为$O(n)$。 1234567int LocateElem(SqList &amp;L, int e) { for (int i = 0; i &lt; L.length; i ++) { if (L.data[i] == e) return i + 1; // 时刻牢记顺序表的位序 == 数组下标 + 1 } return -1; // 表示没找到} 2.3 线性表的链式表示（链表）2.3.1 单链表的定义和基本操作 定义 1234typedef struct LNode { ElemType data; struct LNode * next;}LNode, *LinkList; 头插法建立单链表 从一个空表开始，生成新结点，并将读取到的数据放到新结点的数据域中，然后将新结点插到当前表的表头（头结点之后）。 表中元素的顺序和输入顺序相反。 每个结点插入的时间为$O(1)$，总时间为$O(n)$。 12345678910111213141516// 头插法建立单链表// 表中元素的顺序和输入顺序相反LinkList List_HeadInsert(LinkList &amp;l) { LNode *s; int x; L = (LinkList)malloc(sizeof(LNode)); L -&gt; next = nullptr; scanf(&quot;%d&quot;, &amp;x); while (x != 9999) { // 输入9999以停止输入 s = (LNode*)malloc(sizeof(LNode)); s -&gt; data = x; s -&gt; next = L -&gt; next; L -&gt; next = s; scanf(&quot;%d&quot;, &amp;x); } return L;} 尾插法建立单链表 增加一个尾指针r，使其始终指向链表的尾结点。 时间复杂度和头插法相同。 123456789101112131415161718// 尾插法建立单链表// 设立一个尾指针指向尾结点LinkList List_TailInsert(LinkList &amp;L) { int x; L = (LinkList)malloc(sizeof(LNode)); L -&gt; next = nullptr; LNode *s, *r = L; scanf(&quot;%d&quot;, &amp;x); while (x != 9999) { s = (LNode*)malloc(sizeof(LNode)); s -&gt; data = x; s -&gt; next = nullptr; r -&gt; next = s; r = s; scanf(&quot;%d&quot;, &amp;x); } return L;} 按序号查找结点值 从头往后搜索，如果没找到则返回空。 时间复杂度为$O(n)$。 12345678910111213// 按序号查找结点// 返回结点的指针。如果没找到，就返回最后一个结点的指针域nullptrLNode *GetELem(LinkList &amp;L, int k) { int i = 1; LNode *p = L -&gt; next; if (k == 0) return L; // 如果 k == 0，返回头结点 if (k &lt; 0) return nullptr; // 如果输入不合法，返回空指针 while (p &amp;&amp; i &lt; k) { p = p -&gt; next; i ++; } return p;} 按值查找表结点 从头往后查找，若某结点数据域的值等于给定值e，返回该结点的指针。若没找到则返回空。 时间复杂度为$O(n)$。 123456789// 按值查找表结点LNode *LocateElem(LinkList L, ElemType e) { LNode *p = L -&gt; next; while (p) { if (p -&gt; data == e) return p; p = p -&gt; next; } return nullptr;} 插入结点 将值为x的新结点插入单链表的第i个位置上。先检查插入的合法性，再找到待插位置的前驱结点，即第i-1个结点，再在其后插入。 时间复杂度为$O(n)$。 1234567891011// 插入结点// 将新结点插到第i个位置bool List_Insert(LinkList &amp;L, ElemType x, int i) { LNode * pre = GetELem(L, i - 1); if (pre == nullptr) return false; // 没有第i - 1个结点，插入失败 LNode * s = (LNode*)malloc(sizeof(LNode)); s -&gt; data = x; s -&gt; next = pre -&gt; next; pre -&gt; next = s; return true;} 删除结点 将第i个结点删除。先判断合法性，再查找到第i个结点的前驱结点，修改其后继指针。 时间复杂度为$O(n)$。 1234567891011// 删除结点// 删除第i个结点bool List_Delete(LinkList &amp;L, int i) { LNode * pre = GetELem(L, i - 1); if (pre == nullptr) return false; // 没有第i - 1个结点，删除失败 LNode * s = pre -&gt; next; pre -&gt; next = s -&gt; next; s -&gt; next = nullptr; free(s); return true;} 2.3.2 双链表 定义 双链表结点中有两个指针prior和next，分别用来指向前驱结点和后继结点。 插入 将s结点插入p之后 1234567// 先处理s的前后指针s -&gt; next = p -&gt; next;s -&gt; prior = p;// 再处理s的后继结点的前指针p -&gt; next -&gt; prior = s;// 最后把p的next指向sp -&gt; next = s; 删除 删除p的后继结点q。 123p -&gt; next = q -&gt; next;p -&gt; next -&gt; prior = p;free(q); 2.3.3 循环链表 循环单链表 在循环单链表中，尾结点的next指针指向L，所以表中没有指向nullptr的结点。 判断表空的条件：头结点的next指向头结点。 循环双链表 判断表空的条件：头结点的prior和next都指向头结点。 第三章 栈、队列和数组3.1 栈栈是只允许在一端进行插入或删除操作的线性表。（操作受限的线性表） 栈的数学性质：$n$个不同元素进栈，出栈元素的不同排列的个数为$\\frac{1}{n+1}C_{2n}^{n}$ 3.1.1 顺序栈的定义和基本操作采用顺序存储的栈称为顺序栈。 初始时，top = -1 栈空条件：top == -1 栈满条件：top == MaxSize - 1 栈顶指针top指向栈顶元素。入栈时，先++top，再赋值；出栈时，先取值，再让top--。 定义 12345typedef struct SqStack{ ElemType data[MaxSize]; // stack int top; // pointer to the top of the stack} SqStack; 入栈 1234567bool push(SqStack &amp;s, int x){ if (s.top == MaxSize - 1) return false; s.data[++s.top] = x; // 栈顶指针先加1 再赋值 return true;} 出栈 1234567bool pop(SqStack &amp;s, int &amp;x){ if (stackEmpty(s)) return false; x = s.data[s.top--]; // 先取值 栈顶指针再减1 return true;} 3.1.2 链栈采用链式存储的栈叫做链栈。 优点是便于多个栈共享存储空间以提高效率，且不存在栈满上溢的情况。 规定所有操作都在表头实现。 3.2 队列队列也是一种操作受限的线性表。 3.2.1 队列的顺序存储队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置。（做题时，队头と队尾をよく区別してくれ！） 初始状态：q.front == q.rear == 0（不能用来判断队满） 进队：q.rear = x; q.rear++ 出队：x = q.front; q.front--; 3.2.2 循环队列初始状态：q.front == q.rear 队首指针前进1：q.front = (q.front + 1) % maxsize 队尾指针前进1：q.rear = (q.rear + 1) % maxsize 队空和队满时都有：q.front == q.rear，那么如何区分？ 通常会牺牲一个存储单元，保持其为空，即入队少用一个队列单元。此时约定“队头指针在队尾指针的前一个位置时为队满”，即(q.rear + 1) % maxsize == q.front，队空时仍为q.front == q.rear。 3.2.3 队列的链式存储链队列是一个同时带有队头指针和队尾指针的单链表。 出队时在链表头删除元素，入队时在链表尾插入元素。所以队头指针设在链表的表头位置，队尾指针设在链表的表尾位置。 适用于数据元素变动比较大的情形，而且不存在队列满且产生溢出的问题。 3.3 栈和队列的应用3.3.1 栈的应用 括号匹配 表达式求值（中缀表达式转后缀表达式） 递归 进制转换 迷宫求解 3.3.2 队列的应用 缓冲区 树的层次遍历（图的BFS） 第四章 串KMP Algorithm 第五章 树与二叉树5.1 树的基本概念5.1.1 树的性质 树中的结点数等于度数+1 度为$m$的树中第$i$层上至多有$m^{i-1}$个结点 高度为$h$的$m$叉树至多有$(m^h-1)/(m-1)$个结点（等比数列求和公式） 具有$n$个结点的$m$叉树的最小高度为$\\log_m^{[n(m-1)+1]}$（向上取整） 树的路径长度是树根到每个结点路径长度的总和。 5.2 二叉树的概念5.2.1 二叉树的性质 非空二叉树的叶子结点数等于度为2的结点数加1。即$n_0=n_2+1$ 具有$n$个结点的完全二叉树的高度是$\\log_2^{n+1}$（向上取整） 5.2.2 二叉树的存储顺序存储结构 链式存储结构 在含有$n$个结点的二叉链表中，含有$n+1$个空链域。 5.3 二叉树的遍历和线索二叉树5.3.1 二叉树的遍历 先序遍历 递归写法 12345678void preorderTraversal(TreeNode *root){ if (root == nullptr) return; visit(root); preorderTraversal(root-&gt;left); preorderTraversal(root-&gt;right);} 迭代写法 使用了一个栈作为辅助。首先将根结点入栈，然后每次迭代将栈顶元素出栈，再将其右孩子、左孩子入栈。 顺序很重要，先右孩子入栈，再左孩子入栈，这样出栈的时候才是中左右的顺序。 123456789101112131415161718192021void preorderTraversal_it(TreeNode *root){ stack&lt;TreeNode *&gt; st; vector&lt;int&gt; res; if (root == nullptr) return; st.push(root); while (!st.empty()) { TreeNode *top = st.top(); st.pop(); res.push_back(top-&gt;val); if (top-&gt;right != nullptr) st.push(top-&gt;right); if (top-&gt;left != nullptr) st.push(top-&gt;left); } for (int x : res) cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; endl; return;} 中序遍历 递归写法 12345678void inorderTraversal(TreeNode *root){ if (root == nullptr) return; preorderTraversal(root-&gt;left); visit(root); preorderTraversal(root-&gt;right);} 非递归写法 同样使用一个栈作为辅助。但是和前序遍历不一样的是，出栈顺序是左中右，所以需要调整入栈顺序。首先一路走到树的最左结点，路上访问到的结点都入栈。此时栈顶元素是最左结点，将其出栈，输出；随后的栈顶元素即为其父结点，将其出栈并输出，然后将其右孩子入栈，之后再找到右子树的最左结点，重复以上操作。 cur一直找左孩子，直到找到最左孩子，再继续cur = cur -&gt; left之后cur == nullptr，这时栈顶元素就是它的父亲，也就是整棵树的最左结点。左结点在这个时候出栈并输出。 123456789101112131415161718192021void inorderTraversal_it(TreeNode *root){ stack&lt;TreeNode *&gt; st; vector&lt;int&gt; res; TreeNode *cur = root; while (!cur || !st.empty()) { if (!cur) { st.push(cur); cur = cur-&gt;left; } else { cur = st.top(); st.pop(); res.push_back(cur -&gt; val); // 中间结点入栈 cur = cur -&gt; right; // 右结点入栈。如果cur此时是叶子结点，这句语句之后cur为空，保证了不会死循环 } } for (int x : res) cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; endl; return;} 后序遍历 递归写法 12345678void postorderTraversal(TreeNode *root){ if (root == nullptr) return; preorderTraversal(root-&gt;left); preorderTraversal(root-&gt;right); visit(root);} 非递归写法 只需要在先序遍历的基础上修改一下。 先序遍历是中左右，后序遍历是左右中。所以只需要把先序遍历循环中的两句交换顺序，变成中右左，然后再逆序输出就是后序遍历了。 123456789101112131415161718192021void postorderTraversal_it(TreeNode *root){ stack&lt;TreeNode *&gt; st; vector&lt;int&gt; res; if (root == nullptr) return; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); res.push_back(root -&gt; val); if (root -&gt; left != nullptr) st.push(root -&gt; left); if (root -&gt; right != nullptr) st.push(root -&gt; right); } reverse(res.begin(), res.end()); for (int x : res) cout &lt;&lt; x &lt;&lt; &quot; &quot;; return;} 层次遍历 借助一个队列。把每层的元素从左到右加入队列中，然后出队并输出。出队元素如果有孩子结点，也按照从左到右的顺序继续加入队列中。 123456789101112131415161718192021222324void levelOrder(TreeNode* root){ queue&lt;TreeNode*&gt; q; vecrot&lt;vectot&lt;int&gt;&gt; res; if (root != nullptr) q.push(root); while (!q.empty()) { int size = q.size(); vector&lt;int&gt; level_vals; for (int i = 0; i &lt; size; i ++) { // 循环次数 == 这一层元素的个数 TreeNode* cur = q.front(); level_vals.push_back(cur -&gt; val); if (cur -&gt; left != nullptr) q.push(cur -&gt; left); if (cur -&gt; right != nullptr) q.push(cur -&gt; right); q.pop(); } res.push_back(level_vals); } for (int x : res) cout &lt;&lt; x &lt;&lt; &quot; &quot;; return;} 5.3.2 线索二叉树在含$n$个结点的二叉树中，有$n+1$个空指针，将这些空指针利用起来，指向结点的前驱/后继，即是线索二叉树。 引入线索二叉树是为了加快查找结点前驱和后继的速度。 5.4 树、森林5.4.1 树、森林、二叉树的转换树转换为二叉树的规则：（左孩子右兄弟）每个结点左指针指向它第一个孩子，右指针指向它在树中的相邻右兄弟。 5.4.2 树和森林的遍历树的遍历 先根遍历：先访问根结点，再遍历子树。遍历序列和相对应的二叉树先序序列相同。 后根遍历：先遍历子树，再访问根结点。遍历序列和对应的二叉树中序序列相同。 森林的遍历 先序遍历森林 中序遍历森林 中序遍历森林中第一棵树的根结点的子树森林 访问第一棵树的根结点 中序遍历除去第一棵树之后剩余的树构成的森林 森林的先序遍历和中序遍历即为对应二叉树的先序遍历和中序遍历。 树 森林 二叉树 先根遍历 先序遍历 先序遍历 后根遍历 中序遍历 中序遍历 第六章 图6.1 图的基本概念简单图：不存在重复边；不存在顶点到自身的边。 连通图、连通分量：在无向图中，如任意两个顶点都是连通的，则称其为连通图；无向图中的极大连通子图称为连通分量。 强连通图、强连通分量：将上条中的无向图换成有向图。 生成树：连通图的生成树是包含图中所有结点的极小连通子图。有$n$个结点和$n-1$条边。 简单路径、简单回路：顶点不重复出现的路径称为简单路径；除第一个顶点和最后一个顶点以外，其余顶点不重复出现的路径叫做简单回路。 6.2 图的存储邻接矩阵 邻接表 十字链表：用于有向图 邻接多重表：用于无向图 6.3 图的遍历 遍历方式 时间复杂度(邻接表/邻接矩阵) 空间复杂度 DFS O(V+E)/O(V^2) O(V)（递归） BFS O(V+E)/O(V^2) O(V)（队列） 6.3.1 广度优先搜索6.3.2 深度优先搜索可以用来判断图中是否存在回路 6.4 图的应用6.4.1 最小生成树6.4.2 最短路径6.4.3 拓扑排序6.4.4 关键路径","link":"/2022/07/21/DS-Kaoyan/"},{"title":"最短路问题","text":"いつの日かdistanceも 抱きしめられるようになれるよ 问题分类单源最短路 从一个点到其他所有点的最短距离 不存在负权边 朴素Dijkstra算法 $O(n^2)$ 堆优化版的Dijkstra算法 $O(m\\log n)$ 存在负权边 Bellman-Ford算法 $O(nm)$ SPFA $一般O(m)，最坏O(nm)$ 多源汇最短路 有多个起点到不同点的最短距离 Floyd算法 $O(n^3)$ 模板Dijkstra算法适用于无负权边的图。可以有重边或自环。 算法思想 定义一个distance[]数组，distance[i]表示从起点到点i的距离。 将distance[]初始化，distance[1] = 0，表示起点到自己的距离为0。其余全部赋值为INF，表示还未找到最短距离。 定义一个集合st[]，每当找到一个点i到起点的最短路时，st[i] = true，将点i加入集合中。 迭代n次，每次搜索所有未加入集合中的点，从中找到distance最小的那个点t，将其加入集合中。然后更新distance[]，判断t加入路径之后经过t的新路径距离是否小于原路径。 朴素DijkstraDijkstra求最短路 I不使用任何数据结构进行维护，时间复杂度为$O(n^2)$，适用于稠密图。 实现123456789101112131415161718192021222324252627282930313233343536const int N = 510;int n, m;int g[N][N]; // 邻接矩阵存图int dist[N];bool st[N];int dijkstra(){ memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; n; i++) { int t = -1; for (int j = 1; j &lt;= n; j++) { if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) { t = j; } } st[t] = true; for (int j = 1; j &lt;= n; j++) { dist[j] = min(dist[j], dist[t] + g[t][j]); } } if (dist[n] == 0x3f3f3f3f) return -1; else return dist[n];} 堆优化的DijkstraDijkstra求最短路 II用堆存储所有点到起点的距离，这样每次找distance最小的那个点t的时间复杂度就是$O(1)$ ，而更新其他点的距离的操作变为$O(\\log n)$。本题中点和边数均为$10^5$，所以是稀疏图，用邻接表来存。 实现123456789101112131415161718192021222324252627282930313233343536373839typedef pair&lt;int, int&gt; PII;const int N = 150010;int h[N], e[N], ne[N], w[N], idx;int dist[N];bool st[N];int n, m;int dijkstra(){ memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.first, distance = t.second; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n];} Bellman-Ford算法有边数限制的最短路Bellman-Ford 算法是一种基于松弛（relax）操作的最短路算法，可以求出有负权的图的最短路，并可以对最短路不存在的情况进行判断。适用于有边数限制、有负权边的图。可以用来判断是否有负环。 通常来说，SPFA在各方面都比Bellman-Ford更优。但是如果题中限制了最短路的边数，则只能用Bellman-Ford。 算法思想非常的简单松弛：对于边$(u, v)$，松弛操作对应下面的式子$dist(v)=\\min(dist(v),dist(u)+w(u,v)$也就是如果从源点直接到$v$点的距离大于从源点先到$u$ 再到 $v$，则将最短路从源-&gt;v 更新为 源-&gt;u-&gt;v 对于有 $n$ 个点， $m$ 条边的图，进行 $n - 1$ 次迭代，每次迭代对所有边进行松弛。直到没有边能够松弛了，算法结束。如果松弛次数大于 $n-1$ ，说明图中有负环（因为一共只有 $n$ 个点，任意两个点之间最多有 $n-1$ 条边）。所以，如果我们想知道是否存在源点到目标点的边数最大为 $k$ 的最短路径，则只要进行 $k$ 次迭代。伪代码如下： 123for n for 所有边 a,b,w dist[b] = min(dist[b],back[a] + w) 实现123456789101112131415161718192021222324const int N = 510, M = 10010;int n, m, k;int dist[N];int back[N]; // 因为每次迭代都会松弛所有边，可能会导致串联，所以使用一个备份，其中存的是上一次迭代的diststruct { int a, b, w;}edges[M];void bellman_ford(){ memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; k; i++) { memcpy(back, dist, sizeof dist); for (int j = 0; j &lt; m; j++) { int a = edges[j].a, b = edges[j].b, w = edges[j].w; dist[b] = min(dist[b], back[a] + w); } }} SPFAspfa求最短路spfa判断负环 算法思想spfa是队列优化后的Bellman-Ford。在Bellman-Ford算法中，每一次迭代都会搜索所有的边，判断是否需要松弛。然而很显然，只有在上一轮迭代中松驰过的边才有可能需要松弛，而其他的边在上一轮是没有发生改变的。所以我们使用一个队列来维护那些可能需要松弛的结点，就不需要每次都访问所有点了。 实现1234567891011121314151617181920212223242526272829303132333435363738const int N = 100010;int n, m;int h[N], e[N], ne[N], w[N], idx;int dist[N];bool st[N];int spfa(){ memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue&lt;int&gt; q; q.push(1); st[1] = true; // st用来标记某个点是否进入队列 while (q.size()) { int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) { q.push(j); st[j] = true; } } } } return dist[n];} Floyd算法Floyd求最短路适用于任何图，可以有负权边。但不能有负环。 算法思想基于高深的动态规划。首先图要用邻接矩阵来存。定义一个数组 g[k][x][y] ，表示 $x$ 只经过 $1, 2 \\dots k$ 到 $y$ 的最短距离。所以 g[n][x][y] 就是 $x$ 到 $y$ 的最短距离。所以进行 $n$ 次迭代，每次 g[k][x][y] = min(g[k - 1][x][y], g[k - 1][x][k] + g[k - 1][k][y] 。而实际上，数组的第一维对结果无影响，所以可以省略。 实现1234567void floyd(){ for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);}","link":"/2022/03/09/Shortest-path/"},{"title":"Trie","text":"介绍trie，又称前缀树或字典树，是一种有序树，用来保存关联数组，其中的键通常是字符串。是一种高效的存储和查找字符串的数据结构。 如图所示，如果我想要查找是否有 cat 这个单词，只需要沿着 c -&gt; a -&gt; t 这条路径走。如果路径上有某个结点不存在，则说明不存在这个单词。另外，如果存在某个单词，我们也需要给这个单词最后的那个结点打上一个标记，表示从根节点走到这个结点的路径是一个单词。 例题题目描述维护一个字符串集合，支持两种操作： I x 向集合中插入一个字符串 $x$；Q x 询问一个字符串在集合中出现了多少次。共有 $N$ 个操作，输入的字符串总长度不超过 $10^5$，字符串仅包含小写英文字母。 输入样例1234565I abcQ abcQ abI abQ ab 输出样例123101 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;const int N = 100010;int son[N][26], cnt[N], idx;char str[N];// son[N]用来存树里的结点 ---&gt; 静态链表// son[N][26]用来表示结点的键值（26个小写字母）// cnt[N]用来统计单词出现次数// idx和静态链表中的idx一样，用来表示当前操作的是第几个结点void insert(char* str) { int p = 0; // 从根节点开始 for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; // 将字母映射成整数 if (!son[p][u]) son[p][u] = ++idx; // 如果结点不存在，则创造这个结点，让它指向下一个操作的结点 p = son[p][u]; } // 循环结束后，p就是这个单词的最后一个字母所在结点 cnt[p]++; // 单词出现次数}int query(char* str) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; if (!son[p][u]) return 0; // 如果想要查找的路径上有结点不存在，说明该单词不存在 p = son[p][u]; } return cnt[p];}int main() { int n; scanf(&quot;%d&quot;, &amp;n); while (n--) { char op; scanf(&quot; %c&quot;, &amp;op); // 坑：scanf在读入单个字符时不会过滤回车，例如在读入一个'a'之后，输入回车的话， // 回车会被存放在缓存区中，下一次scanf会自动把回车读入 // 解决办法：在%前加一个空格，会告诉scanf忽略前面的空行，而等待第一个非空行元素读入其中。 if (op == 'I') { scanf(&quot;%s&quot;, str); insert(str); } else { scanf(&quot;%s&quot;, str); printf(&quot;%d\\n&quot;, query(str)); } } return 0;}","link":"/2022/01/28/Trie/"},{"title":"字符串哈希","text":"介绍利用哈希的思想，实现快速判断两个字符串是否相同。 例题题目描述给定一个长度为 $n$ 的字符串，再给定 $m$ 个询问，每个询问包含四个整数 $l_1,r_1,l_2,r_2$，请你判断 $l_1, r_1$和 $l_2, r_2$ 这两个区间所包含的字符串子串是否完全相同。 字符串中只包含大小写英文字母和数字。 输入格式第一行包含整数 $n$ 和 $m$，表示字符串长度和询问次数。 第二行包含一个长度为 $n$ 的字符串，字符串中只包含大小写英文字母和数字。 接下来 $m$ 行，每行包含四个整数 $l_1,r_1,l_2,r_2$，表示一次询问所涉及的两个区间。 注意，字符串的位置从 $1$ 开始编号。 输出格式对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 Yes，否则输出 No。 每个结果占一行。 输入样例123458 3aabbaabb1 3 5 71 3 6 81 2 1 2 输出样例123YesNoYes 题解根据哈希的思想，我们选择一个类似进制转换的哈希函数。 如 aabb 这个字符串，其映射值为：$$(a * P^0+a * P^1+b * P^3+b * P^4)\\bmod Q$$本题里，我们将其从前往后按照前缀的方式存到 h[] 中，那么有： 1234h[1] = 'a' 的映射值h[2] = 'aa' 的映射值h[3] = 'aab' 的映射值h[4] = 'aabb' 的映射值 而映射时有几个注意点： $P$ 通常取 $133$ 或 $13331$ ，经验证明这样很少发生碰撞。 字母不能映射成 $0$ 否则会发生冲突 ：如果a -&gt; 0 那么 aa -&gt; 0 我们要想知道 $[l_1, r_1]$ 和 $[l_2, r_2]$ 是否相同，那么只要判断二者的哈希值是否相等。那么如何判断二者是否相等呢？ 问题就转化为：已知 h[l1], h[r1] 的值，如何求得 $[l_1, r_1]$ 这一段的哈希值？ 答案是：将 h[l1] 左移 $r-l+1$ 位，它与 h[r1] 的差值就是我们想要求的。如 aa 的哈希值右移两位就是 aa00 ，然后用 aabb 的哈希值减去 aa00 ，就得到 bb 的哈希值。代码如下： h[r] - h [l - 1] * p[r - l + 1] 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned long long ULL;const int N = 100010, P = 131;int n, m;ULL h[N], p[N];char str[N];ULL get(int l, int r) { return h[r] - h [l - 1] * p[r - l + 1];}int main() { scanf(&quot;%d%d%s&quot;, &amp;n, &amp;m, str + 1); // 从 str[1]开始存 p[0] = 1; // 预处理h[N]和p[N] for (int i = 1; i &lt;= N; i ++) { p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + str[i]; } while (m--) { int l1, r1, l2, r2; scanf(&quot;%d%d%d%d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2); if (get(l1, r1) == get(l2, r2)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); } return 0;}","link":"/2022/02/25/StringHashing/"},{"title":"By making a song can I keep the memory?","text":"我的2021年终总结 随着考研告一段落，2021年就这样悄无声息地过去了。而我也在周期性地陷入迷茫，像死鱼一样躺了几天之后，终于想起已经时至年尾，该写些什么来虚假地总结和纪念一下这过去的平凡又乏味的一年了。 尽管我每年都会写年终总结，但每次都不知从何下笔，从取标题开始就被难倒。毕竟只是一个死宅大学生而已，一年里又能发生些什么值得写的事呢？ 姑且容我流水账般回忆一下这一年里发生过的，给我留下印象的事吧。 烟花三月，终于下了一趟扬州。第一次尝试青旅，运气很好，遇见了能够一起吃饭观光的小学弟。算是我的社交恐惧症治愈之路上的第一个疗程吧。 五月和老同学们去了无锡和苏州。有点可惜的是，去的时候赶上节假日，所以到处都是人山人海，以至于没有去成苏州博物馆。以后还要找个时间去一次。 之后就是颓废的暑假。七月在家浪费了一个月，依然是日复一日地做着我浪费生命的老一套。八月开始有了些危机感，复习进度捡起来一些。 回学校之后的时间就好像按下了加速键。每天重复着早起去图书馆，晚上十一点回宿舍的日子。还没等我反应过来，手机上显示的时间就从十月变成了十一月、十二月。 虽然我对于考研并不是抱着玩玩的心态去应付的，但也不到「如果考不上这辈子就完了」的程度。所以尽管我没有哪一天是没去学习的，但没有尽全力这一点我也是心知肚明。可能对我来说，所谓的尽全力根本不存在吧。 所以上考场时的状态不佳也是我自食恶果。但是即使自我感觉再差，过去的事也已经过去，这里就不谈了吧。 今年网易云的年终报告，我听得最多的歌是《Reflexion, allegretto, you》，听了七百多遍。我今年最庆幸的事就是二刷了《利兹与青鸟》，发现了三年前第一次看时没发现的美好。一周内看了四遍，还买了BD，让我找回了当年看君名时的热情。 ED我也听了很多遍。当前奏的吉他声响起时，我的脑海里总是浮现出飘飞的水蓝色裙摆、游曳的夏日光斑和摇摇欲坠的未来。 上大学之后，体感时间流逝得越来越快。回看前几年的年终总结，焦虑和迷茫总是主题。而当下正处在转折点的我，依然在踌躇满志和混吃等死的叠加态中撕扯着，迎来了2022年。 Feeling so anxious each spring time We are flapping about like plastic bags How would I sing? Golden reflections of our life In the afternoon sunlight Chocolates melt in my pocket By making a song can I keep the memory? I just came to love it now","link":"/2022/01/02/2021Summary/"},{"title":"死、宝石、夕阳与春雪","text":"她边说边泛起一种焦灼感。然而，就像向别人描述死、宝石的闪光和夕阳的优美一样，这乃是最难的事情。 前言今天终于把三岛由纪夫的《春雪》读完了。 这是我读的第三本三岛。前两本是《金阁寺》和《假面的告白》。 《金阁寺》是高中的时候读的。读的是唐译本。一方面觉得文字极其精致，一方面也确实掉入了华丽辞藻编织出的陷阱里。 简而言之，没读懂，囫囵吞枣。这本薄薄的，被称作三岛的代表作的小说，在我脑海中留下的印象单薄却持久：那只屹立在金阁寺顶上，在时间和空间的永恒流动中岿然不动的黄金凤凰。 《假面的告白》是几个月前读的。读的是陈译本。这是三岛作为作家，所发表的第一部小说。文字的华美从这时就已经让人哑然。 这本自传性小说，也确实让我得以一窥这位伟大作家的真实。所有这本书的读者肯定都忘不了，那副《圣塞巴斯蒂安殉教图》。我也是从这时候才略微领会三岛对于「美」的追求。 健康、死亡。 这两者都是三岛所追求的美的一环。对于生者——从三岛自己就能看出来——他向往健硕的、威严的、如同太阳与铁的不可逆的肉体。但他更喜欢的，或者说，觉得更美的，则是这不可逆的、象征着生的肉体被死亡所吞噬。 日本人所谓的「物哀」，指的是对于萧条、衰败的景物产生的哀伤之情。而三岛将这种感情投射到人，发展出了独属于他的美学。 所以我在读之前也很容易地猜到了，《春雪》的结局必然是悲剧。 三岛的美学 没有什么东西比已达成的恋情更加不值一提了。 清显和聪子明明两情相悦，为何最后偏偏沦落到一人剃度，一人病逝？ 且抛开三岛的「暴烈」不谈。 清显年方十七八，面对比他大两岁的青梅竹马聪子，在男性和新晋贵族身份的两道枷锁的禁锢下，当然渴望在恋情的角力中掌握主导权。他跟聪子的几次拉扯，虽不理智，但是合理。二人的感情在共赏春雪的时刻达到高潮，这是三岛为读者创造的「美」。 塞林格说：爱是想触碰又收回手。 而清显显然不这样认为。 在聪子和王爷订下婚约后，他才发觉「我热恋着聪子」。在镰仓的海边，在那名为「不可为」的夜幕的包裹之下，三岛将他的美学之幕揭开——「为所不可为」。 这份相互折磨的爱，越是危险，越让人感到欲罢不能。于清显，于聪子，于读者，于三岛，都是这样。 所有人都享受着这份漆黑夜色中的耳鬓厮磨，尽管天空即将破晓、美好面临毁灭也无法收手。因为当这份世俗的美被毁灭，原地重新诞生的将是永恒的美，也是三岛一生所追求的美——「死亡」。 瞎扯《春雪》的阅读体验，实在是我从来都没有经历过的。 首先提一下，这次读的是文洁若的译本。感觉比前两次好读些。 花了一个多月读了三分之二，昨天和今天一口气读完了最后三分之一。在读到最后时，内心也被一种巨大且不可名状的悲伤所填满。以至于读完之后还久久不能平静，整个下午都无心做其他事。 读《春雪》之前，我对三岛的认知是「用华丽的文字包裹简单的故事」。 但是现在看来并非如此，在华丽的文字之下，包裹的是同样华丽的故事。 没有一处描写是无用的，登场的众多人物，每个人的形象都跃然纸上。 借明治维新而成为新兴贵族的松枝家，色厉内荏的松枝侯爵与蹴鞠世家，吃了二十七代皇粮却逐渐衰微的绫仓伯爵。这二人的对手戏，如果深挖的话，想必也是可以对日本贵族制有更加清晰的认识的吧。可惜我学疏才浅，做不到了。 从鹿儿岛来的学伴饭沼、服侍绫仓家几十年的老妪蓼科，两人分别服侍着故事的两位主角，却抱着完全不同的态度。饭沼怒清显不争，无比怀念旧时代，而蓼科则是无条件服从聪子，实质却在谋划十几年的复仇。二人对比，深层次剖析的话，也会很有趣吧。 … 可细细品味的地方太多了。等我把丰饶之海四部读完，多了解一些背景知识，一定再读一遍。 摘抄 清显从海潮的奔腾和漫长时间的流逝中，突然察觉到自己不久也会走入老境，而泛起一阵子窒息的感觉。他从来没有想过要获得什么老年人的智慧。他想的只是怎样才能在年轻的时候就溘然死去，而且尽可能不感觉痛苦。宛若一件华丽绸和服随便脱下来扔在桌子上，不知不觉又滑落在昏暗的地板上那么优雅。 三岛对于死亡的描写太美了。 此刻，忽然觉得天光暗了下来，一群飞鸟从天涯海角涌过来，叫声四起，直逼头顶，清显就举枪勾动了扳机。这不单单是无情的射击，而是心中充满不可言状的愤怒和悲哀，与其说是对着群鸟，莫如说是向着太空那只巨大的蓝眼开的枪。 群鸟一齐被打了下来，眼看着一阵带血的龙卷风呐喊着把天和地连接起来了。所以这么说，那是因为无数的鸟儿嘶鸣着，滴着鲜血，密密麻麻地聚集成一根粗大的望不见顶端的柱子，向着地面的一点俯冲下来，就仿佛是水量极大的瀑布带着吼声和血色，没完没了地从天上落了下来。看上去，确实酷似那连续不动的龙卷风。 这段读起来超有画面感。 恋爱中的男人，他的心是容纳不下恋爱之外的任何事物的。甚至对别人的悲痛，也都丧失了同情心。 两个小伙子心里所拥抱的两个截然不同的世界的影子，将其尖端突出地显示在煤油灯那黄雾般的光圈中。一个因恋爱而卧病，一个为坚固的现实而学习。清显恍如在梦境里，他被海藻缠住了脚，在混沌的爱之海中泅水；本多则向往着牢固地建立在地面上的井井有条的理智的建筑物。 情感和理智，毁灭和秩序。","link":"/2021/06/12/harunoyuki/"},{"title":"ただ力の抜けた光る方へ","text":"我的22考研记录 今天是2021年8月1日。从三月份开始准备，到现在考研进程也已过半。 想着不妨写些东西，一是对前半段的复盘，二是督促自己，三是给以后留个回忆。 择校之前一直无法定下目标院校，在各大高校之间徘徊。一开始是北邮、东南，后来是华科、武大、浙大。不过其实我不太想去北邮，只是因为我校考北邮上岸的很多，所以我下意识觉得应该比较好考而已。 上大学前，我对大学的幻想大多来自汪曾祺先生在其散文中介绍的西南联大。 我想象中的大学，应该更具人文气息。而根据我本科在理工科大学经历的这三年来看，其显然过于冷峻了。 大学之大，不在其面积，而在其包容。学科建设全面一些的大学，我认为是会更加丰富且多元一些的。 所以我很想读一读综合类大学，这是其一。 其二就是，我很想去上海。也不知道哪里来的上海情结，反正就是特别有好感。 说来惭愧，高三的时候很想考华师。当时还跟好朋友约好了，她考交大，我考华师，到时候就是邻居了。 结果两个人都没考上，自然也没做成邻居。 而三年过去了，我还是很想去上海。我想去看各种艺术展，想去梅奔看演唱会，想去cp，想参加上影节。 还是有些985情结。而交大和复旦，我感觉高攀不起。于是华师显然是最好的选择，计算机水平不错，考的人又少。 何况还有意外之喜——华师考的是数二英二。英语倒是无所谓，但是之前一直按照数一备考的我突然感觉松了一口气。数二比数一少了概率论、级数、线面积分之类又多又难的内容，对于我这种被数学按在地上摩擦了一辈子的数学废物来说简直如同天降福音。 「就它了，」在华师官网上看到「数学二」三个字时，我心想，「不要太适合我。」 那么定下目标院校的我，有没有做出相应的努力，好好学习呢？ 呵呵。 于是我浪费了整个七月的时间。 规划八月 现在看来，其实放暑假之前，我在学校里的学习状态还算好，进度也还可以。但是一到暑假就一如往常地陷入了颓废的境地。 既然七月已经被浪费了，那么八月就要加倍努力追上来。每天学习10小时吧。 为了不再只是嘴上说说，姑且列个计划表吧，感觉这样比较有用。 到八月底，应该完成的： 高数强化 计组一轮（8/15） 操作系统一轮（8/23） 数据结构一轮（8/30） 英语刷完16年以前的阅读真题（8/27） 政治每天一小时以内，学到哪算哪 同时也该准备一下九月的PAT了。（战略性放弃，先管初试吧） 今天就先写到这，之后视情况再更新。 九月 既然开学了，能够复习的时间肯定是要少于八月的。 而且返校的那天也要浪费一天。 到九月底，应该完成的： 线代强化 高数880 计网二轮 计组二轮 操作系统二轮 数据结构二轮 英语阅读二刷（优先级低） 时间轴8/15 更新： 今天把计组过完了。打算接下来再按章总结，同时开始复习OS。 英语做到了14年。13年的阅读只错了一个，感觉还不错。 高数目前到一元函数积分学。感觉应该增加做题的时间，减少看视频的时间。 这一周由于胃痛的缘故，学习时间比上周大大减少…上周好不容易对自己有了点信心，又消磨殆尽了。 新的一周，希望专注力能再提高一些，希望胃痛能缓和。 8/23 更新： 操作系统一轮结束。 果然还是比计组友好不少啊。我甚至还做了笔记，居然才花了计组一半的时间。 今天看着操作系统只剩下最后一节，突然就开始提不起劲，以至于下午基本都在摸鱼，晚上才把这一节看完。 明天开始数据结构。之前已经看到第四章了，所以应该两三天就能看完。然后进入二轮，以及增加数学的时间。 高数到常微分方程了。 关于自己老是犯低级错误，算错、看错符号之类的，我也许找到原因了。 还是一直以来困扰着我的问题。大脑活动停不下来，永远被无关紧要的事情占据。 就像进程调度的SJF算法，一直在处理最短的任务，把其他的进程都饿死了。 而我也是，难以把注意力放到眼前重要的事情上面。 比如读书时，思绪读着读着就飞走了，从获取信息变成了只是用视线扫过文字而已。 比如做题时，式子化简之后抄下来，大脑直接放弃思考要不要变号，就原封不动地抄下来。 我不知道这种问题是从何而来，也不知道怎么做才能改善。想来也许是小时候，一边吃饭一边看电视，过早地让自己一心二用，导致没有培养起来专心的能力。以及微博之类的碎片信息流，大概也是一部分原因。 所以最近在尝试冥想正念，让自己什么也不想，排除掉在脑海中过于活跃的杂乱信息。以及在碎片时间尽量不用手机，减少无用信息的摄入。 还有英语，这个就很舒适了。 13年错1个，14年错2个，15年错1个。不知道是我变强了还是阅读变简单了，我现在对英语的信心是前所未有的强。做完阅读之后再尝试做几篇完型吧，做得好的话，说不定真能上85。 不过有点可惜，没有一年是全对的。16年的还没做，不过听说这年比较难。 我也许到极限了。 我是指睡眠时间。 这段时间以来每天睡6小时，中午睡半小时左右。 而我昨天尝试着再缩短一下这个时间。定了5小时的闹钟，但是完全起不来，还是在床上多躺了一个小时。 6小时的睡眠时间是我在高中就尝试过的。当时从哪看到说，人的睡眠周期是一个半小时，睡眠最好是这个时间的倍数。事实证明，我睡6小时确实比睡6个半~7小时精神点。 所以打算今天试试4个半小时睡眠。如果失败的话，那就证明我的极限就是6小时了。 哇，4个半小时，听起来好吓人。真的能做到吗，不会猝死吧？ 8/30 更新： 时间终于来到了八月底。 各项任务也是ギリギリ完成了，还算不错。 今天是开学第一天。不知不觉就大四了，完全没有实感。课虽然不是很多，但总归还是会有影响，只希望影响不要太大。 数学到二重积分了，也就是高数的最后一章。接下来就边刷880边线代。线代感觉没时间再看视频了，直接看书做题吧。进度太慢了，之后要增加学数学的时间。 说是这么说，但还是不愿意自己做题。碰到难点的题就不太想思考。也许是对数学的恐惧积重难返吧。 英语。前几天把16年的阅读刷完了，错了两个。就很遗憾，一次全对都没有，多少有点气馁了。然后把完型给写了，居然全对。不过也不知道是这年阅读比较简单还是我真的挺强。总之这下也是给了我不少信心。如果今年阅读简单点的话，也许85还是挺稳的？（我就随便想想） 接下来打算把英语先放一段时间，挪出时间给数学和408。等到十月再开始作文。 感觉即使看了很多方法论，我做题还是靠语感。读不明白的长难句就多读几遍，一般都能读懂。所以二刷阅读真的有必要吗？ 数据结构。其实早该完成的，毕竟只剩下三章，一天一章完全没有难度。但是还是太摸了，这几天学习状态都不怎么好，所以拖到了现在。 这样的话，408总算是一刷结束了。这一套学下来，果然还是DS最友好，我一刷的正确率也最高。然后计网和OS差不多吧，计组毫无疑问的最难了。 政治。马原部分的视频看完了，1000题也做了些。之后的部分就不看视频了，直接做题吧。纸质书 + Anki每天刷。 有些焦虑。看到其他人408都开始刷真题了，数学也在二刷。随着剩下的时间一天天缩短，我产生「如果没考上怎么办」的想法的频率也高了起来。这种时候也只能强行让自己不去想了。毕竟路是自己选的，总该好好走完。高考没能达成的目标，过了四年还没法达成的话，也太没用了吧。 对了，我果然做不到一天只睡四个半小时。 1/1 更新： 本来还以为能多记一点的，结果开学后根本没时间。 考研就这样悄无声息地结束了。 虽然自觉考得很差，但是已经结束了，那就随它去吧。不想再想了，这种经历不想再有第二次了。 出成绩了再来更新。 2/23 更新： 败了，彻彻底底地败了。 考得比想象中还差。 但是因为已经做好心理准备了，所以看到成绩的那一刻也没什么波动。 这也说明我很清楚地知道自己没有尽力吧。 基础从一开始就没打好，心情浮躁，眼高手低，懒得动手，懒得思考。 以至于数学卷子发下来之后，大脑一片空白。下午的专业课，自以为已经掌握得很好了，但做过三四次的题依然不会。 一开始下定决心考研，除了想读书以外，还希望借此机会改掉自己无法专注、喜欢逃避现实的毛病。 但是很可惜，并没有改掉。我依然是自己厌恶的那个自己。 啊，这种话我已经说过多少次了呢？每一次都痛定思痛，每一次都死不悔改。 现在想来，也许这毛病是从小就有的吧。但是小学和初中还算学有余力，所以没有暴露出来。高中开始就比较明显了。上大学之后越来越明显，也许我已经丧失了专注学习的能力。 但我还是想再上几年学。 所以再来一年吧。","link":"/2021/08/01/kaoyan/"},{"title":"网易云音乐上传歌词&amp;翻译","text":"初めから チグハグだったけど 前言前几天听推荐的时候听到了しおんあい的「私の街」这首歌。 嗯，感觉旋律不错。想看看歌词，点开一看，居然没有翻译！ 那就自己来吧。毕竟现在没歌词/翻译的歌还挺少见的，难得有机会，那我当然是跃跃欲试。 作为一个翻译过几万字（虽然也不是什么严肃内容）的翻译爱好者，一篇歌词而已，那不是信手拈来？ 抱着这种心态，飞快地翻译完并提交了。 然后就没过审核。 可恶啊 就这样，我的歌词翻译之路走到了尽头。 本文完。（ 过了两天，我发现しおんあい桑发新歌了。 这首也挺好听的 所以我又手痒了。 歌词部分获取歌词本文以「Tallest Liar」这首歌为例。 首先用Google搜索「Tallest Liar しおんあい」。 一般来说，如果这首歌出了一段时间，那都是能搜到现成的歌词的。 比如J-Lyric，歌ネット这些网站，一般都会有歌词。这里推荐J-Lyric，因为歌ネット不让复制。 但是这首歌比较新，当时才刚出两天。没有现成的歌词。 「那就自己动手！考验听力的时候到了！」 你以为我会这么说吗？怎么可能，我听中文歌都不一定能听懂歌词的。 于是求助万能的油管。 这首歌是有PV的，而PV里是有歌词的。 那就抄下来呗。 新建txt，一句一行，保存。 接下来就是让歌词滚动起来了。 打轴试了几个打轴工具，我比较推荐灯里的歌词滚动姬 它的一个优点是：加载音频时可以用外链，而不一定要上传本地文件。（没有网易云会员我也下载不下来啊） 使用方法就不详细介绍了，反正把刚刚的txt文件传上去，打就完事了。 打完轴之后的成品如下： 上传打开网易云网页端，然后点这个上传歌词。 翻译部分网易云官方推荐上传双语歌词，原文和翻译在同一行，中间用空格隔开。 可以。 但千万别。 我试了，结果就是这样。 哦，行吧。 那就先提交歌词呗。 这次审核还挺快的，第二天就过了。 然后上传翻译，审核更快了，几个小时就过了。 最终效果 总结就，看见自己的翻译还挺有成就感的。 哦，顺便说一下，网易云的审核人员大概是既不懂日文，也不懂中文吧。 这种垃圾翻译都给过","link":"/2021/06/10/netease-music/"},{"title":"Can we play a love song","text":"長い冬が終わる瞬間 笑顔で迎えたいから 我终于决定好好写博客了。 其实早就想自己搭个博客，来抒发自己无处安放的表达欲。而我也确实曾经用Hexo和GitHub搭过一个，但是由于惯例的三分钟热度，搭好之后就无限搁置了。 而这次的念头来自昨天，无意中看到了别人的博客。而我也确实从他的文章中感觉到，这是个有趣的人。 不同于音乐和影像，文字是有其独特魅力的。在自我表达方面，文字并不弱于任何一种媒介。而文字的门槛，也是最低的。不需要懂乐理，不需要懂光影和构图，只要接受过正常教育的人，多少能扯个几句话出来。 以前用过没加好友的小号的QQ空间写日志来着，其实还挺顺手，毕竟只是写字而已，也不需要什么花里胡哨的功能。后来用Notion，确实好看点，还支持Markdown，写起来也舒服。但是这两个都有个问题，那就是没法给别人看。而且身为程序员没个博客像话吗 其实也不太想给别人看。毕竟我们资深社恐，最擅长的就是把所有话都憋在心里。 但是我不想再社恐了。 前几天重看了一遍「四叠半神话大系」。上一次看还是高中吧，当时看只觉得森见牛逼，汤浅牛逼，这就是动画该有的表现方式！ 但是经过这一次二刷，我才更加体会到被困在四叠半大小的空间内的无所适从。 虽然人与人之间的A.T.Field坚不可摧，不同的人永远无法相互理解。但我还是想尝试一下，把真实的自己一点点、一点点地揭开。 所以心血来潮，昨天花了一晚上，买了域名，配置了Hexo。 这个博客以后应该会长期更新吧。目前的话，是有这么几个想法： 写写随笔 学习笔记 技术相关 那就先写到这了，希望这次不要再三分钟热度。 毕竟域名是花了钱的！","link":"/2021/06/09/Can-we-play-a-love-song/"},{"title":"23考研政治30天带背","text":"史纲会议篇：Day1 ~ Day4；史纲人物篇：Day5 ~ 史纲 会议篇今年热点会议： (1)中共二大 (2)八七会议 (3)古田会议 (4)中共七大 (5)十一届三中全会 (6)十二大 (7)南方谈话 Day1 中共一大：确定了党的____和____。 中共二大：第一次提出了____的民主革命纲领；采取了别的政党没有采取的革命方法，即____的方法；提出组织民主的____的主张。 中共三大：正式确定全体共产党员以个人名义加入国民党，同孙中山领导的国民党建立统一战线。 国民党一大：对三民主义作了新的解释，在民族主义中突出了____的内容；在民权主义中强调了民主权利应____；把民生主义概括为____和____两大原则，后来又提出了____的主张。大会确定了联俄、联共、扶助农工三大革命政策。国民党一大的成功召开，标志着____的正式形成。 答案 中共一大：确定了党的名称和纲领。 中共二大：第一次提出了反帝反封建的民主革命纲领；采取了别的政党没有采取的革命方法，即群众路线的方法；提出组织民主的联合战线的主张。 中共三大：正式确定全体共产党员以个人名义加入国民党，同孙中山领导的国民党建立统一战线。 国民党一大：对三民主义作了新的解释，在民族主义中突出了反帝的内容；在民权主义中强调了民主权利应为一般平民所共有；把民生主义概括为平均地权和节制资本两大原则，后来又提出了耕者有其田的主张。大会确定了联俄、联共、扶助农工三大革命政策。国民党一大的成功召开，标志着第一次国共合作的正式形成。 Day2 八七会议：(1)意义：____到____的转折 (2)内容：彻底清算了大革命后期的陈独秀右倾机会主义错误；提出了____和____的方针；毛泽东提出论断____；选出了以瞿秋白为首的中央临时政治局。 古田会议：确立了____、____的原则；古田会议的中心思想是用____进行军队和党的建设；明确规定了红军的性质，是____的武装集团。 遵义会议：集中解决了军事和组织问题；确立了以____为主要代表的马克思主义正确路线在党中央的领导地位；挽救了中国共产党、挽救了中国工农红军、挽救了中国革命；是党的历史上____的转折点，标志了中国共产党在政治上____。 瓦窑堡会议：提出了党的____新政策；阐明了建立____的可能性；批判了____主义错误；决定用____口号代替“工农共和国”。 洛川会议：制定了____十大纲领。强调要打倒日本帝国主义，关键在于使已经发动的抗战成为____；必须实行全国____、全国____的总动员；必须坚持统一战线当中____的领导权，在敌人后方放手发动独立自主的山地游击战争。 答案 八七会议：(1)意义：大革命失败到土地革命战争兴起的转折 (2)内容：彻底清算了大革命后期的陈独秀右倾机会主义错误；提出了土地革命和武装起义的方针；毛泽东提出论断”政权是由枪杆子中取得的“；选出了以瞿秋白为首的中央临时政治局。 古田会议：确立了思想建党、政治建军的原则；古田会议的中心思想是用无产阶级思想进行军队和党的建设；明确规定了红军的性质，是执行革命的政治任务的武装集团。 遵义会议：集中解决了军事和组织问题；确立了以毛泽东为主要代表的马克思主义正确路线在党中央的领导地位；挽救了中国共产党、挽救了中国工农红军、挽救了中国革命；是党的历史上生死攸关的转折点，标志了中国共产党在政治上走向成熟。 瓦窑堡会议：提出了党的抗日民族统一战线新政策；阐明了建立抗日民族统一战线的可能性；批判了“左”倾关门主义错误；决定用人民共和国口号代替“工农共和国”。 洛川会议：制定了抗日救国十大纲领。强调要打到日本帝国主义，关键在于使已经发动的抗战成为全面的全民族的抗战；必须实行全国军事、全国人民的总动员；必须坚持统一战线当中无产阶级的领导权，在敌人后方放手发动独立自主的山地游击战争。 Day3 六届六中全会：第一次明确提出了____这个命题；决定中国之命运。 六届七中全会：通过了____，清算了党内历次机会主义路线，肯定了以毛泽东为代表的马克思列宁主义路线，肯定了以刘少奇为代表的党在白区工作的正确路线。标志着____的胜利结束，为党的七大的胜利召开在____上作了充分准备。 中共七大：毛泽东作了题为____的书面报告和____闭幕词；七大确定了党的____，建立一个____的中国；总结了党的三大作风，即____、____、____；修改党章，对毛泽东思想作了较为全面、系统和科学的概况，并将____确立为____，并写入党章。 杨家岭的其他事件：召开七大；开展了延安整风，使全党达到____和统一；展开了大生产运动；召开延安文艺座谈会；领导抗日民族统一战线，赢得了全面抗战伟大胜利 七届二中全会：召开于中国革命即将取得全国胜利的前夕，地点在____；说明了党的工作重心必须____；两个转变，指出了中国由____转变为____，由____转变为____的总任务和主要途径。此次会议上，毛泽东提出了____的思想。 答案 六届六中全会：第一次明确提出了马克思主义中国化这个命题；决定中国之命运。 六届七中全会：通过了《关于若干历史问题的决议》，清算了党内历次机会主义路线，肯定了以毛泽东为代表的马克思列宁主义路线，肯定了以刘少奇为代表的党在白区工作的正确路线。标志着延安整风的胜利结束，为党的七大的胜利召开在思想上作了充分准备。 中共七大：毛泽东作了题为《论联合政府》的书面报告和《愚公移山》闭幕词；七大确定了党的政治路线，建立一个新民主主义的中国；总结了党的三大作风，即理论和实践相结合、和人民群众紧密地联系在一起、自我批评的作风；修改党章，对毛泽东思想作了较为全面、系统和科学的概况，并将毛泽东思想确立为党的指导思想，并写入党章。 杨家岭的其他事件：召开七大；开展了延安整风，使全党达到空前团结和统一；展开了大生产运动；召开延安文艺座谈会；领导抗日民族统一战线，赢得了全面抗战伟大胜利 七届二中全会：召开于中国革命即将取得全国胜利的前夕，地点在西柏坡；说明了党的工作重心必须从农村转移到城市；两个转变，指出了中国由农业国转变为工业国，由新民主主义社会转变为社会主义社会的总任务和主要途径。此次会议上，毛泽东提出了“两个务必”的思想。 Day4 十一届三中全会：中国进入了____和____的历史新时期；形成了以____的党的中央领导团体；冲破长期“左”的错误的严重束缚，彻底否定了“两个凡是”；把工作重点转移到 ________ 上来和实行 ________ 的战略决策，重新确立了马克思主义的____路线、____路线、____路线。 十二大：第一次提出____命题，标志着党成功地实现了具有重大历史性意义的伟大转变，开始把中国带入建设有中国特色的社会主义政治轨道，标志着全面开创社会主义现代化建设新局面。 南方谈话：(1)意义：邓小平理论的____之作，逐渐走向____；(2)内容：社会主义的本质是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕；发展才是硬道理；“三个有利于”（大概率全选） 十四大：明确以____为我国经济体制改革的目标。 七届三中全会：明确了中心任务是要在____的时间内，争取国家财政经济状况的基本好转。 八大：在经济上提出了____，即 ____的方针，以及 ____的思想；在政治建设上提出要扩大 ________、健全社会主义法制，“有法可依”、“有法必依”；在执政党建设中强调要提高全党的马克思列宁主义思想水平，健全党内民主集中制。 十一届六中全会：通过了____，科学评价了毛泽东和毛泽东思想的历史地位。 十二届三中全会：指出我国社会主义经济是在公有制基础上的有计划的商品经济。 十三大：第一次比较系统阐述了社会主义初级阶段的____；制定了____的发展战略；标志着____的形成。 十五大：确立党在社会主义初级阶段的____。 答案 十一届三中全会：中国进入了改革开放和社会主义现代化建设的历史新时期；形成了以邓小平为核心的党的中央领导团体；冲破长期“左”的错误的严重束缚，彻底否定了“两个凡是”；把工作重点转移到 社会主义现代化建设上来和实行 改革开放 的战略决策，重新确立了马克思主义的思想路线、政治路线、组织路线。 十二大：第一次提出“建设有中国特色的社会主义”命题，标志着党成功地实现了具有重大历史性意义的伟大转变，开始把中国带入建设有中国特色的社会主义政治轨道，标志着全面开创社会主义现代化建设新局面。 南方谈话：(1)意义：邓小平理论的集大成之作，逐渐走向成熟；(2)内容：社会主义的本质是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕；发展才是硬道理；“三个有利于”（大概率全选） 十四大：明确以建立社会主义市场经济体制为我国经济体制改革的目标。 七届三中全会：明确了中心任务是要在三年左右的时间内，争取国家财政经济状况的基本好转。 八大：在经济上提出了既反保守又反冒进，即 在综合平衡中稳步前进的方针，以及 “三个主体，三个补充”的思想；在政治建设上提出要扩大 社会主义民主、健全社会主义法制，“有法可依”、“有法必依”；在执政党建设中强调要提高全党的马克思列宁主义思想水平，健全党内民主集中制。 十一届六中全会：通过了《关于建国以来党的若干历史问题的决议》，科学评价了毛泽东和毛泽东思想的历史地位。 十二届三中全会：指出我国社会主义经济是在公有制基础上的有计划的商品经济。 十三大：第一次比较系统阐述了社会主义初级阶段的理论；制定了“三步走”的发展战略；标志着邓小平理论轮廓的形成。 十五大：确立党在社会主义初级阶段的基本纲领。 史纲 人物、著作篇Day 5 林则徐：编成____一书。近代中国____第一人。 魏源：在____中，提出了____的思想，开创了中国近代____的新风。 郑观应：在《盛世危言》中，在经济上提出了大力发展____，同西方国家进行____；在政治上提出了____，实行____等主张。 冯桂芬：最先对____的指导思想作出比较完整的表述，概括为____。 严复：翻译了____，对中国人无疑是振聋发聩的警世钟。（和陈天华的《警世钟》《猛回头》区别） 孙中山：建立了第一个资产阶级革命团体____；建立了第一个资产阶级革命的全国性政党____，确定了____；领导了____，结束了封建君主专制制度；领导了____和____。 答案 林则徐：编成《四洲志》一书。近代中国睁眼看世界第一人。 魏源：在《海国图志》中，提出了“师夷长技以制夷”的思想，开创了中国近代向西方学习的新风。 郑观应：在《盛世危言》中，在经济上提出了大力发展民族工商业，同西方国家进行“商战”；在政治上提出了设立议院，实行”君民共主“等主张。 冯桂芬：最先对洋务事业的指导思想作出比较完整的表述，概括为”中学为体，西学为用“。 严复：翻译了《天演论》，对中国人无疑是振聋发聩的警世钟。（和陈天华的《警世钟》《猛回头》区别） 孙中山：建立了第一个资产阶级革命团体兴中会；建立了第一个资产阶级革命的全国性政党中国同盟会，确定了三民主义的革命纲领；领导了辛亥革命，结束了封建君主专制制度；领导了”二次革命“和”护法运动“。 Day 6 陈独秀：新文化运动；中共创始人之一；大革命后期犯了右倾机会主义错误。 李大钊：中国的第一个马克思主义者；发表《我的马克思主义观》，对马克思主义作了比较系统的介绍；发表《庶民的胜利》，歌颂了十月革命和布尔什维主义的胜利；发表《法俄革命之比较观》，第一次正确阐述十月革命的性质。 Day 7毛泽东 第一次国内革命战争 &amp; 土地革命战争时期 革命的首要问题是____。 国民革命的中心问题是____。 毛泽东思想开始形成于____时期，同时，____理论的提出也标志着毛泽东思想开始形成。 《中国的红色政权为什么能够存在？》和《井冈山的斗争》提出了____的思想。 《反对本本主义》提出了____和____的重要思想；反映了毛泽东思想的三个基本点，即____、____、____的思想雏形；标志了毛泽东思想的初步形成。 《论反对日本帝国主义的战略》，系统性地解决了党的____上的问题。（瓦窑堡会议上提出） 总结土地革命战争中党内在军事问题上的大争论的著作是____。 答案 革命的首要问题是分清敌友。 国民革命的中心问题是农民问题。 毛泽东思想开始形成于土地革命战争时期，同时，“农村包围城市，武装夺取政权”理论的提出也标志着毛泽东思想开始形成。 《中国的红色政权为什么能够存在？》和《井冈山的斗争》提出了工农武装割据的思想。 《反对本本主义》提出了“没有调查，没有发言权”和“中国革命斗争的胜利要靠中国同志了解中国情况”的重要思想；反映了毛泽东思想的三个基本点，即实事求是、群众路线、独立自主的思想雏形；标志了毛泽东思想的初步形成。 《论反对日本帝国主义的战略》，系统性地解决了党的政治路线上的问题。（瓦窑堡会议上提出） 总结土地革命战争中党内在军事问题上的大争论的著作是《中国革命战争的战略问题》。 Day 8全民族抗战时期 科学地阐明了党的马克思主义思想路线、对党的思想路线做了系统的哲学论证的著作是____。 《论持久战》科学地预测了抗日战争的发展进程，即____、____、____三个阶段，其中____是抗日战争取得最后胜利的最关键的阶段；驳斥了”速胜论“和”亡国论“，提出了____的论断。 《共产党人发刊词》指出中国共产党战胜敌人的三个法宝是____、____、____。 第一次旗帜鲜明地提出了新民主主义的完整理论，阐述了新民主主义的政治、经济、文化的著作是____。 整风运动首先在党的高级干部中进行的相关著作是____。 整风运动在全党范围内普遍展开的相关著作是____、____。 进一步把新民主主义的政治、经济、文化与党的基本纲领联系起来的著作是____。 答案 科学地阐明了党的马克思主义思想路线、对党的思想路线做了系统的哲学论证的著作是《实践论》、《矛盾论》。 《论持久战》科学地预测了抗日战争的发展进程，即战略防御、战略相持、战略反攻三个阶段，其中战略相持是抗日战争取得最后胜利的最关键的阶段；驳斥了”速胜论“和”亡国论“，提出了”兵民是胜利之本“的论断。 《共产党人发刊词》指出中国共产党战胜敌人的三个法宝是群众路线、武装斗争、党的建设。 第一次旗帜鲜明地提出了新民主主义的完整理论，阐述了新民主主义的政治、经济、文化的著作是《新民主主义论》。 整风运动首先在党的高级干部中进行的相关著作是《改造我们的学习》。 整风运动在全党范围内普遍展开的相关著作是《整顿党的作风》、《反对党八股》。 进一步把新民主主义的政治、经济、文化与党的基本纲领联系起来的著作是《论联合政府》。 Day 9解放战争时期与新中国成立后 《关于正确处理人民内部矛盾的问题》中，明确提出____。 《关于正确处理人民内部矛盾的问题》中提出，敌我矛盾是____的矛盾，要用____的方式来解决；人民内部矛盾是____的矛盾，要用____的方式来解决。 社会主义国家政治生活的主题是____，这一论断的根本着眼点在于____，____，把全党的注意力转到社会主义建设上来。 《论十大关系》明确提出____，独立自主地____适合中国情况的社会主义建设道路。 《论十大关系》围绕一个基本方针，即____。 《论十大关系》标志了中国共产党人开始____。 《论十大关系》论述的第一大关系是____。 《论人民民主专政》为新中国的建立奠定了____基础和____基础；人民民主专政的基础是____的联盟，而主要是____。 邓小平 《解放思想，实事求是，团结一致向前看》成为开辟中国特色社会主义道路、开创中国特色社会主义理论的宣言书。 答案 《关于正确处理人民内部矛盾的问题》中，明确提出要走一条有别于苏联的中国工业化道路。 《关于正确处理人民内部矛盾的问题》中提出，敌我矛盾是对抗性的矛盾，要用专政的方式来解决；人民内部矛盾是非对抗性的矛盾，要用民主的方式来解决。 社会主义国家政治生活的主题是关于正确处理人民内部矛盾的问题，这一论断的根本着眼点在于调动一切积极因素，团结一切可以团结的力量，把全党的注意力转到社会主义建设上来。 《论十大关系》明确提出以苏为鉴，独立自主地探索适合中国情况的社会主义建设道路。 《论十大关系》围绕一个基本方针，即调动一切积极因素为社会主义服务。 《论十大关系》标志了中国共产党人开始探索中国自己的社会主义建设道路。 《论十大关系》论述的第一大关系是重工业、轻工业、农业的关系。 《论人民民主专政》为新中国的建立奠定了理论基础和政策基础；人民民主专政的基础是工人阶级、农民阶级和城市小资产阶级的联盟，而主要是工人和农民的联盟。 邓小平 《解放思想，实事求是，团结一致向前看》成为开辟中国特色社会主义道路、开创中国特色社会主义理论的宣言书。 史纲 土地政策 重要的土地政策： Day 10党成立之前的土地政策（都没有触及封建地主土地所有制） 最能体现太平天国社会理想和这次农民起义特色的纲领性文件是____。它确定了____的方案，从根本上否定了____。但是并没有超出____的狭隘眼界，具有不切实际的____的性质，也并未付出实践。 三民主义之民生主义的内容是____，并非将土地所有权分给农民，没有正面触及封建土地制度。 新三民主义之民生主义的内容是____和____，后来又提出了____的主张。 答案 最能体现太平天国社会理想和这次农民起义特色的纲领性文件是《天朝田亩制度》。它确定了平均分配土地的方案，从根本上否定了封建地主土地所有制。但是并没有超出农民小生产者的狭隘眼界，具有不切实际的空想性质，也并未付出实践。 三民主义之民生主义的内容是”平均地权“，并非将土地所有权分给农民，没有正面触及封建土地制度。 新三民主义之民生主义的内容是“平均地权”和”节制资本“，后来又提出了”耕者有其田“的主张。","link":"/2022/11/08/zz-Kaoyan/"}],"tags":[{"name":"日语","slug":"日语","link":"/tags/%E6%97%A5%E8%AF%AD/"},{"name":"想法","slug":"想法","link":"/tags/%E6%83%B3%E6%B3%95/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"考研","slug":"考研","link":"/tags/%E8%80%83%E7%A0%94/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"三岛由纪夫","slug":"三岛由纪夫","link":"/tags/%E4%B8%89%E5%B2%9B%E7%94%B1%E7%BA%AA%E5%A4%AB/"},{"name":"读后感","slug":"读后感","link":"/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"name":"音乐","slug":"音乐","link":"/tags/%E9%9F%B3%E4%B9%90/"}],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"读书","slug":"读书","link":"/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"分享","slug":"分享","link":"/categories/%E5%88%86%E4%BA%AB/"}]}