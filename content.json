{"pages":[{"title":"关于我","text":"懒得写，以后再说","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"2015年の荒川へ","text":"課程デザインと期末テストが終わり、日付は7月に変わった。 私にとって、7月は一年中最も悲しい時期である。 火であり、斜陽であり、別れでもある。 あれから一年が過ぎ、そろそろ何か書こうと思って、あなたの誕生日の今日で、私はこの文章を書くと決めた。 東京生活記録あれは2015年の夏。 ビリビリのホームページで「東京生活記録」というタイトルの動画が見つかった。あの動画のサムネイルは一つの変な人形だった。私は好奇心であの動画を再生した。 それが私とあなたの出合い。 一人の十五歳で二次元にハマっていた少年にとっては、「東京」という言葉の魅力が言うもなく大きい。 最初は東京に誘われ、西日暮里、荒川、スカイツリーなど見知らぬところに私は興味が持ち、毎回も動画を見る。 しかし、見れば見るほど、私は「本当に面白い人だなぁ」と思い始めた。 道に歩いながら、なんだかんだ喋るところが好きだった。 今も思い出せる、あなたが行った場所。 荒川沿い、自転車に乗っていた人々。 秋葉原、歩行者天国、ビッグマック。 東京大学、部活室。 スカイツリー、東京タワー。 そして、西日暮里、屋上。 あなたはギブリが好きで、私もあれからギブリが好きになった。 あなたは三島由紀夫が好きで、動画まで撮って紹介した。私もあれから三島を読み始めた。 私はあなたの振る舞いや、言葉や最高にかっこいいと思い、とても好きだった。 考えたら、今の私には、大体半分くらいはあなたに影響された。 人生の先生と言っても過言ではないね。 東京から南京へ「いつか皆さんは私の動画を見ないことが私にとって嬉しいです。」とあなたが言った。 高校生になってから、学業に勉強していた一方で、生活はなんとなく充実になったかもしれない、私はあなたの動画を見なくなった。 時間がどんどん進んでいく。 運命とか、縁起とか、私は信じない。 しかし、私は南京の大学に受けた。あなたの、故郷の大学。 こうして、私はあなたと繋がってる感じがした。 あなたが遊んだあの公園、あの階段、あのピンポンボール、いつか行ってみたいだね。 三島由紀夫と羊をめぐる冒険去年の春、あなたは一つの動画をアップした。 あの動画で、大好きな三島由紀夫を紹介し、三島さんの本の読む順番も推薦した。 その後、あなたはウェイボーで「江蘇のどこかで羊が見えるの？」と。 数日後、あなたは羊の群れの写真をアップした。 「いいなぁ、あなたは相変わらずかっこいい。」私はこう思った。 そして、7月5日。 2020年7月4日凌晨，叶修于南京结束了自己的生命 あなたの最後の一言。 その後、私は村上春樹の「羊をめぐる冒険」を読んだ。 その本の中で、「活到25岁，然后死掉」という言葉がある。 それが、あなたの思い込みなのか。 Guaranteed Don’t come closer or I’ll have to go あなたはきっと、色々考えたから、死に選ぶことが決まったのが私は信じている。 だから、私はその点を否定しない。それだけでなく、私は「おめでとう」と、苦難から逃げられたことに祝う。 ね、ヨウさん、航海に行きたいってあなたが言っただろう？ あれから一年、どう、あの広くて青い海の景色は？ 「行かないで」とか、「どうしてそんな事を」とか、私は言わない。 ただ時々、あなたのことが私は思い出し、悲しくなる。 後悔はもちろんしちゃうよ、そんなに近かったのに、あったこと一回もない。機会があったのに… ありがとう、たくさんの風景を私に見させて。 ありがとう、今の私を作り上げて。 ありがとう、叶修。","link":"/2021/07/05/2015-arakawa/"},{"title":"KMP Algotirhm","text":"IntroductionPresume we have a string S (length is m) and a pattern P (length is n) given as follow: 123index: 1 2 3 4 5 6 7 8 9 10 11 12S: a b a b a a b a a b a cP: a b a a b a c Now we want to find out is there a sub-string in S that matchs P exactly, which in this case is S[6:12]. That is what KMP algorithm does. Proper Prefix &amp; Proper SuffixBefore learning KMP, let’s make this clear first: what is proper prefix and proper suffix? Proper prefix: All the characters in a string, with one or more cut off the end. “S”, “Sn”, “Sna”, and “Snap” are all the proper prefixes of “Snape”. Proper suffix: All the characters in a string, with one or more cut off the beginning. “agrid”, “grid”, “rid”, “id”, and “d” are all proper suffixes of “Hagrid”. Partial Match TableThe key to KMP, it’s the Partial Match Table. Let’s see a example. 123char: | a | b | a | a | b | a | c |index: | 1 | 2 | 3 | 4 | 5 | 6 | 7 |value: | 0 | 0 | 1 | 1 | 2 | 3 | 0 | I see, there’s a table. But what do these values mean? The length of the longest proper prefix in the (sub)pattern that matches a proper suffix in the same (sub)pattern. For example, at index 1, we have a sub-string “a”. Its proper prefix and proper suffix are both null, so it’s value is 0. At index 2, we have a sub-string “ab”, with proper prefix “a”, and proper suffix “b”, and they do not match each other, there’s another 0. At index 3, we have a sub-string “aba”, with proper prefix “a” and “ab”, and proper suffix “a”, “ba”. We can see that they both contains “a”, which we call “match”. And the length of “a” is 1, so its value is 1. At index 4, we have a sub-string “abab”, proper prefix “a”, “ab”, “aba”, and proper suffix “a”, “aa”, “baa”. They both cotains “a”, which legth is 1, so there’s 1s in its value. etc. How to use Next ArrayThe next array is baes on the pattern. What is cofusing is that on the internet, most blogs and videos, next array and PMT table are just the same thing, but in Wangdao’s text book, the PMT is different from next array. Well, I’ll just make them be the same. In bruce force searching, we search the S one letter by one letter, like this: 12345678910First run:S: a b a b a a b a a b a cP: a b a a &lt;- mismatchSecond run:S: a b a b a a b a a b a cP: a &lt;- mismatchThird run:S: a b a b a a b a a b a cP: a b a a b a c &lt;- mismatch... Obviously, it is very slow, and its time complexity is $O(mn)$. Check this: 123456789First run:S: a b a |b| a a b a a b a cP: a b a |a| &lt;- mismatchSecond run:S: a b a b a a b a |a| b a cP: a b a a b a |c| &lt;- mismatchThird run:S: a b a b a a b a a b a cP: a b a a b a c &lt;- match! We can see that after mismatch, P is not going forward one letter by one letter., but jumps forward. And through the next array we can know where should P jump to. In the first run, P[4] and S[4] mismatch, and next[4 - 1] is 1 which means in the substring from P[0:4], the prefix and subfix of 1 letter are the same, so we move P and make it match the S with its proper prefix instead the subfix that mismatched. In the second run, P[7] and S[9] mismatch, and next[7 - 1] is 3, which means the first and the last 3 letters in the substring from P[0:7] are the same, in this case is “aba”. So we move P forward till the first 3 letters take place of the last 3 letters. etc. Construct a Next Array123456789101112void get_next(String P, int next[]) { int i = 1, j = 0; next[0] = 0; while(i &lt; P.length) { if(j==0 || P[i] == P[j]) { i++; j++; next[i] = j; } else { j = next[j - 1]; } }} PracticeAcwing: 831.KMP字符串 ReferencesYoutube: Abdul Bari - Knuth-Morris-Pratt KMP String Matching Algorithm Zhihu: 阮行止 - 如何更好地理解和掌握 KMP 算法? Blog: The Knuth-Morris-Pratt Algorithm in my own words","link":"/2021/07/08/KMP-Algotirhm/"},{"title":"从零开始的LeetCode题解","text":"始まりと終わりのプロローグ -Turning Point- 数组二分704. 二分查找35. 搜索插入位置 在数组中搜索元素的题通常都可以用二分。但要注意前提是该数组有序。 关于二分的边界条件：在二分的过程中，要保证每次分的区间都满足一开始的定义。而区间的定义一般有两种：左闭右闭 和 左闭右开。以左闭右闭为例： while(left &lt;= right) 必须是 &lt;= ，因为 left 和 right 是有可能相等的。 同理left 更新时是 mid + 1 ， right 更新时是 mid - 1 。 704. 二分查找1234567891011121314151617class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int n = nums.size(); int l = 0, r = n - 1; int mid = 0; while (l &lt;= r) { mid = (l + r) / 2; if (nums[mid] &gt; target) { r = mid - 1; } else if (nums[mid] &lt; target) { l = mid + 1; } else return mid; } return -1; }}; 双指针27. 移除元素977. 有序数组的平方 这类题往往用暴力需要两层 for 循环。如果在第一层循环时能够记录一些信息提供给第二层循环，则可以考虑使用双指针。 27. 移除元素12345678910111213class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int l = 0; int n = nums.size(); for (int r = 0; r &lt; n; r ++) { if (val != nums[r]) { nums[l++] = nums[r]; } } return r; }}; 但双指针不一定要是都向同一个方向运动，也可以是从数组两端向中间走。 977. 有序数组的平方12345678910111213141516171819202122class Solution {public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int k = n - 1; vector&lt;int&gt; ans(n, 0); int l = 0, r = n - 1; while (l != r) { int a = nums[l] * nums[l]; int b = nums[r] * nums[r]; if (a &gt;= b) { ans[k --] = a; l ++; } else { ans[k --] = b; r --; } } ans[0] = nums[l] * nums[l]; return ans; }}; 滑动窗口209. 长度最小的子数组 本质也是双指针。适用于求解数组中的子数组的情况。 209. 长度最小的子数组12345678910111213141516171819class Solution {public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int n = nums.size(); int l = 0, r = 0; int sum = 0, res = 0; int len = INT_MAX; // 窗口的长度 for (r = 0; r &lt; n; r ++) { sum += nums[r]; while (sum &gt;= target) { len = min(len, r - l + 1); sum -= nums[l ++]; } } if (len == INT_MAX) return 0; return len; }}; 链表链表定义1234567struct ListNode { int val; ListNode* next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {}}; 删除元素203. 移除链表元素 对链表进行删除时一定要注意判断链表是否为空，以及对头结点的特殊操作。另外这题用到了虚拟头结点，这样就不用针对头结点特判，也是一个实用的技巧。 203. 移除链表元素12345678910111213141516171819class Solution {public: ListNode* removeElements(ListNode* head, int val) { ListNode* dummyHead = new ListNode(0, head); // 新建一个虚拟头结点，next指向head ListNode* cur = dummyHead; while (cur-&gt;next != nullptr) { ListNode* tmp = cur-&gt;next; if (tmp-&gt;val == val) { cur-&gt;next = tmp-&gt;next; delete tmp; } else { cur = cur-&gt;next; } } head = dummyHead-&gt;next; delete dummyHead; return head; }}; 反转链表206. 反转链表 原本想的是定义一个新链表，然后把旧链表元素依次插到新表头。但是显然复杂度比较高。好的办法依然是双指针。从头开始直接改变 next 指针的朝向。 206. 反转链表123456789101112131415class Solution {public: ListNode* reverseList(ListNode* head) { ListNode* pre = nullptr; ListNode* cur = head; ListNode* tmp; while (cur) { tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; // pre 前进 cur = tmp; // cur 前进 } return pre; }}; 交换结点24. 两两交换链表中的节点 用到了前面提到的虚拟头结点。没啥难的，主要是要自己画图模拟一下。 24. 两两交换链表中的节点12345678910111213141516171819class Solution {public: ListNode* swapPairs(ListNode* head) { ListNode* dummyHead = new ListNode(0, head); ListNode* cur = dummyHead; while (cur-&gt;next != nullptr &amp;&amp; cur-&gt;next-&gt;next != nullptr) { ListNode* t = cur-&gt;next; ListNode* t1 = cur-&gt;next-&gt;next-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; cur-&gt;next-&gt;next = t; cur-&gt;next-&gt;next-&gt;next = t1; cur = cur-&gt;next-&gt;next; } // 注意不要直接返回head，因为被cur修改过了，head不再指向表头了 return dummyHead-&gt;next; }}; 链表中的双指针19.删除链表的倒数第 N 个结点 双指针的经典应用。fast 先移动 n 个位置，再让 slow 指针一起移动。虚拟头结点依然很方便，不用特别处理头结点。 19. 删除链表的倒数第 N 个结点123456789101112131415161718192021222324class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummyHead = new ListNode(0, head); ListNode* fast = dummyHead; ListNode* slow = dummyHead; while (n-- &amp;&amp; fast-&gt;next != nullptr) { fast = fast-&gt;next; } while (fast-&gt;next != nullptr) { fast = fast-&gt;next; slow = slow-&gt;next; } if (n == 1) { delete fast; return head; } ListNode* tmp = slow-&gt;next; slow-&gt;next = tmp-&gt;next; delete tmp; return dummyHead-&gt;next; }} 142. 环形链表 II 两种解法：1、数学题。详解看这里2、哈希表。遍历每个结点，并加入哈希表。遇到的第一个遍历过的结点就是环的入口。 142. 环形链表 II解法一 123456789101112131415161718192021class Solution {public: ListNode *detectCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while (fast != NULL &amp;&amp; fast-&gt;next != NULL) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (slow == fast) { ListNode* p = head; ListNode* t = fast; while (p != t) { p = p-&gt;next; t = t-&gt;next; } return p; } } return NULL; }}; 解法二 123456789101112class Solution {public: ListNode *detectCycle(ListNode *head) { unordered_set&lt;ListNode*&gt; visited; while(head != NULL) { if (visited.count(head)) return head; visited.insert(head); head = head-&gt;next; } return NULL; }}; 设计链表707. 设计链表 模拟，注意 index 从 0 开始。 class MyLinkedList { public: struct ListNode { int val; ListNode* next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} }; MyLinkedList() { dummyHead = new ListNode(0); size = 0; } int get(int index) { if (index &lt; 0 || index &gt; size - 1) return -1; ListNode* cur = dummyHead-&gt;next; while (index --) cur = cur-&gt;next; return cur-&gt;val; } void addAtHead(int val) { ListNode* node = new ListNode(val, dummyHead-&gt;next); dummyHead-&gt;next = node; size ++; } void addAtTail(int val) { ListNode* cur = dummyHead; while (cur-&gt;next != nullptr) { cur = cur-&gt;next; } ListNode* node = new ListNode(val); cur-&gt;next = node; size ++; } void addAtIndex(int index, int val) { if (index &gt; size) return; ListNode* cur = dummyHead; ListNode* node = new ListNode(val); while (index --) cur = cur-&gt;next; node-&gt;next = cur-&gt;next; cur-&gt;next = node; size ++; } void deleteAtIndex(int index) { if (index &lt; 0 || index &gt; size - 1) return; ListNode* cur = dummyHead; while (index --) cur = cur-&gt;next; ListNode* tmp = cur-&gt;next; cur-&gt;next = tmp-&gt;next; delete tmp; size --; } private: int size; ListNode* dummyHead; };","link":"/2022/04/05/LeetCode/"},{"title":"考研数据结构算法题笔记","text":"一寸先が闇なら、二寸先は明るい未来 线性表反向输出链表递归 1234function print_values_in_reverse(ListNode head) if head is NOT null print_values_in_reverse(head.next) print head.val 对链表进行插入排序123456789101112131415161718192021222324252627class Solution {public: ListNode* insertionSortList(ListNode* head) { if (head == nullptr) return nullptr; ListNode *dummyHead = new ListNode(0, head); ListNode *lastSorted, *cur; lastSorted = head; cur = head-&gt;next; while (lastSorted-&gt;next != nullptr) { if (cur-&gt;val &gt;= lastSorted-&gt;val) { lastSorted = lastSorted-&gt;next; } else { ListNode *pre = dummyHead; while (cur-&gt;val &gt;= pre-&gt;next-&gt;val) { pre = pre-&gt;next; } lastSorted-&gt;next = cur-&gt;next; cur-&gt;next = pre-&gt;next; pre-&gt;next = cur; } cur = lastSorted-&gt;next; } return dummyHead-&gt;next; }}; 单链表逆转双指针 不是交换结点中的元素，而是把指针逆转。定义两个指针pre和cur，每次操作先让cur的next指向前驱节点，再令pre前进到cur的位置，然后cur再前进一位，最后pre会前进到尾结点，这时指针就全部逆转了。 12345678910111213List Reverse (List L){ PtrToNode temp; // 保存cur的下一个节点 PtrToNode cur = L; PtrToNode pre = NULL; while (cur) { temp = cur -&gt; Next; cur -&gt; Next = pre; pre = cur; cur = temp; } return pre;} 链式表的按序号查找没啥好说的。 创建的指针cur一定要记得初始化cur = L，不然不知道指向哪。 123456789ElementType FindKth (List L, int K) { List cur = L; int i; for (i = 1; cur != NULL &amp;&amp; i &lt; K; i ++) { cur = cur -&gt; Next; } if (cur == NULL || i &gt; K) return ERROR; else return cur -&gt; Data;} 两数相加模拟 遍历两个链表，每次值相加后赋值给新链表的尾结点，记录下进位值留给下次运算。 注意两个链表长度不一定相等，以及如果最高位产生了进位，需要再新建一个结点用来存。 1234567891011121314151617181920212223class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *head = nullptr, *tail = nullptr; int carry = 0; while(l1 || l2) { int x = l1 ? l1-&gt;val : 0; int y = l2 ? l2-&gt;val : 0; int sum = x + y + carry; if (!head) { head = tail = new ListNode(sum % 10); } else { tail-&gt;next = new ListNode(sum % 10); tail = tail-&gt;next; } carry = sum / 10; if (l1) l1 = l1-&gt;next; if (l2) l2 = l2-&gt;next; } if (carry) tail-&gt;next = new ListNode(1); return head; }}; 350. 两个数组的交集 II排序 + 双指针 12345678910111213141516171819class Solution {public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); int n1 = nums1.size(), n2 = nums2.size(); int i = 0, j = 0; vector&lt;int&gt; res; while (i &lt; n1 &amp;&amp; j &lt; n2) { if (nums1[i] &lt; nums2[j]) i ++; else if (nums2[j] &lt; nums1[i]) j ++; if (i &lt; n1 &amp;&amp; j &lt; n2 &amp;&amp; nums1[i] == nums2[j]) { res.push_back(nums1[i]); i ++, j ++; } } return res; }}; 严书2.11设线性表va中的数据元素递增有序。试写一算法，将x插入到顺序表的适当位置上，保持该表的有序性。 123456789101112131415161718#define MaxSize 50typedef struct { ElemType data[MaxSize]; int length;} SqList;void func(SqList &amp;va, int x) { if (va.length == va.listsize) int i = 0; while (va[i] &gt; x) { i ++; } for (int j = va.size(); j &gt;= i; j --) { va[j + 1] = va[j] } va[i] = x; return;} 严书2.14在带头结点的单链表结构上实现线性表操作Length(L) 123456789int Length(List &amp;L) { int len = 0; ListNode cur = L; while (cur != NULL) { len ++; cur = cur-&gt;next; } return len;} 严书2.15已知指针ha和hb分别指向两个单链表的头结点，并且已知两个链表的长度分别为m和n。试写一算法将这两个链表连接在一起，假设指针hc指向连接后的链表的头结点，并要求算法以尽可能短的实践完成链接运算。 12345678910111213141516171819void func(List &amp;ha, List &amp;hb) { ListNode hc = new ListNode; ListNode p_short, p_long; ListNode h; if (m &lt; n) { p_short = ha; p_long = hb; h = ha; } else { p_short = hb; h = hb; p_long = ha; } while (p_short-&gt;next != NULL) { p_short = p_short-&gt;next; } p_short-&gt;next = p_long-&gt;next; hc-&gt;next = h;} 严书2.20已知单链表中元素以递增有序排列，写一算法删除表中所有值相同的多余元素，同时释放被删除的结点空间 1234567891011void func(LinkList L) { LinkList p1 = L, p2 = L-&gt;next; while (p2 != NULL) { if (p1-&gt;data == p2-&gt;data) { ListNode t = p2; p2 = p2-&gt;next; p1-&gt;next = p2; delete t; } }} 严书 2.22对单链表实现就地逆置 12345678910111213// 双指针void reverse(List L) { ListNode *temp; ListNode *cur = L; ListNode *pre = NULL; while (cur) { temp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = temp; } return;} 严书2.31假设某个单向循环链表的长度大于1，且表中既无头结点也无头指针。已知s为指向链表中某个结点的指针，试编写算法在链表中删除指针s所指结点的前驱结点 12345678910void delete_node(ListNode &amp;s) { ListNode *t = s; while (t-&gt;next-&gt;next != s) { t = t-&gt;next; } ListNode *p = t-&gt;next; t-&gt;next = p-&gt;next; delete p; return;} 二叉树翻转二叉树第一眼就想到了层序遍历。不过递归也可以，而且代码更短，考试的时候还是写递归吧。 也是一个启示，树的题目基本上都可以往递归上面想。 层序遍历 12345678910111213141516171819class Solution {public: TreeNode* invertTree(TreeNode* root) { queue&lt;TreeNode*&gt; q; if (root != nullptr) q.push(root); while (!q.empty()) { int size = q.size(); for (int i = 0; i &lt; size; i ++) { TreeNode* cur = q.front(); q.pop(); swap(cur -&gt; left, cur -&gt; right); // 交换左右子树 // 入队的顺序和层序遍历相反。这里是先右孩子入队，再左孩子入队。 if (cur -&gt; right != nullptr) q.push(cur -&gt; right); if (cur -&gt; left != nullptr) q.push(cur -&gt; left); } } return root; }}; 递归 在前序遍历的基础上，把访问中间结点的操作改为交换左右子树。因为前序遍历是中左右的顺序，所以在原本访问中间结点的时候交换左右孩子，就能实现翻转二叉树。形象理解就是从上至下的递归。 后序遍历是左右中的顺序，所以同理，这里把swap放到后面，变成后序遍历也可以。形象理解就是从下至上的递归。 但是中序不行。有些结点会被翻转两遍。 1234567891011class Solution {public: TreeNode* invertTree(TreeNode* root) { if (root == nullptr) return root; // 终止条件 swap(root -&gt; left, root -&gt; right); // 每次递归，交换左右子树 invertTree(root -&gt; left); invertTree(root -&gt; right); // swap语句放到这个位置也可以 return root; }}; 在每个树行中找最大值这种涉及到“行”的，当然很自然就想到层序遍历。直接默写板子。 123456789101112131415161718192021class Solution {public: vector&lt;int&gt; largestValues(TreeNode* root) { queue&lt;TreeNode*&gt; q; if (root != nullptr) q.push(root); vector&lt;int&gt; res; while (!q.empty()) { int size = q.size(); int maxVal = INT_MIN; for (int i = 0; i &lt; size; i ++) { TreeNode* cur = q.front(); maxVal = max(cur -&gt; val, maxVal); q.pop(); if (cur -&gt; left != nullptr) q.push(cur -&gt; left); if (cur -&gt; right != nullptr) q.push(cur -&gt; right); } res.push_back(maxVal); } return res; }}; 对称二叉树递归，递归，还是递归！ 判断一棵二叉树是否对称，我们先把这棵树从根结点分开，看作左右两颗树。将左树的左边结点、右树的右边结点称为“外”，左树的右边结点和右树的左边结点称为“内”。如果两边的内外结点互相相等，则两棵树对称。 123456789101112131415161718192021class Solution {public: bool isSymmetric(TreeNode *root) { if (root == nullptr) // 如果是空树，对称 return true; return compare(root-&gt;left, root-&gt;right); // 从根结点的两颗子树开始由上至下判断 } bool compare(TreeNode *p, TreeNode *q) { if (!p &amp;&amp; !q) // 如果两个结点都是空的，对称 return true; else if (!p || !q) // 如果两个结点只有一个是空的，不对称 return false; else if (p-&gt;val != q-&gt;val) // 如果两个结点都不空，比较它们的值，如果不等，则不对称 return false; bool inside = compare(p-&gt;right, q-&gt;left); // 比较内结点 bool outside = compare(p-&gt;left, q-&gt;right); // 比较外结点 return (inside &amp;&amp; outside); // 只有二者都为true时才对称 }} 二叉树的最大深度模板题 层序遍历（迭代） 12345678910111213141516171819class Solution {public: int maxDepth(TreeNode* root) { if (root == nullptr) return 0; int height = 0; queue&lt;TreeNode*&gt; q; q.push(root); while (!q.empty()) { int size = q.size(); for (int i = 0; i &lt; size; i ++) { if (q.front()-&gt;left != nullptr) q.push(q.front()-&gt;left); if (q.front()-&gt;right != nullptr) q.push(q.front()-&gt;right); q.pop(); } height ++; } return height; }} 先序遍历（递归） 首先确定这个递归函数是要干什么：求树的高度。所以返回值是int类型； 然后确定终止条件：root == null，空树，树高为0； 最后确定单层递归的逻辑：树的最大深度等于max(左子树深度，右子树深度) + 1。 123456789class Solution {public: int maxDepth(TreeNode* root) { if (root == nullptr) return 0; int lheight = maxDepth(root-&gt;left); int rheight = maxDepth(root-&gt;right); return (max(lheight, rheight) + 1); }}; 二叉树的最小深度和上一题类似，但是这一题要求的是“从根结点到最近叶子结点的最短路径”，所以如果一棵树的左/右结点为空，其最小深度不是1，而是“非空子树的最小深度+1”。如果沿用上一题的写法，那就会在这里出错。 以下给出递归解法。当然也可以层序遍历，这里就不写了。 1234567891011class Solution {public: int minDepth(TreeNode* root) { if (!root) return 0; int lheight = minDepth(root-&gt;left); int rheight = minDepth(root-&gt;right); if (!root-&gt;left &amp;&amp; root-&gt;right) return rheight + 1; if (root-&gt;left &amp;&amp; !root-&gt;right) return lheight + 1; return (min(lheight, rheight) + 1); }}; 平衡二叉树和求二叉树最大深度那题类似。 递归三部曲： 确定参数和返回值类型 传入根结点，如果这棵树是平衡二叉树，则返回树高度；如果不是，则返回-1；所以返回值类型为int 确定终止条件 如果为空树，返回0；如果左/右子树高度为-1（说明不是平衡二叉树），返回-1。 确定单层递归的目的 如果左右子树高度差大于1，返回-1，否则返回树高度。 123456789101112131415class Solution {public: int getHeight(TreeNode* root) { if (root == nullptr) return 0; int lheight = getHeight(root-&gt;left); if (lheight == -1) return -1; int rheight = getHeight(root-&gt;right); if (rheight == -1) return -1; if (abs(lheight - rheight) &gt; 1) return -1; else return(max(lheight, rheight) + 1); } bool isBalanced(TreeNode* root) { return (getHeight(root) &gt;= 0); }}; 652. 寻找重复的子树序列化 将每一棵子树都「序列化」成一个字符串，并且保证： 相同的子树会被序列化成相同的子串； 不同的子树会被序列化成不同的子串。 那么我们只要使用一个哈希表存储所有子树的序列化结果，如果某一个结果出现了超过一次，我们就发现了一类重复子树。 12345678910111213141516171819202122232425262728class Solution {private: unordered_map&lt;string, int&gt; umap; vector&lt;TreeNode*&gt; ans; public: string dfs(TreeNode* root) { if (!root) return &quot;&quot;; // 注意这一行两个dfs前的“ ”不能删掉 string str = to_string(root-&gt;val) + &quot; &quot; + dfs(root-&gt;left) + &quot; &quot; + dfs(root-&gt;right); umap[str] ++; if (umap[str] == 2) ans.push_back(root); return str; } vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) { dfs(root); return ans; }};/* 1 2 31 2 1考虑这样一棵树，当遍历到2时，如果没有&quot; &quot;用来分隔根和左右孩子的值的话，左右两个以2为根的子树都会被序列化为&quot;21&quot;，但是这两棵树不是相同的。而有&quot; &quot;进行分隔的话，左边就被序列化为&quot;2 1 &quot;，右边是&quot;2 1&quot;，二者不同。*/ 严书 6.36T1与T2均为空，或者左右子树分别相似，则称T1与T2相似 1234567891011121314bool similar(Tree T1, Tree T2) { if (T1 == NULL) { if (T2 == NULL) return true; else return false; } else { if (T2 == NULL) return false; else return (similar(T1-&gt;lchild, T2-&gt;rchild) &amp;&amp; similar(T1-&gt;rchild, T2-&gt;rchild)); } } 严书 6.42递归求二叉树中叶子结点的数目 1234567int leaf_number(BiTree T) { if (T == NULL) return 0; if (!T-&gt;lchild &amp;&amp; !T-&gt;rchild) return 1; return leaf_number(T-&gt;lchild) + leaf_number(T-&gt;rchild);} 严书 6.45删除以元素值为x的结点为根的子树 1234567891011121314151617181920212223242526272829303132333435363738394041424344// levelOrdervoid delete_x(BiTree &amp;T, int x) { if (T == NULL) return; queue&lt;TreeNode*&gt; q; q.push(T); while(!q.empty()) { int size = q.size(); for (int i = 0; i &lt; size; i ++) { TreeNode *t = q.front(); if (t-&gt;val == x) delete t; else { if (t-&gt;lchild != NULL) q.push(t-&gt;lchild); if (t-&gt;rchild != NULL) q.push(t-&gt;rchild); q.pop(); } } } return;}// recursion, preOrder deletebool delete_x(BiTree &amp;T, int x) { if (T-&gt;data == x) { delete_tree(T); T = NULL; return true; } delete_x(T-&gt;lchild, x); delete_x(T-&gt;rchild, x); return true;}bool delete_tree(BiTree &amp;T) { if (T) { delete_tree(T-&gt;lchild); delete_tree(T-&gt;rchild); delete T; return true; } return false;} 严书 6.46递归算法复制一棵二叉树 12345678void copy_tree(BiTree &amp;T, BiTree &amp;T1) { if (T == NULL) return; TreeNode t = new TreeNode; t-&gt;data = T-&gt;data; copy_tree(T-&gt;lchild, t-&gt;lchild); copy_tree(T-&gt;rchild, t-&gt;rchild); } 严书 6.55为二叉链表结点增加DescNum域，表示结点的孩子个数 12345678910111213typedef struct TreeNode { struct TreeNode *lchild; struct TreeNode *rchild; int data; int DescNum;} TreeNode, *BiTree;int add_descnum(BiTree &amp;T) { if (!T) return 0; T-&gt;DescNum = add_descnum(T-&gt;lchild) + add_descnum(T-&gt;rchild); return T-&gt;DescNum + 1;} 动态规划","link":"/2022/07/14/DS-Kaoyan-algorithm/"},{"title":"考研操作系统笔记","text":"Through the storm, we will find a way. lpf的考研提示 各位同学： 很多同学下个月要踏入考研的考场，预祝大家能收获好成绩！ 批改了几十年的考研卷子，几点建议供大家参考： 1、答案是空白，老师不会给分； 2、字尽量写的大一点，端正一点，行与行要有间距，便于老师阅卷；（老师一天要批改上千道题目） 3、突出答案中的关键部分（如平均等待时间等数字），避免阅卷老师漏掉； 4、代码加注释，避免老师短时间内看不懂你写的代码； 5、先写答案，再写过程。如在银行家算法中问是否处于安全状态，先回答是否处于安全状态，再说明理由（没有理由可能会扣分。另外，即使回答是否处于安全状态你回答错了，如果有计算过程也能得部分分数）。 第一章 导论1.1 什么是操作系统定义 操作系统是内核（Kernel）：一直运行在计算机上的程序，内核不运行则计算机无法运行。 目的 核心目标：运行程序 面向系统：高效使用计算机 面向用户：方便使用计算机 功能 操作系统是资源分配器 管理所有资源 面对冲突的资源请求，决定如何分配资源，以便系统能有效公平运行 操作系统是控制程序 管理用户程序运行，以防计算机资源的错误使用或使用不当 操作系统是计算机最底层的软件 现代计算机系统 现代计算机系统通常包含一个或多个CPU和内存、若干通过总线相连的设备控制器及其设备、总线、CPU和设备控制器可以并行工作，并竞争内存。 CPU和设备间的交互 每个设备控制器有一个本地缓冲 CPU在内存和本地缓冲之间传输数据 I/O控制器从设备到本地缓冲之间传输数据 控制器通过中断通知CPU完成操作 中断是指当出现需要时，CPU暂时停止当前进程的执行，转而处理新情况的中断处理程序。 1.2 多道程序设计和分时简单批处理系统（单道程序设计）用户将一批作业（批处理作业）提交给操作系统后就不再干预，由操作系统控制它们自动运行。 每个时刻只执行一个作业，自动从一个运行完的作业切换到下一个作业 实现了自动化作业调度（由常驻监控程序Monitor（简单批处理系统的核心）实现） 控制作业传输 调度作业运行 自动从一个运行完的作业转换到下一个作业 可以在无需人工干预的条件下运行作业（不具有交互性） 多道程序系统（多道程序设计）在内存中同时存在多道作业，在管理程序控制下相互穿插运行。 目的：提高CPU利用率 并行和并发并行：微观上，两个或多个作业在同一时刻运行 并发：宏观上，两个或多个作业在同时运行；但微观上，同一时刻只有一个作业在运行，不同作业在不同时间段依次运行 分时系统分时系统是针对交互作业设计出来的，是多道程序设计的延伸。e.g. Unix 联机的多用户交互式操作系统 采用时间片轮转方式使一台计算机为多个用户服务 在单位时间内，每个用户获得一个时间片并运行 保证用户获得足够小的响应时间，并提供交互能力 1.3 操作系统类型 大型机系统 简单批处理系统 多道程序系统 分时系统 桌面系统 适用于PC 嵌入式系统 完全嵌入受控器件内部，为特定应用设计的专用计算机系统 手持（移动）系统 适用于手持设备，如手机、平板 分布式系统 又称松耦合系统 通过网络通信：TCP/IP 目前没有真正意义上的分布式操作系统 多处理器系统 有多个紧密通信的处理器的系统。多个处理器共享计算机总线、内存和外设等。紧耦合系统。 优点：节省资金（因为共享其他设备）、增加可靠性、增加吞吐量 对称多处理（SMP）：每个处理器运行操作系统的相同副本 非对称多处理（ASMP）：各个处理器不对等，一个主处理器，若干从处理器（如骁龙820） 集群系统 通过专用网络连接一群计算机，将这些计算机虚拟化为一台有超强算力的计算机。 1.4 操作系统操作和功能操作双模式用户模式和内核模式 用以解决程序运行中出现的问题：除以零、死循环等，允许OS保护自身和其他系统部件 双模式需要CPU的支持，如果CPU有模式位，则可以在操作系统中实现双模式 内核模式的模式位为0，用户模式的模式位为1 在用户模式中，只能运行用户自编的应用程序 在内核模式中，可以运行OS内核程序（特权指令），包括I/O指令、置中断指令等 用户可以通过系统调用和软件中断执行特权指令 I/O保护I/O指令都是特权指令，防止用户执行非法I/O 内存保护通过硬件支持（基址寄存器+限长寄存器）的存储保护机制，防止内存非法访问 定时器如果用户程序死循环或不调用系统调用，那么操作系统就无法获得CPU的控制权并对系统进行管理 所以引入定时器，在一段时间后发生中断，将CPU控制权返回给操作系统 也需要硬件支持 功能进程管理、内存管理、文件管理、I/O系统管理、其他 第二章 操作系统结构2.1 操作系统服务和接口操作系统以服务形式向程序和用户提供环境执行程序 三种基本服务形式提供给程序的服务形式：系统调用 系统调用可以供程序通过应用程序接口（API）访问 三种常用API：Windows的Win32 API、POSIX系统的POSIX API、Java虚拟机的Java API 提供给用户的服务形式：用户接口、系统程序 用户接口：命令行接口（CLI）、图形接口（GUI） 智能手机采用的人机交互接口有：命令行接口、图形接口、声控接口 系统程序：用以管理、维护操作系统 文件管理（文件资源管理器）、状态信息（这台电脑-&gt;管理）、通信等 2.2 操作系统结构 简单结构（无结构）：MS-DOS、早期Unix 层次结构：每层只能使用相邻低层次的功能和服务（THE、iOS） 微内核（Mach、Windows NT、 Windows 2000） 便于移植、更稳定、更安全（适合服务器） 用户空间和内核空间通信的系统开销增加 ——&gt; 提出了消息传递机制 模块结构：大部分现代操作系统采用（Linux、Solaris） 每个核心部件分开 每个模块在需要时被加载到内核 混合结构：MacOS 2.3 虚拟机定义：虚拟机是通过软件模拟实现，具有完整硬件系统功能，并运行在一个完全隔离环境中的完整计算机系统 常见的虚拟机有三种 高级语言虚拟机（JVM） 用以模拟代码运行，实现跨平台 运行在操作系统上 工作站虚拟机（VMWare Workstation、Virtual Box） 面向工作站和PC，使得多个操作系统可以在一个计算机上使用 客户操作系统运行在宿主操作系统上 服务器虚拟机（阿里云、腾讯云等） 多用户、多操作系统并存 把服务器的物理资源抽象成逻辑资源，让一个物理计算机虚拟化为多个相互隔离的虚拟服务器 直接运行在硬件上 第三章 进程3.1 进程概念进程：一个程序在一个数据集上的一次运行 进程和程序的区别 进程是程序的一个实例，是程序的一次执行；程序是进程的代码部分 进程是动态的，程序是静态的 进程在内存中，程序在外存中 进程的组成进程包括 代码（程序段） 当前活动：程序计数器PC、堆栈(包括函数参数、返回地址、局部变量）、数据（包括全局变量）、堆（进程运行时动态分配的内存） 进程的状态运行态：指令在执行 等待态：等待资源或某些事件发生，满足条件后转化为就绪态 就绪态：等待分配处理器（时间片），满足条件后转化为运行态 新建态：创建进程 终止态：进程执行完毕 进程控制块（PCB）PCB在内核空间中，是进程在操作系统中的唯一标志 PCB中包含了和进程有关的信息：进程状态、程序计数器、CPU寄存器、CPU调度信息、内存管理信息、记账信息、I/O状态信息 进程的上下文切换需要PCB保护和恢复现场 3.2 进程操作进程创建父进程创建子进程，如此轮流创建进程，构成一棵进程树 资源共享的三种方式 父进程子进程共享所有资源 子进程共享父进程资源的子集 父进程和子进程之间无资源共享 执行顺序 父进程和子进程并发执行（默认） 父进程等待，直到子进程执行完成为止（父进程调用wait系统调用） 地址空间 子进程复制父进程的空间（与父进程具有相同的程序和数据）（fork） 子进程装入另一个新程序 fork Linux中用系统调用fork()来创建子进程。fork()创建的子进程和父进程有不同的PID ，但是它们共享相同的代码空间和资源（通过虚拟存储的写时复制技术实现），相当于复制了父进程。 通过fork()的返回值区分父子进程： 如果子进程创建失败，fork()返回-1 如果创建成功，fork()在父进程中返回新创建的子进程的PID，在子进程中返回0 进程终止当进程完成执行最后语句并且通过系统调用exit()请求操作系统删除自身时，进程终止。 进程结束的方式 进程执行最后一项并退出（exit） 进程执行完最后一项并退出 操作系统收回进程的资源 父进程终止子进程的执行（abort） 通常使用这种方式结束进程是由于以下几种原因 子进程超量分配资源 赋予子进程的任务不再需要 父进程终止 父进程可等待子进程的结束（abort） 父进程通过调用wait()系统调用来等待子进程结束 fork()创建子进程之后，父进程和子进程的运行顺序是不固定的，有可能还没有执行子进程，父进程就先结束了。我们需要让子进程先执行，然后再执行父进程，就要用wait()，让父进程等子进程运行完。 进程通信独立与协同进程 独立进程：不会影响另一个进程的执行或被另一个进程执行影响 协同进程：可能影响另一个进程的执行或被另一个进程执行影响 进程间通信（IPC）的两种模式 共享内存：一块内存在多个进程间共享 以最快的速度进行方便的通信，一般用于大数据通信 生产者-消费者 消息传递：建立连接后使用send和receive操作交换信息 用以交换较少数量的数据 消息传递分为直接通信和间接通信 直接通信：需要通信的每个进程必须明确指定通信的接收者或发送者 间接通信：消息导向至信箱并从信箱接收，两个进程只有拥有一个共享信箱时才能通信 进程间采用间接通信方式时，在消息中必须给出信箱名 消息传递分为阻塞（同步）和非阻塞（异步） 阻塞send：发送进程阻塞，直到消息被接收 阻塞receive：接收者进程阻塞，直到有消息可用 非阻塞send：发送进程发送消息并继续操作 非阻塞receive：接收者收到一个有效消息或无效消息 其他Tips 进程的创建和终止都是原子操作 原子性必须需要硬件的支持 进程创建时，进程将被设置为就绪态，不会为其分配CPU 单任务操作系统不需要进行进程上下文切换 进程创建原语的任务主要是为进程建立PCB表 进程操作的原语有：创建原语、唤醒原语、阻塞原语、撤销原语（没有延迟原语） 第四章 线程4.1 什么是线程线程是在CPU上运行的基本执行单位；进程上的一个代码片段可以被创建为一个线程 进程仍然是资源分配的基本单位；线程本身不拥有系统资源，而是向进程申请资源 每个线程含有一个栈 引入线程的原因性能角度 操作进程对系统而言开销大 应用角度 进程代码并行执行的需求 硬件角度 充分利用多核处理器的并行特性 加速进程运行 线程和进程的联系和区别代码 进程包含线程 线程是进程中的一段代码 资源 进程是资源分配的基本单位 线程不拥有资源，共享使用进程的资源 调度 线程是基本的调度单位 同一进程中的线程切换不引起进程切换 切换 进程：重量级，上下文切换代价大 线程：轻量级，切换代价小 生命期 进程撤销会导致它的所有线程被撤销 线程撤销不影响进程 线程数据结构线程控制块（TCB） TCB包含在PCB中 含有：线程ID，程序计数器，寄存器集，栈空间 线程的优点 响应度高：线程创建开销小。（e.g. Web服务器） 资源共享 经济性：线程创建和上下文切换比进程快 充分利用多处理（MP）结构 4.2 线程模型用户线程定义：由用户线程库进行管理的线程 用户线程的创建和调度在用户空间中，不需要内核的干预 内核看不见用户线程 内核线程定义：由内核进行管理的线程 需要内核支持，由内核完成调度 由内核进行创建和撤销 多线程模型多对一模型：多个用户线程对应一个内核中的用户进程，用于不支持内核线程的操作系统 内核只看到一个进程，多个线程不能并行运行在多个处理器上 进程内线程切换不会导致进程切换（减少系统开销） 一个线程的系统调用会导致整个进程阻塞 一对一模型：用户线程映射到内核线程（Windows中普遍采用） 并发性好：多个线程可以并行运行在多个处理器上 内核开销大 多对多模型：多个用户线程映射为相等或更小数目的内核线程 并发性和效率兼顾，但增加了复杂度 4.3 线程库线程库为程序员提供API来创建和管理线程 两种模式 用户库（用户线程） 存在于用户空间 调用线程库不会产生系统调用 内核库（内核线程） 存在于内核 操作系统支持 调用线程库会产生系统调用 常见线程库PThreads线程库 线程的POSIX标准 多是用户线程 Java线程库 两种创建方法 扩展java.lang.Thread类 实现Runnable接口 由JVM管理 用户线程，操作系统不可见 Win32线程库 可能会产生系统调用 Tips 同一个进程中的线程，不能共享堆栈 ‌线程是比进程更小的能独立运行的基本单位 一个线程的TCB中不包括打开文件列表 Java中的线程有六种状态 第五章 CPU调度5.1 CPU调度概述三种调度 调度 作用 开销 频率 长程/作业调度 将作业由新建态转换到就绪态 大 高（秒） 短程调度 调度程序选择下一个执行进程 小 低（毫秒） 中程调度 将进程在内存和外存换进换出 中 中 处于新建状态的进程一般首先被放到外存的进程池中，经过长程调度放入内存，转换为就绪状态 中程调度又称交换，将进程在内存和外存之间换进换出，目的是节省内存空间 调度过程调度程序（Scheduler） 根据某种策略（调度算法）选择内存中的一个就绪进程 分派程序（Dispatcher） 负责具体的进程切换工作： 负责把CPU的控制权转交CPU调度程序 切换上下文 切换到用户态 跳转到用户程序的适当位置并重新运行 调度方式非抢占式调度一旦把CPU分配给某进程之后，系统不可以抢占已分配的CPU并分配给其他进程 特点：易实现、系统开销小、适合批处理系统；响应时间长，不适合交互式系统 发生时机： 从运行转到等待 进程终止运行 抢占式调度调度程序可根据某种原则暂停某个正在执行的进程，将已分配给它的CPU重新分配给其他进程 特点：可防止单一进程长时间独占CPU；系统开销大 发生时机： 从运行转到就绪 从等待转到就绪 基本指标 CPU利用率：固定时间内CPU运行时间的比例 吞吐量：单位时间内运行完的进程数 周转时间：T完成时间 - T到达时间 响应时间：T首次运行 - T到达时间 等待时间：进程等待调度（不运行）的时间总和 5.2 先来先服务和短作业优先先来先服务（FCFS）短作业优先（SJF） SJF算法的就绪队列是按照进程的下一个CPU脉冲时间排列 非抢占式 抢占式 被称为最短剩余时间优先调度，缩写为SRTF SJF调度算法拥有最短的平均等待时间 但是存在饥饿问题 5.3 优先级调度和时间片轮转优先级调度（PR）目前主流的操作系统调度算法 优先级类型 静态优先级 进程创建时确定优先级，运行期间不变 可能产生饥饿问题（解决方法：老化，视进程等待时间的延长提高其优先级） 动态优先级 进程的优先级随着进程推进或等待时间增加而改变 高响应比优先调度算法（响应比 = 等待时间/运行时间） 抢占式 非抢占式 时间片轮转（RR）一般来说时间片轮转调度算法能够获得最短响应时间 5.4 多级队列和多处理器调度多级队列调度（MLQ）针对不同的进程使用不同的调度算法：允许系统中存在多个就绪队列，每个就绪队列有自己的调度算法 核心问题 队列数 每个队列的调度算法（每个队列的调度算法可以相同、可以不同） 决定新进程将进入哪个队列的方法 多级反馈队列调度（MLFQ）进程在其运行过程中，能在不同队列间移动 Unix, Solaris, Windows的调度算法都是MLFQ的变种 核心问题 MLQ需要考虑的问题 决定进程升级（低级队列到高级队列）和降级（高级队列到低级队列）的方法 多处理器调度适用多核处理器的CPU调度 亲和性：进程在某个给定的CPU上尽量长时间运行而不被迁移到其他处理器的倾向性 软亲和性：操作系统试图保证进程运行在同一处理器上（但不保证一定） 进程通常不会在处理器之间频繁迁移 硬亲和性：操作系统提供系统调用支持硬亲和性，使得进程运行在某个处理器子集上 进程不会在处理器之间迁移 负载平衡将负载平均分配到SMP系统的所有处理器 对于有些系统（处理器具有私有的可执行进程的队列），负载平衡是必需的；对于具有公共队列的系统，负载平衡通常没有必要，因为一旦处理器空闲，就可以从公共队列中取出一个可执行进程。 单队列调度方法（SQMP）系统有一个公共就绪队列；当任意一个CPU空闲时，就从就绪队列中选择一个到该CPU上运行 优点 容易从单核调度算法推广到多核/多处理器 实现简单，负载均衡 缺点 不具有亲和性 加锁问题 多队列调度方法（MQMP）系统有多个队列，每个CPU一个；每个就绪队列有自己的调度算法，并且调度相对独立 优点 亲和性好 不需要加锁 缺点 负载不均衡 Tips 为了照顾紧迫型进程，应采用PR调度策略 一般来说，能够获得最短响应时间的调度算法是RR算法 一般来说，能够获得最短平均等待时间的调度算法是SJF算法 SJF算法的就绪队列是按照进程的下一个CPU脉冲时间排列 对短作业不利的调度算法是FCFS 第六章 进程同步6.1 临界区同步和互斥同步：协调进程的执行次序，使并发进程间能够有效地共享资源、相互合作，保证数据一致性 互斥：进程排他性地运行某段代码，任何时候只有一个进程能够运行 临界资源：一次只允许一个进程使用的资源 共享资源：一次允许多个进程使用的资源 临界区：涉及临界资源的代码片段；由程序员确定 互斥准则 有空让进 有限等待 6.2 信号量整型信号量信号量 S 是整型变量 原子操作wait(S) / P(s) signal(S) / V(s)：V操作唤醒的进程状态可能会变为就绪态 存在忙等问题 记录型信号量分为计数信号量和二值信号量 在整型信号量的基础上增加了一个等待队列 通过加入了阻塞和唤醒机制，消除了忙等 当一个进程无法获得一个信号量时，马上释放CPU并把自己转换为等待状态，加入该信号量的等待队列，从而消除忙等 信号量S的使用 S必须置一次初值且只能置一次初值 S初值不能为负数 除了初始化，只能通过执行P、V操作访问S 互斥信号量的使用 12345Semaphore *S; S-&gt;value = 1; // 初始化为1wait(S);CriticalSection(); // 临界区signal(S); 同步信号量使用 123456789// 例如P1和P2需要比C1和C2先运行Semaphore S;S-&gt;value = 0; //初始化为0P1: C1; signal(S);P2: wait(S); C2; 6.3 经典问题生产者消费者12345678910111213141516171819semaphore *full, *empty, *mutex;full-&gt;value = 0, empty-&gt;value = N, mutex-&gt;value = 1;Producer() { prodece(); wait(empty); wait(mutex); put in; signal(mutex); signal(full);}Consumer() { wait(full); wait(mutex); take out; signal(mutex); signal(empty);} 读者写者 允许多个读者同时读 不允许多个写者同时写 不允许读者、写者同时读写 （1）读优先：要求指一个读者试图进行读操作时，如果这时正有其他读者在进行操作，他可直接开始读操作，而不需要等待。 12345678910111213141516171819202122232425/*读优先*/// rc是读者计数器，当第一个读者开始读时，给临界区加锁，写者无法写，但其他读者依然可以读// 当最后一个读者读完，rc == 0时，释放临界区，写者可以写// rc本身也是临界资源，使用互斥信号量rmutexsemaphore rwmutex = 1; // 用于写者与其他写者/读者互斥访问共享数据semaphore rmutex = 1; // 用于读者互斥访问int rc = 0;procedure reader_i: P(rmutex); rc ++; if(rc == 1) P(rwmutex); // 如果是第一个开始读的，就给临界区加锁，不允许写者写 V(rmutex); 读数据; P(rmutex); rc --; if(rc == 0) V(rwmutex); // 如果是最后一个读完的，就给临界区解锁，允许写者写 V(rmutex);procedure writer_i: P(rwmutex); 写数据; V(rwmutex); （2）写优先：一个读者试图进行读操作时，如果有其他写者在等待进行写操作或正在进行写操作，他要等待该写者完成写操作后才开始读操作。 12345678910111213141516171819202122/*写优先多个读者可以同时进行读写者必须互斥写者优先于读者（一旦有写者，后续的读者都必须等待写完）*/semaphore rwmutex = 1; // 用于写者与其他写者/读者互斥访问共享数据semaphore rmutex = 10; // 假设有10个读者进程procedure reader_i: P(rwmutex); // 读写互斥，在写者已经在写时不能读，读者在读时不能写 P(rmutex); V(rwmutex); // 释放读写互斥 读数据; V(rmutex);procedure writer_i: P(rwmutex); for (int i = 0; i &lt; 10; i ++) P(rmutex); // 禁止新读者，并等待已进入的读者退出 写数据; for (int i = 0; i &lt; 10; i ++) V(rmutex); // 恢复允许rmutex值为10 V(rwmutex); 哲学家就餐防止死锁可采取的措施 最多允许（筷子数 - 1）个哲学家同时坐在 仅当一个哲学家左右两边筷子都可用时，才允许他拿筷子 给所有哲学家编号，奇数哲学家必须先拿左边筷子，偶数哲学家反之 增加一根额外的筷子 6.4 管程由编程语言解决同步和互斥问题；引入管程可以方便程序员在代码中实现同步 第七章 死锁7.1 死锁概念及其资源分配图死锁：一组等待进程，其中每一个进程都持有资源，并且等待着由这个组中其他进程所持有的资源 死锁的必要条件互斥：一次只有一个进程可以使用一个资源 占有并等待：一个至少持有一个资源的进程等待获得额外的由其他进程所持有的资源 不可抢占：一个资源只有当持有它的进程完成任务后，才会自由地释放 循环等待：等待资源的进程之间存在环 资源分配图 如果资源分配图没有环，那么系统就不处于死锁状态 如果资源分配图有环，那么系统可能处于死锁状态 如果每个资源类型刚好有一个实例，那么有环就意味着已经出现死锁（充分必要）；如果每个资源类型有多个实例，那么有环并不意味着出现了死锁（必要非充分）。 死锁处理方法一般来说，处理死锁问题有三种方法： 通过协议来预防或避免死锁，确保系统不会进入死锁状态 可以允许系统进入死锁状态，然后检测并恢复 忽略这个问题（被大多数操作系统所采用） 忽略死锁的可能性要比其他方法更便宜。对于许多系统，死锁很少发生（如一年一次），发生之后人工重启系统即可。所以和死锁预防、死锁避免和死锁检测与恢复相比，这种方法更便宜。 7.2 死锁预防死锁预防是一组方法，确保至少一个上述的必要条件不成立 通过限制资源申请的方法来预防死锁，降低了设备使用率和系统吞吐量 互斥如系统存在互斥资源，不能改变这个条件来预防死锁 占有并等待必须保证进程申请资源的时候没有占有其他资源 静态分配策略 要求进程在执行前一次性申请全部的资源或要求进程只有在没有资源时才可申请资源 利用率低，可能出现饥饿 非抢占当一个进程处于等待时，如果其他进程申请其拥有的资源，那么该进程的部分资源可以被抢占 循环等待对所有的资源类型进行总排序，并且要求进程按照递增顺序申请资源，先申请数量少的资源，用完并释放后再申请数量多的 7.3 死锁避免获得以后如何申请资源的附加信息来决定是否分配资源 死锁避免算法动态检查资源分配状态以确保循环等待条件不可能成立 资源分配图算法适用于每个资源类型只有一个实例的系统 需求边（虚线）、请求边、分配边 请求能满足的前提是：把请求边转换为分配边后不会导致环存在。如果有环存在，那么分配会导致系统处于非安全状态 通过采用环检测算法（$O(n^2)$）检查安全性 银行家算法适用于每个资源类型有多个实例的系统 安全算法+资源请求算法 7.4 死锁检测和恢复死锁检测单个实例 —— 资源等待图资源等待图是资源分配图的简化，适用于每种资源类型只有单个实例的系统 若等待图中有环，则系统一定产生了死锁 为检测死锁，系统需要维护等待图，并周期调用环检测算法，复杂度为$O(n^2)$ 多个实例类似银行家算法中的安全算法，只不过把Need换成Request，Finish[]中值为false的元素即为发生死锁的进程 死锁恢复 操作员人工恢复 自动恢复 终止进程 中断所有的死锁进程 一次中断一个进程直到死锁消失 抢占资源 总结死锁产生的必要条件： 互斥 持有并等待 非抢占 循环等待 死锁处理的方法： 死锁预防：确保至少一个死锁产生的必要条件不发生（其中互斥条件无法改变） 死锁避免： 死锁的检测与恢复 Tips 死锁避免方法不会限制用户申请资源的顺序；死锁预防的破坏循环等待条件才会 所有进程都被挂起时，系统不一定陷入死锁 每个死锁进程必然占据了某类资源 &lt;–错误，因为可能有的资源本身没有占有资源，但是在等待被占有的资源，此时它也处于死锁中。比如汽车过桥问题中，不在桥上但不能过桥的汽车。 在为多道程序所提供的系统资源不足时，可能出现死锁。但是，不恰当的进程推进顺序也可能产生死锁 ‏当检测出发生死锁时，可以通过撤销一个进程解除死锁（错误，可能需要撤销多个进程才能解除死锁） 第八章 内存管理8.1 内存管理背景内存管理的目的 提高内存利用率 提高内存数据访问的速度 进行存储保护 基本硬件CPU可以直接访问的通用存储只有内存和处理器内置的寄存器 程序必须装入内存才能被执行 内存保护保护用户进程不会相互影响 内存保护通过硬件来实现，因为操作系统通常不干预CPU对内存的访问（会导致性能损失） 内存保护的一种可能方案： 动态重定位 确保每个进程都有一个单独的内存空间。 基址寄存器：含有最小的合法的物理内存地址 界限寄存器：指定了范围的大小 只有操作系统可以通过特殊的特权指令，才能加载基址寄存器和界限寄存器 地址绑定程序以二进制可执行文件的形式存储在磁盘上，为了执行，程序被调入内存并放在进程中。 地址绑定通常发生在以下三个时期： 编译时：如果在编译时就已经知道进程将在内存中的驻留地址，那么就可以生成绝对代码 加载时：如果在编译时不知道进程将驻留在何处，那么编译器就生成可重定位代码 执行时：如果进程在执行时可以从一个内存段移到另一个内存段，那么绑定应延迟到执行时才进行（绝大多数操作系统采用） 逻辑地址和物理地址逻辑地址（虚拟地址）：CPU生成的地址 物理地址（实地址）：内存单元看到的地址 从逻辑地址到物理地址的运行时映射是由内存管理单元（MMU）的硬件设备来完成 动态加载为了获得更好的内存空间利用率，可以使用动态加载。此时，一个程序只有在调用时才会加载，所有程序都以可重定位加载格式保存在磁盘上。 动态加载不需要操作系统提供特别支持。 动态链接库动态链接库为系统库，将各种库文件的连接被推迟到执行时期。 与动态加载不同，动态链接通常需要操作系统的帮助。 8.2 连续内存分配连续内存分配是早期内存分配方式，运用于内存较少的系统 涉及三种类型：单一连续分配、固定分区分配、可变分区分配 单一连续分配单道程序环境下，仅装有一道用户程序，整个内存的用户空间由该程序独占，这种分配方案称为单一连续分配 固定分区分配预先把可分配的主存空间分割成若干个连续的区域，称为一个分区 每个分区的大小可以相同也可以不同，但分区大小固定不变，每个分区只能装入一个程序 可变分区分配可变分区分配是固定分配分区的延伸，主要用于批处理系统 对于可变分区方案，操作系统有一个表，用于记录哪些内存可用和哪些内存已用。开始，所有内存都可用于用户进程，因此可以作为一大块的可用内存，称为孔。最后，内存中会有一个集合，包含各种大小的孔。 存储分配算法 首次适应：分配首个足够大的孔 最佳适应：分配最小的足够大的孔 最差适应：分配最大的孔 在速度和存储空间的利用上，首次适应和最佳适应要好于最差适应（但是会产生外部碎片） 减少碎片的方法：紧缩，把小的空闲内存结合成一个大的块（必须得到动态重定位的支持才能采用） 8.3 分页内存管理由连续分配方式发展为分页存储管理方式的主要动力是：提高内存利用率 每个进程拥有一张页表，且进程的页表驻留在内存中（不是只有执行进程的页表驻留） 允许进程的物理地址空间可能不连续 将物理内存分成大小固定的块，称为帧 将逻辑内存分成同样大小的块，称为页 地址转换机制CPU生成的每个地址分为两部分：页码和页偏移。页码作为页表的索引，页表包含每页在物理内存的基地址，这个基地址和页偏移的组合就成了物理内存地址，可发送到物理单元。 注意页表项中只有帧号，所以一个32位的页表项可以指向$2^32$个物理帧的任意一个 硬件支持如果页表比较小，可以将页表存放于寄存器中。但如果页表较大（例如100万个条目），就只能存放于内存中 页表基地址寄存器（PTBR）指向页表，改变页表时只需要改变这一寄存器即可，这大大降低了上下文切换的时间 转换表缓冲区（TLB）中存放页码和帧码 假设寄存器的查找需要时间为a，访问一次内存时间为b，命中率为$\\lambda$$$有效访问时间EAT=\\lambda(a+b)+(1-\\lambda)(a+2b)$$ 页共享如果代码是可重入代码（只读），可以在进程间共享；共享代码出现在所有进程的逻辑空间的相同位置 8.4 页表结构层次页表哈希页表虚拟页号被散列到一个页表中，这种页表的每一个条目都包括了一个链表元素（拉链法处理碰撞），这些元素哈希成同一位置 页表中每个元素有三个域：虚拟页号、所映射的帧号、指向下一个元素的指针 反向页表（倒置页表）反向页表适用于进程较多的系统 通常来说，每个进程都有一个页表，而每个页表有很多项，需要消耗大量物理内存。为了解决这个问题，可以使用反向页表。反向页表对于每个真正的内存页或帧才有一个条目。每个条目保存真正内存位置的页的虚拟地址，以及拥有这个页的进程的信息。 整个系统只有一个页表，对每个物理内存的页也只有一条对应的条目 8.5 分段内存管理分段的特点 支持用户观点的内存管理机制 逻辑地址空间是由一组段组成的，每个段都有名称和长度，地址指明了段名称和段内偏移 可以实现有意义的共享 方便进行地址转换 程序不需要连续的内存 在段式存储管理中，一个段是不定长的连续区域 会产生外部碎片（两个段中间的空闲区有可能过小而无法分配给其他程序段） 地址 由谁确定 存储 分页 逻辑地址连续，一维 操作系统 各页可以分散存放在主存 分段 逻辑地址不连续，二维 用户 每段必须采用连续的主存空间 8.6 内存“扩充”技术为了解决内存空间不足的问题所产生的技术 虚拟内存覆盖在程序执行过程中，程序的不同部分相互替换，只在内存中保留那些在任何时间都需要的指令和数据 现代操作系统一般不用 由程序员声明覆盖结构，不需要操作系统的特别支持 交换把内存中暂时不能运行的进程或者暂时不用的程序和数据调出到外存上的备份区，再把已具备运行条件的进程或进程所需的程序或数据调入内存 交换较为耗时（100MB大约4S） 交换时间的主要部分是转移时间，总的转移时间直接同交换的内存数量成正比 标准交换技术在现代操作系统中一般很少使用 其他Tips 采用覆盖和交换技术的目的是减少程序占用的主存空间 采用覆盖技术不需要操作系统的支持 采用交换技术需要I/O支持 每个进程拥有一张页表，且进程的页表驻留在内存中 存在内部碎片的存储管理方式：固定分区分配、单一连续分配、段页式存储管理 存在外部碎片的存储管理方式：可变分区分配、段式存储管理 实现进程间数据共享最方便的存储管理技术是分段 在页式存储管理中，引入快表可以减少每一次的内存访问时间（错误，引入快表只能减少平均的内存访问时间，而不是每次内存访问时间） 对于通用计算机而言，存储层次分为四层：CPU寄存器。 高速缓存、主存和辅存 ‏采用动态重定位方式装入的作业，其地址变换工作是在每执行一条指令时完成的。 第九章 虚拟内存内存不够进程运行 -&gt; 虚拟内存技术 虚拟内存使用请求分页技术实现 -&gt; 如何处理缺页、页置换、给进程分配页框数等问题 页置换问题 -&gt; 页置换算法 给进程分配页框 -&gt; 固定分配、优先级分配；颠簸问题 内核内存分配 -&gt; buddy, slab 9.1 虚拟存储技术局部性原理 虚拟存储技术 当进程运行时，先将其一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动将它们从磁盘调入内存执行 虚拟内存大小由：操作系统字长和内外存容量和共同决定 使用虚拟内存的共享库 通过将共享对象映射到虚拟地址空间，系统库可以被多个进程所共享 虚拟内存允许进程共享内存 虚拟内存可允许在创建进程期间共享页，从而加快进程创建（fork） 写时复制(Copy on Write) 允许父进程和子进程在初始化时共享页面 虚拟内存的实现 虚拟页式 请求分页 预调页 虚拟段式 9.2 请求分页进程开始运行之前，不是装入全部页面，而是装入一个或零个页面。运行之后，根据进程需要而动态装入其它页面。当内存空间已满，需要装入新的页面时，则根据某种算法置换内存中的某个页面，以便装入新的页面。 有效-无效位请求分页的实现需要在页表的表项中增加一个“有效-无效位”，1表示在该页在内存，0表示不在内存。在所有的表项中，这个位被初始化为0 缺页中断如果访问的页不在内存，系统陷入缺页中断。此时系统决定终止执行指令或将该页从外存中调入内存，再更改页表，然后重启指令 缺页中断属于程序中断 请求分页讨论极端情况下，进程创建时未被分配内存，导致进程执行第一行代码开始就不断产生缺页中断。这种情况被称为纯请求分页 请求分页性能缺页率： $0&lt;= p &lt;= 1$ 有效访问时间（EAT）： $$EAT = (1-p) \\times 内存访问时间 + p \\times 页错误时间$$ 页错误时间 = 处理缺页中断 + [页交换出去的时间] + 读入页时间 + 重启进程开销 9.3 页面置换页置换过程 将待置换的帧换出至磁盘 修改页表，将换出的帧有效位设置为i 将待换入的页换入内存 修改页表，将换入的帧有效位设置为v 页置换讨论 如果发生页置换，则缺页处理时间加倍 通过修改位或脏位来防止页面转移过多（只有修改过的页面才换出到磁盘，否则直接舍弃） 页置换算法1. 先进先出算法（FIFO）：可能会导致Belady异常（页框更多-&gt;缺页更多）。使用FIFO队列来管理内存中所有的页。 2. 最优置换算法（OPT）：置换将来不再需要的页（无法实现） 3. 最近最少使用算法（LRU）：置换最长时间没有使用的页。需要一个计数器或栈来实现（开销大，需要硬件支持） 4. 不经常使用算法（NFU）：将每个页面与一个软件计数器相关联，每次时钟中断时，将每个页面的R位(即访问位，值是0或1)加到它的计数器上，缺页时置换值最小的页。老化算法 5. 二次机会算法：以循环链表的形式存储所有的页，为每个页设置R位，如果将要交换的页访问位是0则直接置换；如果是1则将其置零，然后对后面的页执行相同的操作。实现：时钟置换 9.4 页框分配和颠簸固定分配平均分配：100个页框，5个进程，每个进程分配20个页 按比例分配：根据每个进程的大小来分配 优先级分配按照优先级而不是进程大小来使用比率分配策略 如果进程Pi产生一个缺页： 可能选择替换Pi自己的页框 可能从一个较低优先级的进程中选择一个页面来替换 全局置换和局部置换全局置换：进程在所有的页框（包括其他进程的）中选择一个替换页面 局部置换：每个进程只从属于自己的页框中选择 颠簸（抖动）颠簸：一个进程的页面经常换入换出 工作集（Working Set）假如进程Pi最近的10个引用（称为工作集窗口）是：2 6 1 5 7 7 7 7 5 1，那么在这10个引用中，它的工作集就是${1,2,5,6,7}$ 缺页率（PFF）策略设置一个可接受的缺页率，如果缺页率太低，回收一些进程的页框；如果缺页率太高，就分给进程一些页框 9.5 内核内存分配内核内存不同于用户内存，通常从空闲内存池中获取，因为： 内核需要为不同大小的数据结构分配内存 一些内核内存需要连续的物理页 占用内存块的时间比较短 伙伴（Buddy）系统主要思想：内存按2的幂的大小进行划分，组成若干空闲块链表；查找链表找到满足进程要求的最佳匹配块。 当分配需求小于现在可用内存时，当前段就分为两个更小的2的幂段（伙伴），继续上述操作直到合适的段大小。 主要用于Linux早期版本中内核底层内存管理 从物理上连续的大小固定的段上分配内存 优点：可通过合并而快速形成更大的段 缺点：容易产生碎片 Slab分配主要思想： Slab层把不同的对象划分为所谓的Cache组，每个Cache都存放不同类型的对象（例如一个Cache存放task_struct结构体，另一个Cache存放struct_inode结构体）。 Slab是由一个或多个物理上连续的页组成，每个Cache又由一个或多个slab组成。 每个内核数据结构都有一个Cache（如进程描述符、文件对象、信号量等）。 Slab分配：当创建cache时，包括若干个标记为空闲的对象，对象的数量与slab的大小有关。当需要内核对象时，从cache上直接获取，并标记对象为使用。当一个slab充满了已使用的对象时，下一个对象的分配从空的slab开始分配。 优点： 没有因碎片引起的内存浪费 内存请求可以快速满足（因为对象预先创建，需要使用时只需要标记为使用） 9.6 虚拟内存中的其他考虑预先调页在纯请求调页中，进程启动初期会有大量的缺页中断 预先调页在引用前，调入进程的所有或一些需要的页面，从而减少缺页 页面尺寸没有最佳答案，取决于考虑的方面。但总的来说，现代操作系统趋向更大的页 页表大小：需要大的页，从而减少页表项 碎片：需要小的页 I/O开销：需要大的页，因为磁盘的寻道时间和延迟时间远超传输时间 程序局部：需要小的页，从而精确匹配程序局部 缺页次数：需要大的页，因为每次缺页会产生大量的额外开销 TLB的命中率TLB范围：通过TLB所访问的内存量 $$TLB范围=（TLB大小）\\times （页大小）$$ 理想情况下，一个进程的工作集应存放在TLB中，否则会有大量的缺页中断 反向页表I/O互锁允许某些页在内存中被锁住 为了防止I/O出错，有两种解决方案： 不允许用户内存进行I/O 允许页锁在内部，锁住的页不能被置换 其他Tips 可以实现虚拟存储的存储管理方法：分页、分段、段页式 缺页中断属于程序中断 程序部分装入技术可带来的好处有：1.更多的进程可以并发执行，提高了CPU的利用率 2.每个进程所需的内存量更小 3.载入或交换每个用户进程到内存所需的I/O会更少 4.进程大小不再受到物理内存大小的限制 请求式分页的优点：1.系统能够快速响应 2.需要很少的物理内存 3.可以支持多用户 4.需要很少的I/O 在采用虚存的系统中，要求程序运行前不必全部装入内存且在运行过程中不必一直驻留在内存 第十章 文件系统接口10.1 文件文件概念文件是计算机中信息存储的基本组织形式；是具有文件名的相关信息集合 文件结构是指文件内信息的组织方式 目的是便于程序理解文件内容。操作系统和应用程序决定了文件的结构 常用文件结构 无结构：字节流等 简单记录结构：线性、固定长度、可变长度等 复杂结构：格式化文档、多媒体文件等 一般可执行文件采用的文件结构是字符流 文件类型文件类型一般由扩展名决定，如.txt .doc等 文件属性名称 标识符：文件的唯一标记 类型 位置：指向文件位置的指针 尺寸：文件的当前大小（以字节、块为单位） 保护：访问控制信息 时间、日期和用户标识 所有文件的信息保存在目录结构中，该目录结构保存在外存上。通常，目录条目由文件的名称及其唯一标识符组成。 文件操作创建文件、写、读、打开、关闭、截断、删除等 打开文件操作不是一个文件系统中必须具有的操作 创建文件：首先要在文件系统中为文件找到空间，其次要在目录中创建新文件的条目 写文件：使用一个系统调用指定文件名称和要写入的位置，系统根据给定的文件名搜索目录以查找文件位置。系统保留写指针用于指向需要进行下次写操作的文件位置。 读文件：使用一个系统调用，指明文件名称和需要文件的下一个块应该放在哪里。系统搜寻目录找到相关条目，并保留一个读指针。 重新定位文件：搜寻目录找到适当的条目，并且将当前文件位置指针重新定位到给定值。 删除文件：在目录中搜索给定名称的文件，找到关联的目录条目后，释放所有文件空间，并删除目录条目 以上大多数操作都要搜寻目录找到对应的条目。而操作系统有一个打开文件表，用以维护所有打开文件的信息。当请求文件操作时，可通过该表的索引指定文件，而不需要搜索。 具体操作过程创建文件：应用程序调用逻辑文件系统，逻辑文件系统分配一个新的FCB，然后将相应的目录读到内存，使用新的文件名和FCB进行更新，并将目录写回磁盘。 打开文件：系统调用open()将文件名传递到逻辑文件系统。open()首先搜索整个系统的打开文件表，以确定这个文件是否已被其他进程使用，若是，则在单个进程的打开文件表中创建一个条目，指向系统的打开文件表；若否，则根据文件名搜索目录结构，找到文件后将其FCB复制到系统的打开文件表中，再在进程的打开文件表中创建一个条目，指向系统的打开文件表。 关闭文件：进程的打开文件表的条目被删除，系统的打开数目减少。当所有打开该文件的用户关闭它时，所有更新过的数据被复制到磁盘中，系统的打开文件表条目被删除。 系统中的数据结构 打开文件表：跟踪打开文件，分为系统的和进程的 文件指针：指向最后一次读写的位置，每个进程有一个（lseek()） 打开文件计数器：打开文件（调用open()）次数 访问控制 10.2 逻辑文件及其访问方法文件访问文件系统的主要功能是文件访问，也就是检索、读写等操作 逻辑文件逻辑文件指文件呈现在用户面前的组织结构，又称为文件逻辑结构；和实际在磁盘上的存储方式无关 逻辑文件决定了文件访问方法，不同的逻辑文件有不同的访问方式 顺序访问：按照存放顺序依次访问，如磁带 直接（随机）访问：可以随机访问，如磁盘、光盘 顺序文件顺序文件是最常用的文件组织形式，由一系列不等长记录按照某种顺序排列形成。只能顺序访问 优点：记录存储紧凑 缺点：访问效率差 直接（随机）文件采用直接访问方式，直接文件一般组织为记录等长的文件 用户提供给操作系统的块号，通常为相对块号。文件的第一相对块是0。 优点：访问效率高，可直接定位到某条记录 缺点：浪费存储空间（因为记录可能不等长，要使记录等长，就要把每条都扩充到最长记录的大小） 索引文件为了结合顺序文件和直接文件的优点，为顺序文件建立索引表，表项等长以便随机访问，表中每项中有指针指向文件中的记录 索引文件广泛用于组织需要频繁检索的文件，如数据库文件等 对于大文件，索引文件本身可能变得太大而无法保存在内存中。解决方法是为索引文件创建索引 10.3 文件目录文件控制块FCB用以保存文件的各种属性信息（文件名、权限、拥有者、组、大小、修改次数等） 必须通过文件控制块来访问文件 目录目录由目录项有序构成，一个目录中的目录项组成了目录文件，每个目录项存放了一个文件的各类属性 在有的操作系统中，目录项 = 文件控制块 目录是用户和文件之间的桥梁，负责把文件名转换为文件在存储设备上的位置 inode为了减小目录项的大小，提升文件访问的效率，产生了inode Unix为每个文件控制块建立一个索引项，内容为文件名和指向文件控制块的指针，类似于索引文件，称为Inode inode用于描述保存给定文件的元数据的结构，例如其长度、权限以及其组成块的位置。每个inode都由一个数字（称为inumber）隐式引用。给定一个inumber，以其为偏移量，在inode的bitmap中可以定位到该inode位置 在inode中存放有一个或多个直接指针，指向属于该文件的一个数据块；为了支持更大的文件，inode中又引入了多级索引，即间接指针 10.4 目录结构目录设计的目标：访问效率、同名文件、文件分组 单层目录只有一个根目录“/” 结构简单，检索效率差，不允许重名，不能分组 双层目录为每个用户建立自己的目录 不同用户可有相同命名的文件；每个用户的文件无法分组，同一用户文件无法重名 将不同用户进行隔离，虽然保证了用户文件的独立性，但也使得不同用户难以访问对方的文件 树型目录把双层目录进行扩展 检索高效、可以分组、允许重名，禁止共享文件或目录 图型目录无环图目录：有向边无环，不同目录内可以指向同一文件，实现文件共享 通用图（有环图）目录：允许图中有环，会出现目录内的文件又指回目录的情况 文件共享硬链接：硬链接文件具有相同inode的节点号。硬链接文件是普通文件。 新建一个文件f1，内容为”this is file1”，再ln f1 f2，创建f1的硬链接f2。此时f2中的内容也为”this is f1”。将f1或f2删除（unlink()），不影响另一个文件。f1和f2的inode相同。 符号链接（软链接）：就是快捷方式。软连接文件和源文件是不同的文件，文件类型不同，inode号也不同。 新建一个文件f1，内容为”this is file1”，再ln -s f1 f3，创建f1的符号链接f3。此时f3中的内容也为”this is f1”。将f1删除，f3依然存在，但无法访问。f1和f3的inode不同。 目录实现线性列表：采用文件名称和数据块指针的线性列表。查找文件需要线性搜索 哈希表：除了采用线性列表存储目录条目外，还采用了哈希数据结构，根据文件名称获得一个值，并返回列表内的一个文件指针 Tips 一般可执行文件采用的文件结构是字符流 打开文件操作不是一个文件系统中必须具有的操作 在文件系统中，打开文件的主要操作是创建一个目录项（错） 可以实现文件共享的目录结构是图型目录 文件的逻辑结构一般可能由应用程序、操作系统、用户决定 第十一章 文件系统实现11.1 文件系统文件系统是操作系统中负责管理和存储文件信息的模块，提供了在存储设备上组织文件的方法和数据结构 在系统角度上 文件系统对存储设备的空间进行组织和分配，负责文件检索、读写等操作 目标：存取速度和存储空间效率 在用户角度上： 文件系统提供按名存取的文件访问机制、文件的组织管理 目标：方便的文件存取机制 文件系统的层次架构从低到高：设备-&gt;I/O控制-&gt;基本文件系统-&gt;文件组织模块-&gt;逻辑文件系统-&gt;应用程序 基本文件系统：物理块读写、向设备驱动程序发送控制命令 文件组织模块：管理文件、逻辑块和物理块；把文件的逻辑地址转为物理地址；管理空闲空间；为文件分配物理块 逻辑文件系统：文件按名存取；文件目录组织管理；把文件名转换为文件ID、文件句柄；管理FCB 文件系统实现磁盘文件系统 引导控制块：包含了系统引导操作系统的各种信息，只有安装操作系统的分区才有 分区控制块：包含分区信息，UFS称为超级块 目录和FCB 用户文件 内存文件系统 分区表：所有安装分区信息 目录缓冲结构：保存最近访问的目录信息 进程打开文件表 系统打开文件表 文件操作需要用到内存文件系统，目的是通过缓冲提高文件系统性能 虚拟文件系统 把多个文件系统整合成一个目录结构，为用户屏蔽各个文件系统的差异 网络文件系统 通过LAN（或WAN）访问远程文件系统 常用文件系统Window：FAT, NTFS Linux：Ext(Ext2, Ext3, Ext4) （Ext：基于扩展的文件系统） MacOS：HFS 11.2 连续分配物理块：存储设备的基本分配单位。系统以物理块为单位为文件分配存储空间。物理块的大小和页面大小相对应，从0开始编号 逻辑块：在文件空间中的块。大小和物理块一致，一个逻辑块存储在一个物理块中。块号从0开始 连续分配：每个文件在磁盘上占用一组连续的物理块。访问文件时，FCB只需给出&lt;起始块号，长度&gt; 地址映射：将逻辑地址（一维）映射到物理地址（二维）。 目录格式：&lt;文件名，起始块号，长度&gt; 优点：支持随机访问、存取速度快、适用一次性写入操作 缺点：浪费空间（小空间无法分配，外部碎片）、文件不能动态增长、不利于文件的插入和删除 11.3 链接分配链接分配：文件信息存放在若干个不连续的物理块中，所有物理块通过指针链接成链表结构 目录格式：&lt;文件名，起始块号，结束块号&gt; 优点：提高磁盘的利用率（没有外部碎片）、可以动态扩充文件大小、便于文件的插入和删除 缺点：无法实现随机/直接访问、可靠性差 分类 隐式链接：链表的指针分散存放在物理块中，每个物理块中的指针指向下一个物理块 为了读入一个指针需要读入整个物理块 显式链接：指针集中存放，把所有指针存放在一张链接表中，每个磁盘块都有一个条目，并可按块号索引 例子：FAT（用于MS-DOS） 链接表一般在文件系统装载时装入内存 改善了随机访问时间：通过读入FAT信息，磁头能找到任何块的位置 不适合大容量磁盘（因为此时链接表会非常大） FAT表存放在磁盘每个卷的开头 目录条目包含文件首块的块号，通过这个块号索引的表条目包含文件的下一块的块号 未使用的块用0作为条目的值来表示。为文件分配新块时，只要找到第一个值为0的FAT条目，用新块的地址替换前面文件结束值，用文件结束值替代0 11.4 索引分配索引分配：将所有指针放在一起，即索引块 索引块：索引块的第i个条目指向文件的第i个块 目录格式：&lt;文件名，索引块&gt; 访问文件时，先访问该文件的索引块，再从索引块中找到文件所占的物理块，FCB指向索引块 优点：支持随机访问（先访问索引块，再访问具体块）、离散存储，没有碎片 缺点：需要额外空间存放索引表、磁盘访问时间增加（物理块分布在磁盘各地） 如果文件很小，只占1到2块，采用链接分配只会浪费1到2个指针的空间，而如果采用索引分配，即使只有1到2个指针是非空的，也需要分配一个完整的索引块。所以对于小文件尽量不要使用索引分配。 但如果文件太大，一个索引块不能存放所有指针应该怎么办？ 多级索引大文件无法用单级索引实现，于是产生了多级索引 例如，物理块大小4KB，表项大小4B，每个索引块中可以存放4KB/4B=1K个表项，所以单级目录支持的最大文件是1K*4KB=4MB n级索引文件大小：$(1K)^n\\times 4KB$ 联合策略Unix中采用多种索引混合的策略 将索引块的前几个指针（如15）存在文件的inode中，这些指针的前12个指向直接块，即它们包含物理块的地址。接下来的3个指针指向间接块，第一个指向一级间接块，一级间接块为索引块；第二个指向二级间接块，最后一个指针为三级间接块。 11.5 空闲空间管理空闲表空闲区：连续的未分配物理块集合 空闲表：&lt;首块块号, 长度&gt;。每个表项对应一个空闲区。适用连续分配 空闲链表将磁盘上所有空闲块链接在一个链表中 分配：从链表头依次摘下适当数目的空闲块 回收：空闲块加入链表尾部 位示图利用二进制一位来表示一个块的使用情况，1代表盘块空闲，0代表盘块已分配 所有块都有一个二进制位与之对应 位示图需要额外的空间，存放在物理块中。分配时，将1改成0，回收时，将0改成1 成组链接结合了空闲表和空闲链表 例如Unix系统中： 将空闲块分成若干组，每100块为一组 每组第一个空闲块中包括：空闲块总数、下一组空闲块首块的块号、本组其它空闲块的块号列表 一致性检查将目录结构数据与磁盘空闲块结构相比较，纠正发现的不一致 空闲空间整理把不连续的空闲块集合在一起 有利于给文件分配连续的物理块 Tips 采用离散分配的磁盘空间分配方法有：链接分配、索引分配、基于扩展的文件系统（Ext） 文件信息隐藏在若干个不连续物理块中的链接分配模式是隐式链接 第十二章 大容量存储器结构12.1 磁盘结构和管理磁盘结构盘片、磁头、主轴；接口、磁盘控制器、缓冲区 盘片结构磁道（从外面开始从“0”编号）、扇区（扇区大小为512B）、柱面 地址映射关系块号 LBA 磁盘地址（CHS）格式：&lt;柱面Cylinder，磁头/面Head，扇区Sector&gt; $$柱面号 = 块号 / (每个磁道扇区数 \\times 扇面数)$$ $$磁头号 = (块号 / 每个磁道扇区数)\\mod 扇面数$$ $$扇区号 = (块号\\mod 每个磁道扇区数) + 1$$ 磁盘访问时间$$磁盘访问时间 = 寻道时间 + 旋转延迟时间 + 传输时间 + 系统开销时间$$ 例：4KB块，7200 RPM磁盘， 5ms平均寻道时间，1Gb/sec传输率，0 .1ms 控制开销： 5ms + 0.5 * (7200 / 60)s + 4KB / 1Gb/s + 0.1ms = 9.30ms 磁盘管理低级格式化（物理格式化）：将磁盘分成扇区，以便磁盘控制器读写 分区：将磁盘分成分区，主分区和扩展分区 高级格式化（逻辑格式化：创建文件系统 引导块 12.2 磁盘调度和RAID磁盘调度目标是减少磁盘访问时间，使寻道时间最小化 调度算法先来先服务 FCFS 最短寻道时间优先 SSTF 饥饿 扫描算法/电梯算法 SCAN 到达另一端时，磁头改变移动方向 饥饿：当磁头当前位置前后有大量请求时，另外一段的请求会长期等待；C-SCAN也有这种问题，但由于其单向响应请求，理论上可以缓解一半 循环扫描算法 C-SCAN 从起始位置移动到一端，中间处理请求。然后从一端回到另一端，这个过程不处理请求 单向处理请求 磁头从硬盘外道（0道）移动到内道的过程中处理请求 内道移动到外道的过程中不处理请求 具有更加均匀的等待时间 循环LOOK算法 C-LOOK C-SCAN的变形，磁头只移动到一个方向上最远请求为止，而不是继续移动到磁盘尽头 实际上，SSTF 较为普遍而且很有吸引力，SCAN和C-SCAN适合磁盘大负荷系统（数据库） RAID结构由很多价格较便宜的磁盘，组合成一个大容量的磁盘组，利用个别磁盘提供数据所产生的加成效果提升整个磁盘系统效能和可靠性 可靠性：引入冗余 性能：数据分散在多个磁盘，并行读写 RAID级别RAID 0 条带化，没有冗余 数据分散在多个磁盘上 提高读写性能（并行） 不具有容错功能 RAID 1 磁盘镜像 提高可靠性 RAID 5 分散 + 校验 校验信息分散在各个磁盘 RAID 01 / RAID 10 RAID 0 重视性能，RAID 1 重视可靠性 RAID 01 先做分散，再镜像，性能好 RAID 10 先镜像，再分散，可靠性好 Tips 不具有容错功能的RAID技术是RAID 0 数据库服务器的磁盘一般采用的磁盘调度算法是SCAN 具有更加均匀的等待时间的磁盘调度算法是C-SCAN 可能存在饥饿现象的磁盘调度算法是SCAN、SSTF 操作系统的引导程序一般存放在ROM中（错误，自举程序存放在ROM中，引导程序在磁盘中） LOOK算法总比SCAN算法优 （错误） ‎磁盘调度的目的是减少磁盘访问时间 LOOK算法总比SCAN算法优（错误） 第十三章 I/O系统13.1 I/O基本概念I/O系统的基本功能隐藏物理设备的细节、与设备的无关性、提高处理机和I/O设备的利用率、对I/O设备进行控制、确保对设备的正确共享、错误处理 设备独立性引入逻辑设备和物理设备 在应用程序中，使用逻辑设备名来请求使用某类设备，而系统在实际执行时使用物理设备名 内核I/O结构从低到高：硬件 -&gt; 设备驱动程序 -&gt; I/O驱动结构 -&gt; 内核I/O子系统 -&gt; I/O应用接口 -&gt; 应用程序 I/O硬件端口 总线 控制器 I/O硬件控制控制设备方法 直接I/O指令 内存映射I/O：设备地址和内存统一编址 I/O寄存器 状态寄存器 控制寄存器 数据输入寄存器 数据输出寄存器 I/O设备的类型按使用特性分类：存储设备、I/O设备 按传输速率分类：低速设备（键盘、鼠标）、中速设备（打印机）、高速设备（磁带、磁盘） 低速设备一般被设置成独占设备 按信息交换的单位分类：块设备、字符设备 按设备的共享属性分类：独占设备、共享设备 独占设备应该采用静态分配策略 13.2 I/O控制方式I/O的标准协议 操作系统读取状态寄存器，等待设备进入可以接收命令的就绪状态（轮询） 操作系统下发数据到数据寄存器 操作系统将命令写入命令寄存器 操作系统再次轮询设备，等待并判断设备是否执行完命令 轮询又称“可编程I/O” 由用户程序自己控制的I/O控制方式 流程：由设备定时发出询问，询问设备是否忙，忙则进程进入忙等，不忙则进行I/O 特点：容易实现，但效率偏低；CPU会长期处于忙等状态。实际上基本不用。 中断CPU硬件有一根中断请求线IRL 流程： CPU执行完每条指令后，检测IRL 如检测到信号，CPU保存当前状态，并跳转到中断处理程序 执行中断处理程序 执行完毕，清除中断，返回 中断（interrupt）和陷入（trap） 中断是CPU对I/O设备发来的中断信号的一种响应 陷入是指CPU内部事件所引起的中断（除以0等） 中断向量表 中断向量表存放每个设备的中断处理程序的入口地址 中断处理程序 检测是否有未响应的中断信号 保护被终端进程的CPU环境 转入相应的设备处理程序 中断处理 恢复CPU的现场并退出中断 DMA直接内存访问（Direct Memory Access） 绕过CPU，直接在I/O设备和内存之间传输数据。数据传输完成后，DMA控制器抛出一个中断来告诉操作系统自己已经完成数据传输 13.3 I/O内核子系统内核提供与I/O相关的许多服务，如调度、缓冲、缓存、假脱机等，建立在硬件和设备驱动程序的基础设施之上，还保护自己免受错误进程和恶意用户的危害 I/O改善计算机效率的一个方法是进行I/O调度，另一个方法是使用主存或磁盘上的存储空间的技术，如缓冲、高速缓存、假脱机等 I/O调度操作系统开发人员通过为每个设备维护一个请求队列来实现调度 缓冲（Buffering）缓冲区是一个存储区域，可以由专门的硬件组成；更多的是利用内存 缓冲的用途： 解决设备之间的速度差异 协调传输数据大小不一样的设备 支持应用程序I/O的复制语义 高速缓存（Cache）假脱机（SPOOLing）为了缓和CPU的高速性与I/O设备的低速性之间的矛盾而引入了脱机输入、脱机输出技术 原理：程序模拟脱机输入，把低速I/O设备上的数据传送到高速磁盘上；另一程序模拟脱机输出，把数据从磁盘传送到低速输出设备 输入进程模拟脱机输入时的外围控制机，将用户要求的数据从输入设备通过输入缓冲区再送入输入井，当CPU需要输入数据时，直接从输入井读入内存。输出同理。 特点：提高了I/O的速度；将独占设备改造为共享设备，实现了虚拟设备的功能 错误处理Tips 一个设备控制器可以连接多个设备 需要CPU干预最少的I/O控制方式是SPOOLING 使用SPOOLing系统的目的是为了提高I/O设备的使用效率 操作系统使用的缓冲技术，多数通过使用内存来实现 低速设备一般被设置成独占设备 独占设备应该采用静态分配策略 基于中断机制的I/O方式是一种同步的I/O方式（错误） ‏使用内存映射I/O的设备是显卡 由用户程序自己控制的I/O控制方式是轮询","link":"/2022/08/24/OS-Kaoyan/"},{"title":"最短路问题","text":"いつの日かdistanceも 抱きしめられるようになれるよ 问题分类单源最短路 从一个点到其他所有点的最短距离 不存在负权边 朴素Dijkstra算法 $O(n^2)$ 堆优化版的Dijkstra算法 $O(m\\log n)$ 存在负权边 Bellman-Ford算法 $O(nm)$ SPFA $一般O(m)，最坏O(nm)$ 多源汇最短路 有多个起点到不同点的最短距离 Floyd算法 $O(n^3)$ 模板Dijkstra算法适用于无负权边的图。可以有重边或自环。 算法思想 定义一个distance[]数组，distance[i]表示从起点到点i的距离。 将distance[]初始化，distance[1] = 0，表示起点到自己的距离为0。其余全部赋值为INF，表示还未找到最短距离。 定义一个集合st[]，每当找到一个点i到起点的最短路时，st[i] = true，将点i加入集合中。 迭代n次，每次搜索所有未加入集合中的点，从中找到distance最小的那个点t，将其加入集合中。然后更新distance[]，判断t加入路径之后经过t的新路径距离是否小于原路径。 朴素DijkstraDijkstra求最短路 I不使用任何数据结构进行维护，时间复杂度为$O(n^2)$，适用于稠密图。 实现123456789101112131415161718192021222324252627282930313233343536const int N = 510;int n, m;int g[N][N]; // 邻接矩阵存图int dist[N];bool st[N];int dijkstra(){ memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; n; i++) { int t = -1; for (int j = 1; j &lt;= n; j++) { if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) { t = j; } } st[t] = true; for (int j = 1; j &lt;= n; j++) { dist[j] = min(dist[j], dist[t] + g[t][j]); } } if (dist[n] == 0x3f3f3f3f) return -1; else return dist[n];} 堆优化的DijkstraDijkstra求最短路 II用堆存储所有点到起点的距离，这样每次找distance最小的那个点t的时间复杂度就是$O(1)$ ，而更新其他点的距离的操作变为$O(\\log n)$。本题中点和边数均为$10^5$，所以是稀疏图，用邻接表来存。 实现123456789101112131415161718192021222324252627282930313233343536373839typedef pair&lt;int, int&gt; PII;const int N = 150010;int h[N], e[N], ne[N], w[N], idx;int dist[N];bool st[N];int n, m;int dijkstra(){ memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.first, distance = t.second; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n];} Bellman-Ford算法有边数限制的最短路Bellman-Ford 算法是一种基于松弛（relax）操作的最短路算法，可以求出有负权的图的最短路，并可以对最短路不存在的情况进行判断。适用于有边数限制、有负权边的图。可以用来判断是否有负环。 通常来说，SPFA在各方面都比Bellman-Ford更优。但是如果题中限制了最短路的边数，则只能用Bellman-Ford。 算法思想非常的简单松弛：对于边$(u, v)$，松弛操作对应下面的式子$dist(v)=\\min(dist(v),dist(u)+w(u,v)$也就是如果从源点直接到$v$点的距离大于从源点先到$u$ 再到 $v$，则将最短路从源-&gt;v 更新为 源-&gt;u-&gt;v 对于有 $n$ 个点， $m$ 条边的图，进行 $n - 1$ 次迭代，每次迭代对所有边进行松弛。直到没有边能够松弛了，算法结束。如果松弛次数大于 $n-1$ ，说明图中有负环（因为一共只有 $n$ 个点，任意两个点之间最多有 $n-1$ 条边）。所以，如果我们想知道是否存在源点到目标点的边数最大为 $k$ 的最短路径，则只要进行 $k$ 次迭代。伪代码如下： 123for n for 所有边 a,b,w dist[b] = min(dist[b],back[a] + w) 实现123456789101112131415161718192021222324const int N = 510, M = 10010;int n, m, k;int dist[N];int back[N]; // 因为每次迭代都会松弛所有边，可能会导致串联，所以使用一个备份，其中存的是上一次迭代的diststruct { int a, b, w;}edges[M];void bellman_ford(){ memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; k; i++) { memcpy(back, dist, sizeof dist); for (int j = 0; j &lt; m; j++) { int a = edges[j].a, b = edges[j].b, w = edges[j].w; dist[b] = min(dist[b], back[a] + w); } }} SPFAspfa求最短路spfa判断负环 算法思想spfa是队列优化后的Bellman-Ford。在Bellman-Ford算法中，每一次迭代都会搜索所有的边，判断是否需要松弛。然而很显然，只有在上一轮迭代中松驰过的边才有可能需要松弛，而其他的边在上一轮是没有发生改变的。所以我们使用一个队列来维护那些可能需要松弛的结点，就不需要每次都访问所有点了。 实现1234567891011121314151617181920212223242526272829303132333435363738const int N = 100010;int n, m;int h[N], e[N], ne[N], w[N], idx;int dist[N];bool st[N];int spfa(){ memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue&lt;int&gt; q; q.push(1); st[1] = true; // st用来标记某个点是否进入队列 while (q.size()) { int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) { q.push(j); st[j] = true; } } } } return dist[n];} Floyd算法Floyd求最短路适用于任何图，可以有负权边。但不能有负环。 算法思想基于高深的动态规划。首先图要用邻接矩阵来存。定义一个数组 g[k][x][y] ，表示 $x$ 只经过 $1, 2 \\dots k$ 到 $y$ 的最短距离。所以 g[n][x][y] 就是 $x$ 到 $y$ 的最短距离。所以进行 $n$ 次迭代，每次 g[k][x][y] = min(g[k - 1][x][y], g[k - 1][x][k] + g[k - 1][k][y] 。而实际上，数组的第一维对结果无影响，所以可以省略。 实现1234567void floyd(){ for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);}","link":"/2022/03/09/Shortest-path/"},{"title":"Trie","text":"介绍trie，又称前缀树或字典树，是一种有序树，用来保存关联数组，其中的键通常是字符串。是一种高效的存储和查找字符串的数据结构。 如图所示，如果我想要查找是否有 cat 这个单词，只需要沿着 c -&gt; a -&gt; t 这条路径走。如果路径上有某个结点不存在，则说明不存在这个单词。另外，如果存在某个单词，我们也需要给这个单词最后的那个结点打上一个标记，表示从根节点走到这个结点的路径是一个单词。 例题题目描述维护一个字符串集合，支持两种操作： I x 向集合中插入一个字符串 $x$；Q x 询问一个字符串在集合中出现了多少次。共有 $N$ 个操作，输入的字符串总长度不超过 $10^5$，字符串仅包含小写英文字母。 输入样例1234565I abcQ abcQ abI abQ ab 输出样例123101 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;const int N = 100010;int son[N][26], cnt[N], idx;char str[N];// son[N]用来存树里的结点 ---&gt; 静态链表// son[N][26]用来表示结点的键值（26个小写字母）// cnt[N]用来统计单词出现次数// idx和静态链表中的idx一样，用来表示当前操作的是第几个结点void insert(char* str) { int p = 0; // 从根节点开始 for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; // 将字母映射成整数 if (!son[p][u]) son[p][u] = ++idx; // 如果结点不存在，则创造这个结点，让它指向下一个操作的结点 p = son[p][u]; } // 循环结束后，p就是这个单词的最后一个字母所在结点 cnt[p]++; // 单词出现次数}int query(char* str) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; if (!son[p][u]) return 0; // 如果想要查找的路径上有结点不存在，说明该单词不存在 p = son[p][u]; } return cnt[p];}int main() { int n; scanf(&quot;%d&quot;, &amp;n); while (n--) { char op; scanf(&quot; %c&quot;, &amp;op); // 坑：scanf在读入单个字符时不会过滤回车，例如在读入一个'a'之后，输入回车的话， // 回车会被存放在缓存区中，下一次scanf会自动把回车读入 // 解决办法：在%前加一个空格，会告诉scanf忽略前面的空行，而等待第一个非空行元素读入其中。 if (op == 'I') { scanf(&quot;%s&quot;, str); insert(str); } else { scanf(&quot;%s&quot;, str); printf(&quot;%d\\n&quot;, query(str)); } } return 0;}","link":"/2022/01/28/Trie/"},{"title":"字符串哈希","text":"介绍利用哈希的思想，实现快速判断两个字符串是否相同。 例题题目描述给定一个长度为 $n$ 的字符串，再给定 $m$ 个询问，每个询问包含四个整数 $l_1,r_1,l_2,r_2$，请你判断 $l_1, r_1$和 $l_2, r_2$ 这两个区间所包含的字符串子串是否完全相同。 字符串中只包含大小写英文字母和数字。 输入格式第一行包含整数 $n$ 和 $m$，表示字符串长度和询问次数。 第二行包含一个长度为 $n$ 的字符串，字符串中只包含大小写英文字母和数字。 接下来 $m$ 行，每行包含四个整数 $l_1,r_1,l_2,r_2$，表示一次询问所涉及的两个区间。 注意，字符串的位置从 $1$ 开始编号。 输出格式对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 Yes，否则输出 No。 每个结果占一行。 输入样例123458 3aabbaabb1 3 5 71 3 6 81 2 1 2 输出样例123YesNoYes 题解根据哈希的思想，我们选择一个类似进制转换的哈希函数。 如 aabb 这个字符串，其映射值为：$$(a * P^0+a * P^1+b * P^3+b * P^4)\\bmod Q$$本题里，我们将其从前往后按照前缀的方式存到 h[] 中，那么有： 1234h[1] = 'a' 的映射值h[2] = 'aa' 的映射值h[3] = 'aab' 的映射值h[4] = 'aabb' 的映射值 而映射时有几个注意点： $P$ 通常取 $133$ 或 $13331$ ，经验证明这样很少发生碰撞。 字母不能映射成 $0$ 否则会发生冲突 ：如果a -&gt; 0 那么 aa -&gt; 0 我们要想知道 $[l_1, r_1]$ 和 $[l_2, r_2]$ 是否相同，那么只要判断二者的哈希值是否相等。那么如何判断二者是否相等呢？ 问题就转化为：已知 h[l1], h[r1] 的值，如何求得 $[l_1, r_1]$ 这一段的哈希值？ 答案是：将 h[l1] 左移 $r-l+1$ 位，它与 h[r1] 的差值就是我们想要求的。如 aa 的哈希值右移两位就是 aa00 ，然后用 aabb 的哈希值减去 aa00 ，就得到 bb 的哈希值。代码如下： h[r] - h [l - 1] * p[r - l + 1] 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned long long ULL;const int N = 100010, P = 131;int n, m;ULL h[N], p[N];char str[N];ULL get(int l, int r) { return h[r] - h [l - 1] * p[r - l + 1];}int main() { scanf(&quot;%d%d%s&quot;, &amp;n, &amp;m, str + 1); // 从 str[1]开始存 p[0] = 1; // 预处理h[N]和p[N] for (int i = 1; i &lt;= N; i ++) { p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + str[i]; } while (m--) { int l1, r1, l2, r2; scanf(&quot;%d%d%d%d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2); if (get(l1, r1) == get(l2, r2)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); } return 0;}","link":"/2022/02/25/StringHashing/"},{"title":"By making a song can I keep the memory?","text":"我的2021年终总结 随着考研告一段落，2021年就这样悄无声息地过去了。而我也在周期性地陷入迷茫，像死鱼一样躺了几天之后，终于想起已经时至年尾，该写些什么来虚假地总结和纪念一下这过去的平凡又乏味的一年了。 尽管我每年都会写年终总结，但每次都不知从何下笔，从取标题开始就被难倒。毕竟只是一个死宅大学生而已，一年里又能发生些什么值得写的事呢？ 姑且容我流水账般回忆一下这一年里发生过的，给我留下印象的事吧。 烟花三月，终于下了一趟扬州。第一次尝试青旅，运气很好，遇见了能够一起吃饭观光的小学弟。算是我的社交恐惧症治愈之路上的第一个疗程吧。 五月和老同学们去了无锡和苏州。有点可惜的是，去的时候赶上节假日，所以到处都是人山人海，以至于没有去成苏州博物馆。以后还要找个时间去一次。 之后就是颓废的暑假。七月在家浪费了一个月，依然是日复一日地做着我浪费生命的老一套。八月开始有了些危机感，复习进度捡起来一些。 回学校之后的时间就好像按下了加速键。每天重复着早起去图书馆，晚上十一点回宿舍的日子。还没等我反应过来，手机上显示的时间就从十月变成了十一月、十二月。 虽然我对于考研并不是抱着玩玩的心态去应付的，但也不到「如果考不上这辈子就完了」的程度。所以尽管我没有哪一天是没去学习的，但没有尽全力这一点我也是心知肚明。可能对我来说，所谓的尽全力根本不存在吧。 所以上考场时的状态不佳也是我自食恶果。但是即使自我感觉再差，过去的事也已经过去，这里就不谈了吧。 今年网易云的年终报告，我听得最多的歌是《Reflexion, allegretto, you》，听了七百多遍。我今年最庆幸的事就是二刷了《利兹与青鸟》，发现了三年前第一次看时没发现的美好。一周内看了四遍，还买了BD，让我找回了当年看君名时的热情。 ED我也听了很多遍。当前奏的吉他声响起时，我的脑海里总是浮现出飘飞的水蓝色裙摆、游曳的夏日光斑和摇摇欲坠的未来。 上大学之后，体感时间流逝得越来越快。回看前几年的年终总结，焦虑和迷茫总是主题。而当下正处在转折点的我，依然在踌躇满志和混吃等死的叠加态中撕扯着，迎来了2022年。 Feeling so anxious each spring time We are flapping about like plastic bags How would I sing? Golden reflections of our life In the afternoon sunlight Chocolates melt in my pocket By making a song can I keep the memory? I just came to love it now","link":"/2022/01/02/2021Summary/"},{"title":"死、宝石、夕阳与春雪","text":"她边说边泛起一种焦灼感。然而，就像向别人描述死、宝石的闪光和夕阳的优美一样，这乃是最难的事情。 前言今天终于把三岛由纪夫的《春雪》读完了。 这是我读的第三本三岛。前两本是《金阁寺》和《假面的告白》。 《金阁寺》是高中的时候读的。读的是唐译本。一方面觉得文字极其精致，一方面也确实掉入了华丽辞藻编织出的陷阱里。 简而言之，没读懂，囫囵吞枣。这本薄薄的，被称作三岛的代表作的小说，在我脑海中留下的印象单薄却持久：那只屹立在金阁寺顶上，在时间和空间的永恒流动中岿然不动的黄金凤凰。 《假面的告白》是几个月前读的。读的是陈译本。这是三岛作为作家，所发表的第一部小说。文字的华美从这时就已经让人哑然。 这本自传性小说，也确实让我得以一窥这位伟大作家的真实。所有这本书的读者肯定都忘不了，那副《圣塞巴斯蒂安殉教图》。我也是从这时候才略微领会三岛对于「美」的追求。 健康、死亡。 这两者都是三岛所追求的美的一环。对于生者——从三岛自己就能看出来——他向往健硕的、威严的、如同太阳与铁的不可逆的肉体。但他更喜欢的，或者说，觉得更美的，则是这不可逆的、象征着生的肉体被死亡所吞噬。 日本人所谓的「物哀」，指的是对于萧条、衰败的景物产生的哀伤之情。而三岛将这种感情投射到人，发展出了独属于他的美学。 所以我在读之前也很容易地猜到了，《春雪》的结局必然是悲剧。 三岛的美学 没有什么东西比已达成的恋情更加不值一提了。 清显和聪子明明两情相悦，为何最后偏偏沦落到一人剃度，一人病逝？ 且抛开三岛的「暴烈」不谈。 清显年方十七八，面对比他大两岁的青梅竹马聪子，在男性和新晋贵族身份的两道枷锁的禁锢下，当然渴望在恋情的角力中掌握主导权。他跟聪子的几次拉扯，虽不理智，但是合理。二人的感情在共赏春雪的时刻达到高潮，这是三岛为读者创造的「美」。 塞林格说：爱是想触碰又收回手。 而清显显然不这样认为。 在聪子和王爷订下婚约后，他才发觉「我热恋着聪子」。在镰仓的海边，在那名为「不可为」的夜幕的包裹之下，三岛将他的美学之幕揭开——「为所不可为」。 这份相互折磨的爱，越是危险，越让人感到欲罢不能。于清显，于聪子，于读者，于三岛，都是这样。 所有人都享受着这份漆黑夜色中的耳鬓厮磨，尽管天空即将破晓、美好面临毁灭也无法收手。因为当这份世俗的美被毁灭，原地重新诞生的将是永恒的美，也是三岛一生所追求的美——「死亡」。 瞎扯《春雪》的阅读体验，实在是我从来都没有经历过的。 首先提一下，这次读的是文洁若的译本。感觉比前两次好读些。 花了一个多月读了三分之二，昨天和今天一口气读完了最后三分之一。在读到最后时，内心也被一种巨大且不可名状的悲伤所填满。以至于读完之后还久久不能平静，整个下午都无心做其他事。 读《春雪》之前，我对三岛的认知是「用华丽的文字包裹简单的故事」。 但是现在看来并非如此，在华丽的文字之下，包裹的是同样华丽的故事。 没有一处描写是无用的，登场的众多人物，每个人的形象都跃然纸上。 借明治维新而成为新兴贵族的松枝家，色厉内荏的松枝侯爵与蹴鞠世家，吃了二十七代皇粮却逐渐衰微的绫仓伯爵。这二人的对手戏，如果深挖的话，想必也是可以对日本贵族制有更加清晰的认识的吧。可惜我学疏才浅，做不到了。 从鹿儿岛来的学伴饭沼、服侍绫仓家几十年的老妪蓼科，两人分别服侍着故事的两位主角，却抱着完全不同的态度。饭沼怒清显不争，无比怀念旧时代，而蓼科则是无条件服从聪子，实质却在谋划十几年的复仇。二人对比，深层次剖析的话，也会很有趣吧。 … 可细细品味的地方太多了。等我把丰饶之海四部读完，多了解一些背景知识，一定再读一遍。 摘抄 清显从海潮的奔腾和漫长时间的流逝中，突然察觉到自己不久也会走入老境，而泛起一阵子窒息的感觉。他从来没有想过要获得什么老年人的智慧。他想的只是怎样才能在年轻的时候就溘然死去，而且尽可能不感觉痛苦。宛若一件华丽绸和服随便脱下来扔在桌子上，不知不觉又滑落在昏暗的地板上那么优雅。 三岛对于死亡的描写太美了。 此刻，忽然觉得天光暗了下来，一群飞鸟从天涯海角涌过来，叫声四起，直逼头顶，清显就举枪勾动了扳机。这不单单是无情的射击，而是心中充满不可言状的愤怒和悲哀，与其说是对着群鸟，莫如说是向着太空那只巨大的蓝眼开的枪。 群鸟一齐被打了下来，眼看着一阵带血的龙卷风呐喊着把天和地连接起来了。所以这么说，那是因为无数的鸟儿嘶鸣着，滴着鲜血，密密麻麻地聚集成一根粗大的望不见顶端的柱子，向着地面的一点俯冲下来，就仿佛是水量极大的瀑布带着吼声和血色，没完没了地从天上落了下来。看上去，确实酷似那连续不动的龙卷风。 这段读起来超有画面感。 恋爱中的男人，他的心是容纳不下恋爱之外的任何事物的。甚至对别人的悲痛，也都丧失了同情心。 两个小伙子心里所拥抱的两个截然不同的世界的影子，将其尖端突出地显示在煤油灯那黄雾般的光圈中。一个因恋爱而卧病，一个为坚固的现实而学习。清显恍如在梦境里，他被海藻缠住了脚，在混沌的爱之海中泅水；本多则向往着牢固地建立在地面上的井井有条的理智的建筑物。 情感和理智，毁灭和秩序。","link":"/2021/06/12/harunoyuki/"},{"title":"ただ力の抜けた光る方へ","text":"我的22考研记录 今天是2021年8月1日。从三月份开始准备，到现在考研进程也已过半。 想着不妨写些东西，一是对前半段的复盘，二是督促自己，三是给以后留个回忆。 择校之前一直无法定下目标院校，在各大高校之间徘徊。一开始是北邮、东南，后来是华科、武大、浙大。不过其实我不太想去北邮，只是因为我校考北邮上岸的很多，所以我下意识觉得应该比较好考而已。 上大学前，我对大学的幻想大多来自汪曾祺先生在其散文中介绍的西南联大。 我想象中的大学，应该更具人文气息。而根据我本科在理工科大学经历的这三年来看，其显然过于冷峻了。 大学之大，不在其面积，而在其包容。学科建设全面一些的大学，我认为是会更加丰富且多元一些的。 所以我很想读一读综合类大学，这是其一。 其二就是，我很想去上海。也不知道哪里来的上海情结，反正就是特别有好感。 说来惭愧，高三的时候很想考华师。当时还跟好朋友约好了，她考交大，我考华师，到时候就是邻居了。 结果两个人都没考上，自然也没做成邻居。 而三年过去了，我还是很想去上海。我想去看各种艺术展，想去梅奔看演唱会，想去cp，想参加上影节。 还是有些985情结。而交大和复旦，我感觉高攀不起。于是华师显然是最好的选择，计算机水平不错，考的人又少。 何况还有意外之喜——华师考的是数二英二。英语倒是无所谓，但是之前一直按照数一备考的我突然感觉松了一口气。数二比数一少了概率论、级数、线面积分之类又多又难的内容，对于我这种被数学按在地上摩擦了一辈子的数学废物来说简直如同天降福音。 「就它了，」在华师官网上看到「数学二」三个字时，我心想，「不要太适合我。」 那么定下目标院校的我，有没有做出相应的努力，好好学习呢？ 呵呵。 于是我浪费了整个七月的时间。 规划八月 现在看来，其实放暑假之前，我在学校里的学习状态还算好，进度也还可以。但是一到暑假就一如往常地陷入了颓废的境地。 既然七月已经被浪费了，那么八月就要加倍努力追上来。每天学习10小时吧。 为了不再只是嘴上说说，姑且列个计划表吧，感觉这样比较有用。 到八月底，应该完成的： 高数强化 计组一轮（8/15） 操作系统一轮（8/23） 数据结构一轮（8/30） 英语刷完16年以前的阅读真题（8/27） 政治每天一小时以内，学到哪算哪 同时也该准备一下九月的PAT了。（战略性放弃，先管初试吧） 今天就先写到这，之后视情况再更新。 九月 既然开学了，能够复习的时间肯定是要少于八月的。 而且返校的那天也要浪费一天。 到九月底，应该完成的： 线代强化 高数880 计网二轮 计组二轮 操作系统二轮 数据结构二轮 英语阅读二刷（优先级低） 时间轴8/15 更新： 今天把计组过完了。打算接下来再按章总结，同时开始复习OS。 英语做到了14年。13年的阅读只错了一个，感觉还不错。 高数目前到一元函数积分学。感觉应该增加做题的时间，减少看视频的时间。 这一周由于胃痛的缘故，学习时间比上周大大减少…上周好不容易对自己有了点信心，又消磨殆尽了。 新的一周，希望专注力能再提高一些，希望胃痛能缓和。 8/23 更新： 操作系统一轮结束。 果然还是比计组友好不少啊。我甚至还做了笔记，居然才花了计组一半的时间。 今天看着操作系统只剩下最后一节，突然就开始提不起劲，以至于下午基本都在摸鱼，晚上才把这一节看完。 明天开始数据结构。之前已经看到第四章了，所以应该两三天就能看完。然后进入二轮，以及增加数学的时间。 高数到常微分方程了。 关于自己老是犯低级错误，算错、看错符号之类的，我也许找到原因了。 还是一直以来困扰着我的问题。大脑活动停不下来，永远被无关紧要的事情占据。 就像进程调度的SJF算法，一直在处理最短的任务，把其他的进程都饿死了。 而我也是，难以把注意力放到眼前重要的事情上面。 比如读书时，思绪读着读着就飞走了，从获取信息变成了只是用视线扫过文字而已。 比如做题时，式子化简之后抄下来，大脑直接放弃思考要不要变号，就原封不动地抄下来。 我不知道这种问题是从何而来，也不知道怎么做才能改善。想来也许是小时候，一边吃饭一边看电视，过早地让自己一心二用，导致没有培养起来专心的能力。以及微博之类的碎片信息流，大概也是一部分原因。 所以最近在尝试冥想正念，让自己什么也不想，排除掉在脑海中过于活跃的杂乱信息。以及在碎片时间尽量不用手机，减少无用信息的摄入。 还有英语，这个就很舒适了。 13年错1个，14年错2个，15年错1个。不知道是我变强了还是阅读变简单了，我现在对英语的信心是前所未有的强。做完阅读之后再尝试做几篇完型吧，做得好的话，说不定真能上85。 不过有点可惜，没有一年是全对的。16年的还没做，不过听说这年比较难。 我也许到极限了。 我是指睡眠时间。 这段时间以来每天睡6小时，中午睡半小时左右。 而我昨天尝试着再缩短一下这个时间。定了5小时的闹钟，但是完全起不来，还是在床上多躺了一个小时。 6小时的睡眠时间是我在高中就尝试过的。当时从哪看到说，人的睡眠周期是一个半小时，睡眠最好是这个时间的倍数。事实证明，我睡6小时确实比睡6个半~7小时精神点。 所以打算今天试试4个半小时睡眠。如果失败的话，那就证明我的极限就是6小时了。 哇，4个半小时，听起来好吓人。真的能做到吗，不会猝死吧？ 8/30 更新： 时间终于来到了八月底。 各项任务也是ギリギリ完成了，还算不错。 今天是开学第一天。不知不觉就大四了，完全没有实感。课虽然不是很多，但总归还是会有影响，只希望影响不要太大。 数学到二重积分了，也就是高数的最后一章。接下来就边刷880边线代。线代感觉没时间再看视频了，直接看书做题吧。进度太慢了，之后要增加学数学的时间。 说是这么说，但还是不愿意自己做题。碰到难点的题就不太想思考。也许是对数学的恐惧积重难返吧。 英语。前几天把16年的阅读刷完了，错了两个。就很遗憾，一次全对都没有，多少有点气馁了。然后把完型给写了，居然全对。不过也不知道是这年阅读比较简单还是我真的挺强。总之这下也是给了我不少信心。如果今年阅读简单点的话，也许85还是挺稳的？（我就随便想想） 接下来打算把英语先放一段时间，挪出时间给数学和408。等到十月再开始作文。 感觉即使看了很多方法论，我做题还是靠语感。读不明白的长难句就多读几遍，一般都能读懂。所以二刷阅读真的有必要吗？ 数据结构。其实早该完成的，毕竟只剩下三章，一天一章完全没有难度。但是还是太摸了，这几天学习状态都不怎么好，所以拖到了现在。 这样的话，408总算是一刷结束了。这一套学下来，果然还是DS最友好，我一刷的正确率也最高。然后计网和OS差不多吧，计组毫无疑问的最难了。 政治。马原部分的视频看完了，1000题也做了些。之后的部分就不看视频了，直接做题吧。纸质书 + Anki每天刷。 有些焦虑。看到其他人408都开始刷真题了，数学也在二刷。随着剩下的时间一天天缩短，我产生「如果没考上怎么办」的想法的频率也高了起来。这种时候也只能强行让自己不去想了。毕竟路是自己选的，总该好好走完。高考没能达成的目标，过了四年还没法达成的话，也太没用了吧。 对了，我果然做不到一天只睡四个半小时。 1/1 更新： 本来还以为能多记一点的，结果开学后根本没时间。 考研就这样悄无声息地结束了。 虽然自觉考得很差，但是已经结束了，那就随它去吧。不想再想了，这种经历不想再有第二次了。 出成绩了再来更新。 2/23 更新： 败了，彻彻底底地败了。 考得比想象中还差。 但是因为已经做好心理准备了，所以看到成绩的那一刻也没什么波动。 这也说明我很清楚地知道自己没有尽力吧。 基础从一开始就没打好，心情浮躁，眼高手低，懒得动手，懒得思考。 以至于数学卷子发下来之后，大脑一片空白。下午的专业课，自以为已经掌握得很好了，但做过三四次的题依然不会。 一开始下定决心考研，除了想读书以外，还希望借此机会改掉自己无法专注、喜欢逃避现实的毛病。 但是很可惜，并没有改掉。我依然是自己厌恶的那个自己。 啊，这种话我已经说过多少次了呢？每一次都痛定思痛，每一次都死不悔改。 现在想来，也许这毛病是从小就有的吧。但是小学和初中还算学有余力，所以没有暴露出来。高中开始就比较明显了。上大学之后越来越明显，也许我已经丧失了专注学习的能力。 但我还是想再上几年学。 所以再来一年吧。","link":"/2021/08/01/kaoyan/"},{"title":"网易云音乐上传歌词&amp;翻译","text":"初めから チグハグだったけど 前言前几天听推荐的时候听到了しおんあい的「私の街」这首歌。 嗯，感觉旋律不错。想看看歌词，点开一看，居然没有翻译！ 那就自己来吧。毕竟现在没歌词/翻译的歌还挺少见的，难得有机会，那我当然是跃跃欲试。 作为一个翻译过几万字（虽然也不是什么严肃内容）的翻译爱好者，一篇歌词而已，那不是信手拈来？ 抱着这种心态，飞快地翻译完并提交了。 然后就没过审核。 可恶啊 就这样，我的歌词翻译之路走到了尽头。 本文完。（ 过了两天，我发现しおんあい桑发新歌了。 这首也挺好听的 所以我又手痒了。 歌词部分获取歌词本文以「Tallest Liar」这首歌为例。 首先用Google搜索「Tallest Liar しおんあい」。 一般来说，如果这首歌出了一段时间，那都是能搜到现成的歌词的。 比如J-Lyric，歌ネット这些网站，一般都会有歌词。这里推荐J-Lyric，因为歌ネット不让复制。 但是这首歌比较新，当时才刚出两天。没有现成的歌词。 「那就自己动手！考验听力的时候到了！」 你以为我会这么说吗？怎么可能，我听中文歌都不一定能听懂歌词的。 于是求助万能的油管。 这首歌是有PV的，而PV里是有歌词的。 那就抄下来呗。 新建txt，一句一行，保存。 接下来就是让歌词滚动起来了。 打轴试了几个打轴工具，我比较推荐灯里的歌词滚动姬 它的一个优点是：加载音频时可以用外链，而不一定要上传本地文件。（没有网易云会员我也下载不下来啊） 使用方法就不详细介绍了，反正把刚刚的txt文件传上去，打就完事了。 打完轴之后的成品如下： 上传打开网易云网页端，然后点这个上传歌词。 翻译部分网易云官方推荐上传双语歌词，原文和翻译在同一行，中间用空格隔开。 可以。 但千万别。 我试了，结果就是这样。 哦，行吧。 那就先提交歌词呗。 这次审核还挺快的，第二天就过了。 然后上传翻译，审核更快了，几个小时就过了。 最终效果 总结就，看见自己的翻译还挺有成就感的。 哦，顺便说一下，网易云的审核人员大概是既不懂日文，也不懂中文吧。 这种垃圾翻译都给过","link":"/2021/06/10/netease-music/"},{"title":"Can we play a love song","text":"長い冬が終わる瞬間 笑顔で迎えたいから 我终于决定好好写博客了。 其实早就想自己搭个博客，来抒发自己无处安放的表达欲。而我也确实曾经用Hexo和GitHub搭过一个，但是由于惯例的三分钟热度，搭好之后就无限搁置了。 而这次的念头来自昨天，无意中看到了别人的博客。而我也确实从他的文章中感觉到，这是个有趣的人。 不同于音乐和影像，文字是有其独特魅力的。在自我表达方面，文字并不弱于任何一种媒介。而文字的门槛，也是最低的。不需要懂乐理，不需要懂光影和构图，只要接受过正常教育的人，多少能扯个几句话出来。 以前用过没加好友的小号的QQ空间写日志来着，其实还挺顺手，毕竟只是写字而已，也不需要什么花里胡哨的功能。后来用Notion，确实好看点，还支持Markdown，写起来也舒服。但是这两个都有个问题，那就是没法给别人看。而且身为程序员没个博客像话吗 其实也不太想给别人看。毕竟我们资深社恐，最擅长的就是把所有话都憋在心里。 但是我不想再社恐了。 前几天重看了一遍「四叠半神话大系」。上一次看还是高中吧，当时看只觉得森见牛逼，汤浅牛逼，这就是动画该有的表现方式！ 但是经过这一次二刷，我才更加体会到被困在四叠半大小的空间内的无所适从。 虽然人与人之间的A.T.Field坚不可摧，不同的人永远无法相互理解。但我还是想尝试一下，把真实的自己一点点、一点点地揭开。 所以心血来潮，昨天花了一晚上，买了域名，配置了Hexo。 这个博客以后应该会长期更新吧。目前的话，是有这么几个想法： 写写随笔 学习笔记 技术相关 那就先写到这了，希望这次不要再三分钟热度。 毕竟域名是花了钱的！","link":"/2021/06/09/Can-we-play-a-love-song/"}],"tags":[{"name":"日语","slug":"日语","link":"/tags/%E6%97%A5%E8%AF%AD/"},{"name":"想法","slug":"想法","link":"/tags/%E6%83%B3%E6%B3%95/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"考研","slug":"考研","link":"/tags/%E8%80%83%E7%A0%94/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"三岛由纪夫","slug":"三岛由纪夫","link":"/tags/%E4%B8%89%E5%B2%9B%E7%94%B1%E7%BA%AA%E5%A4%AB/"},{"name":"读后感","slug":"读后感","link":"/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"name":"音乐","slug":"音乐","link":"/tags/%E9%9F%B3%E4%B9%90/"}],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"读书","slug":"读书","link":"/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"分享","slug":"分享","link":"/categories/%E5%88%86%E4%BA%AB/"}]}