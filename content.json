{"pages":[{"title":"关于我","text":"懒得写，以后再说","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"2015年の荒川へ","text":"課程デザインと期末テストが終わり、日付は7月に変わった。 私にとって、7月は一年中最も悲しい時期である。 火であり、斜陽であり、別れでもある。 あれから一年が過ぎ、そろそろ何か書こうと思って、あなたの誕生日の今日で、私はこの文章を書くと決めた。 東京生活記録あれは2015年の夏。 ビリビリのホームページで「東京生活記録」というタイトルの動画が見つかった。あの動画のサムネイルは一つの変な人形だった。私は好奇心であの動画を再生した。 それが私とあなたの出合い。 一人の十五歳で二次元にハマっていた少年にとっては、「東京」という言葉の魅力が言うもなく大きい。 最初は東京に誘われ、西日暮里、荒川、スカイツリーなど見知らぬところに私は興味が持ち、毎回も動画を見る。 しかし、見れば見るほど、私は「本当に面白い人だなぁ」と思い始めた。 道に歩いながら、なんだかんだ喋るところが好きだった。 今も思い出せる、あなたが行った場所。 荒川沿い、自転車に乗っていた人々。 秋葉原、歩行者天国、ビッグマック。 東京大学、部活室。 スカイツリー、東京タワー。 そして、西日暮里、屋上。 あなたはギブリが好きで、私もあれからギブリが好きになった。 あなたは三島由紀夫が好きで、動画まで撮って紹介した。私もあれから三島を読み始めた。 私はあなたの振る舞いや、言葉や最高にかっこいいと思い、とても好きだった。 考えたら、今の私には、大体半分くらいはあなたに影響された。 人生の先生と言っても過言ではないね。 東京から南京へ「いつか皆さんは私の動画を見ないことが私にとって嬉しいです。」とあなたが言った。 高校生になってから、学業に勉強していた一方で、生活はなんとなく充実になったかもしれない、私はあなたの動画を見なくなった。 時間がどんどん進んでいく。 運命とか、縁起とか、私は信じない。 しかし、私は南京の大学に受けた。あなたの、故郷の大学。 こうして、私はあなたと繋がってる感じがした。 あなたが遊んだあの公園、あの階段、あのピンポンボール、いつか行ってみたいだね。 三島由紀夫と羊をめぐる冒険去年の春、あなたは一つの動画をアップした。 あの動画で、大好きな三島由紀夫を紹介し、三島さんの本の読む順番も推薦した。 その後、あなたはウェイボーで「江蘇のどこかで羊が見えるの？」と。 数日後、あなたは羊の群れの写真をアップした。 「いいなぁ、あなたは相変わらずかっこいい。」私はこう思った。 そして、7月5日。 2020年7月4日凌晨，叶修于南京结束了自己的生命 あなたの最後の一言。 その後、私は村上春樹の「羊をめぐる冒険」を読んだ。 その本の中で、「活到25岁，然后死掉」という言葉がある。 それが、あなたの思い込みなのか。 Guaranteed Don’t come closer or I’ll have to go あなたはきっと、色々考えたから、死に選ぶことが決まったのが私は信じている。 だから、私はその点を否定しない。それだけでなく、私は「おめでとう」と、苦難から逃げられたことに祝う。 ね、ヨウさん、航海に行きたいってあなたが言っただろう？ あれから一年、どう、あの広くて青い海の景色は？ 「行かないで」とか、「どうしてそんな事を」とか、私は言わない。 ただ時々、あなたのことが私は思い出し、悲しくなる。 後悔はもちろんしちゃうよ、そんなに近かったのに、あったこと一回もない。機会があったのに… ありがとう、たくさんの風景を私に見させて。 ありがとう、今の私を作り上げて。 ありがとう、叶修。","link":"/2021/07/05/2015-arakawa/"},{"title":"KMP Algotirhm","text":"IntroductionPresume we have a string S (length is m) and a pattern P (length is n) given as follow: 123index: 1 2 3 4 5 6 7 8 9 10 11 12S: a b a b a a b a a b a cP: a b a a b a c Now we want to find out is there a sub-string in S that matchs P exactly, which in this case is S[6:12]. That is what KMP algorithm does. Proper Prefix &amp; Proper SuffixBefore learning KMP, let’s make this clear first: what is proper prefix and proper suffix? Proper prefix: All the characters in a string, with one or more cut off the end. “S”, “Sn”, “Sna”, and “Snap” are all the proper prefixes of “Snape”. Proper suffix: All the characters in a string, with one or more cut off the beginning. “agrid”, “grid”, “rid”, “id”, and “d” are all proper suffixes of “Hagrid”. Partial Match TableThe key to KMP, it’s the Partial Match Table. Let’s see a example. 123char: | a | b | a | a | b | a | c |index: | 1 | 2 | 3 | 4 | 5 | 6 | 7 |value: | 0 | 0 | 1 | 1 | 2 | 3 | 0 | I see, there’s a table. But what do these values mean? The length of the longest proper prefix in the (sub)pattern that matches a proper suffix in the same (sub)pattern. For example, at index 1, we have a sub-string “a”. Its proper prefix and proper suffix are both null, so it’s value is 0. At index 2, we have a sub-string “ab”, with proper prefix “a”, and proper suffix “b”, and they do not match each other, there’s another 0. At index 3, we have a sub-string “aba”, with proper prefix “a” and “ab”, and proper suffix “a”, “ba”. We can see that they both contains “a”, which we call “match”. And the length of “a” is 1, so its value is 1. At index 4, we have a sub-string “abab”, proper prefix “a”, “ab”, “aba”, and proper suffix “a”, “aa”, “baa”. They both cotains “a”, which legth is 1, so there’s 1s in its value. etc. How to use Next ArrayThe next array is baes on the pattern. What is cofusing is that on the internet, most blogs and videos, next array and PMT table are just the same thing, but in Wangdao’s text book, the PMT is different from next array. Well, I’ll just make them be the same. In bruce force searching, we search the S one letter by one letter, like this: 12345678910First run:S: a b a b a a b a a b a cP: a b a a &lt;- mismatchSecond run:S: a b a b a a b a a b a cP: a &lt;- mismatchThird run:S: a b a b a a b a a b a cP: a b a a b a c &lt;- mismatch... Obviously, it is very slow, and its time complexity is $O(mn)$. Check this: 123456789First run:S: a b a |b| a a b a a b a cP: a b a |a| &lt;- mismatchSecond run:S: a b a b a a b a |a| b a cP: a b a a b a |c| &lt;- mismatchThird run:S: a b a b a a b a a b a cP: a b a a b a c &lt;- match! We can see that after mismatch, P is not going forward one letter by one letter., but jumps forward. And through the next array we can know where should P jump to. In the first run, P[4] and S[4] mismatch, and next[4 - 1] is 1 which means in the substring from P[0:4], the prefix and subfix of 1 letter are the same, so we move P and make it match the S with its proper prefix instead the subfix that mismatched. In the second run, P[7] and S[9] mismatch, and next[7 - 1] is 3, which means the first and the last 3 letters in the substring from P[0:7] are the same, in this case is “aba”. So we move P forward till the first 3 letters take place of the last 3 letters. etc. Construct a Next Array123456789101112void get_next(String P, int next[]) { int i = 1, j = 0; next[0] = 0; while(i &lt; P.length) { if(j==0 || P[i] == P[j]) { i++; j++; next[i] = j; } else { j = next[j - 1]; } }} PracticeAcwing: 831.KMP字符串 ReferencesYoutube: Abdul Bari - Knuth-Morris-Pratt KMP String Matching Algorithm Zhihu: 阮行止 - 如何更好地理解和掌握 KMP 算法? Blog: The Knuth-Morris-Pratt Algorithm in my own words","link":"/2021/07/08/KMP-Algotirhm/"},{"title":"从零开始的LeetCode题解","text":"始まりと終わりのプロローグ -Turning Point- 数组二分704. 二分查找35. 搜索插入位置 在数组中搜索元素的题通常都可以用二分。但要注意前提是该数组有序。 关于二分的边界条件：在二分的过程中，要保证每次分的区间都满足一开始的定义。而区间的定义一般有两种：左闭右闭 和 左闭右开。以左闭右闭为例： while(left &lt;= right) 必须是 &lt;= ，因为 left 和 right 是有可能相等的。 同理left 更新时是 mid + 1 ， right 更新时是 mid - 1 。 704. 二分查找1234567891011121314151617class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int n = nums.size(); int l = 0, r = n - 1; int mid = 0; while (l &lt;= r) { mid = (l + r) / 2; if (nums[mid] &gt; target) { r = mid - 1; } else if (nums[mid] &lt; target) { l = mid + 1; } else return mid; } return -1; }}; 双指针27. 移除元素977. 有序数组的平方 这类题往往用暴力需要两层 for 循环。如果在第一层循环时能够记录一些信息提供给第二层循环，则可以考虑使用双指针。 27. 移除元素12345678910111213class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int l = 0; int n = nums.size(); for (int r = 0; r &lt; n; r ++) { if (val != nums[r]) { nums[l++] = nums[r]; } } return r; }}; 但双指针不一定要是都向同一个方向运动，也可以是从数组两端向中间走。 977. 有序数组的平方12345678910111213141516171819202122class Solution {public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int k = n - 1; vector&lt;int&gt; ans(n, 0); int l = 0, r = n - 1; while (l != r) { int a = nums[l] * nums[l]; int b = nums[r] * nums[r]; if (a &gt;= b) { ans[k --] = a; l ++; } else { ans[k --] = b; r --; } } ans[0] = nums[l] * nums[l]; return ans; }}; 滑动窗口209. 长度最小的子数组 本质也是双指针。适用于求解数组中的子数组的情况。 209. 长度最小的子数组12345678910111213141516171819class Solution {public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int n = nums.size(); int l = 0, r = 0; int sum = 0, res = 0; int len = INT_MAX; // 窗口的长度 for (r = 0; r &lt; n; r ++) { sum += nums[r]; while (sum &gt;= target) { len = min(len, r - l + 1); sum -= nums[l ++]; } } if (len == INT_MAX) return 0; return len; }}; 链表链表定义1234567struct ListNode { int val; ListNode* next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {}}; 删除元素203. 移除链表元素 对链表进行删除时一定要注意判断链表是否为空，以及对头结点的特殊操作。另外这题用到了虚拟头结点，这样就不用针对头结点特判，也是一个实用的技巧。 203. 移除链表元素12345678910111213141516171819class Solution {public: ListNode* removeElements(ListNode* head, int val) { ListNode* dummyHead = new ListNode(0, head); // 新建一个虚拟头结点，next指向head ListNode* cur = dummyHead; while (cur-&gt;next != nullptr) { ListNode* tmp = cur-&gt;next; if (tmp-&gt;val == val) { cur-&gt;next = tmp-&gt;next; delete tmp; } else { cur = cur-&gt;next; } } head = dummyHead-&gt;next; delete dummyHead; return head; }}; 反转链表206. 反转链表 原本想的是定义一个新链表，然后把旧链表元素依次插到新表头。但是显然复杂度比较高。好的办法依然是双指针。从头开始直接改变 next 指针的朝向。 206. 反转链表123456789101112131415class Solution {public: ListNode* reverseList(ListNode* head) { ListNode* pre = nullptr; ListNode* cur = head; ListNode* tmp; while (cur) { tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; // pre 前进 cur = tmp; // cur 前进 } return pre; }}; 交换结点24. 两两交换链表中的节点 用到了前面提到的虚拟头结点。没啥难的，主要是要自己画图模拟一下。 24. 两两交换链表中的节点12345678910111213141516171819class Solution {public: ListNode* swapPairs(ListNode* head) { ListNode* dummyHead = new ListNode(0, head); ListNode* cur = dummyHead; while (cur-&gt;next != nullptr &amp;&amp; cur-&gt;next-&gt;next != nullptr) { ListNode* t = cur-&gt;next; ListNode* t1 = cur-&gt;next-&gt;next-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; cur-&gt;next-&gt;next = t; cur-&gt;next-&gt;next-&gt;next = t1; cur = cur-&gt;next-&gt;next; } // 注意不要直接返回head，因为被cur修改过了，head不再指向表头了 return dummyHead-&gt;next; }}; 链表中的双指针19.删除链表的倒数第 N 个结点 双指针的经典应用。fast 先移动 n 个位置，再让 slow 指针一起移动。虚拟头结点依然很方便，不用特别处理头结点。 19. 删除链表的倒数第 N 个结点123456789101112131415161718192021222324class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummyHead = new ListNode(0, head); ListNode* fast = dummyHead; ListNode* slow = dummyHead; while (n-- &amp;&amp; fast-&gt;next != nullptr) { fast = fast-&gt;next; } while (fast-&gt;next != nullptr) { fast = fast-&gt;next; slow = slow-&gt;next; } if (n == 1) { delete fast; return head; } ListNode* tmp = slow-&gt;next; slow-&gt;next = tmp-&gt;next; delete tmp; return dummyHead-&gt;next; }} 142. 环形链表 II 两种解法：1、数学题。详解看这里2、哈希表。遍历每个结点，并加入哈希表。遇到的第一个遍历过的结点就是环的入口。 142. 环形链表 II解法一 123456789101112131415161718192021class Solution {public: ListNode *detectCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while (fast != NULL &amp;&amp; fast-&gt;next != NULL) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (slow == fast) { ListNode* p = head; ListNode* t = fast; while (p != t) { p = p-&gt;next; t = t-&gt;next; } return p; } } return NULL; }}; 解法二 123456789101112class Solution {public: ListNode *detectCycle(ListNode *head) { unordered_set&lt;ListNode*&gt; visited; while(head != NULL) { if (visited.count(head)) return head; visited.insert(head); head = head-&gt;next; } return NULL; }}; 设计链表707. 设计链表 模拟，注意 index 从 0 开始。 class MyLinkedList { public: struct ListNode { int val; ListNode* next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} }; MyLinkedList() { dummyHead = new ListNode(0); size = 0; } int get(int index) { if (index &lt; 0 || index &gt; size - 1) return -1; ListNode* cur = dummyHead-&gt;next; while (index --) cur = cur-&gt;next; return cur-&gt;val; } void addAtHead(int val) { ListNode* node = new ListNode(val, dummyHead-&gt;next); dummyHead-&gt;next = node; size ++; } void addAtTail(int val) { ListNode* cur = dummyHead; while (cur-&gt;next != nullptr) { cur = cur-&gt;next; } ListNode* node = new ListNode(val); cur-&gt;next = node; size ++; } void addAtIndex(int index, int val) { if (index &gt; size) return; ListNode* cur = dummyHead; ListNode* node = new ListNode(val); while (index --) cur = cur-&gt;next; node-&gt;next = cur-&gt;next; cur-&gt;next = node; size ++; } void deleteAtIndex(int index) { if (index &lt; 0 || index &gt; size - 1) return; ListNode* cur = dummyHead; while (index --) cur = cur-&gt;next; ListNode* tmp = cur-&gt;next; cur-&gt;next = tmp-&gt;next; delete tmp; size --; } private: int size; ListNode* dummyHead; };","link":"/2022/04/05/LeetCode/"},{"title":"考研数据结构算法题笔记","text":"一寸先が闇なら、二寸先は明るい未来 链表单链表逆转双指针 不是交换结点中的元素，而是把指针逆转。定义两个指针pre和cur，每次操作先让cur的next指向前驱节点，再令pre前进到cur的位置，然后cur再前进一位，最后pre会前进到尾结点，这时指针就全部逆转了。 12345678910111213List Reverse (List L){ PtrToNode temp; // 保存cur的下一个节点 PtrToNode cur = L; PtrToNode pre = NULL; while (cur) { temp = cur -&gt; Next; cur -&gt; Next = pre; pre = cur; cur = temp; } return pre;} 链式表的按序号查找没啥好说的。 创建的指针cur一定要记得初始化cur = L，不然不知道指向哪。 123456789ElementType FindKth (List L, int K) { List cur = L; int i; for (i = 1; cur != NULL &amp;&amp; i &lt; K; i ++) { cur = cur -&gt; Next; } if (cur == NULL || i &gt; K) return ERROR; else return cur -&gt; Data;} 二叉树翻转二叉树第一眼就想到了层序遍历。不过递归也可以，而且代码更短，考试的时候还是写递归吧。 也是一个启示，树的题目基本上都可以往递归上面想。 层序遍历 12345678910111213141516171819class Solution {public: TreeNode* invertTree(TreeNode* root) { queue&lt;TreeNode*&gt; q; if (root != nullptr) q.push(root); while (!q.empty()) { int size = q.size(); for (int i = 0; i &lt; size; i ++) { TreeNode* cur = q.front(); q.pop(); swap(cur -&gt; left, cur -&gt; right); // 交换左右子树 // 入队的顺序和层序遍历相反。这里是先右孩子入队，再左孩子入队。 if (cur -&gt; right != nullptr) q.push(cur -&gt; right); if (cur -&gt; left != nullptr) q.push(cur -&gt; left); } } return root; }}; 递归 在前序遍历的基础上，把访问中间结点的操作改为交换左右子树。因为前序遍历是中左右的顺序，所以在原本访问中间结点的时候交换左右孩子，就能实现翻转二叉树。形象理解就是从上至下的递归。 后序遍历是左右中的顺序，所以同理，这里把swap放到后面，变成后序遍历也可以。形象理解就是从下至上的递归。 但是中序不行。有些结点会被翻转两遍。 1234567891011class Solution {public: TreeNode* invertTree(TreeNode* root) { if (root == nullptr) return root; // 终止条件 swap(root -&gt; left, root -&gt; right); // 每次递归，交换左右子树 invertTree(root -&gt; left); invertTree(root -&gt; right); // swap语句放到这个位置也可以 return root; }}; 在每个树行中找最大值这种涉及到“行”的，当然很自然就想到层序遍历。直接默写板子。 123456789101112131415161718192021class Solution {public: vector&lt;int&gt; largestValues(TreeNode* root) { queue&lt;TreeNode*&gt; q; if (root != nullptr) q.push(root); vector&lt;int&gt; res; while (!q.empty()) { int size = q.size(); int maxVal = INT_MIN; for (int i = 0; i &lt; size; i ++) { TreeNode* cur = q.front(); maxVal = max(cur -&gt; val, maxVal); q.pop(); if (cur -&gt; left != nullptr) q.push(cur -&gt; left); if (cur -&gt; right != nullptr) q.push(cur -&gt; right); } res.push_back(maxVal); } return res; }}; 对称二叉树递归，递归，还是递归！ 判断一棵二叉树是否对称，我们先把这棵树从根结点分开，看作左右两颗树。将左树的左边结点、右树的右边结点称为“外”，左树的右边结点和右树的左边结点称为“内”。如果两边的内外结点互相相等，则两棵树对称。 123456789101112131415161718192021class Solution {public: bool isSymmetric(TreeNode *root) { if (root == nullptr) // 如果是空树，对称 return true; return compare(root-&gt;left, root-&gt;right); // 从根结点的两颗子树开始由上至下判断 } bool compare(TreeNode *p, TreeNode *q) { if (!p &amp;&amp; !q) // 如果两个结点都是空的，对称 return true; else if (!p || !q) // 如果两个结点只有一个是空的，不对称 return false; else if (p-&gt;val != q-&gt;val) // 如果两个结点都不空，比较它们的值，如果不等，则不对称 return false; bool inside = compare(p-&gt;right, q-&gt;left); // 比较内结点 bool outside = compare(p-&gt;left, q-&gt;right); // 比较外结点 return (inside &amp;&amp; outside); // 只有二者都为true时才对称 }} 二叉树的最大深度模板题 层序遍历（迭代） 12345678910111213141516171819class Solution {public: int maxDepth(TreeNode* root) { if (root == nullptr) return 0; int height = 0; queue&lt;TreeNode*&gt; q; q.push(root); while (!q.empty()) { int size = q.size(); for (int i = 0; i &lt; size; i ++) { if (q.front()-&gt;left != nullptr) q.push(q.front()-&gt;left); if (q.front()-&gt;right != nullptr) q.push(q.front()-&gt;right); q.pop(); } height ++; } return height; }} 先序遍历（递归） 首先确定这个递归函数是要干什么：求树的高度。所以返回值是int类型； 然后确定终止条件：root == null，空树，树高为0； 最后确定单层递归的逻辑：树的最大深度等于max(左子树深度，右子树深度) + 1。 123456789class Solution {public: int maxDepth(TreeNode* root) { if (root == nullptr) return 0; int lheight = maxDepth(root-&gt;left); int rheight = maxDepth(root-&gt;right); return (max(lheight, rheight) + 1); }}; 二叉树的最小深度和上一题类似，但是这一题要求的是“从根结点到最近叶子结点的最短路径”，所以如果一棵树的左/右结点为空，其最小深度不是1，而是“非空子树的最小深度+1”。如果沿用上一题的写法，那就会在这里出错。 以下给出递归解法。当然也可以层序遍历，这里就不写了。 1234567891011class Solution {public: int minDepth(TreeNode* root) { if (!root) return 0; int lheight = minDepth(root-&gt;left); int rheight = minDepth(root-&gt;right); if (!root-&gt;left &amp;&amp; root-&gt;right) return rheight + 1; if (root-&gt;left &amp;&amp; !root-&gt;right) return lheight + 1; return (min(lheight, rheight) + 1); }}; 平衡二叉树和求二叉树最大深度那题类似。 递归三部曲： 确定参数和返回值类型 传入根结点，如果这棵树是平衡二叉树，则返回树高度；如果不是，则返回-1；所以返回值类型为int 确定终止条件 如果为空树，返回0；如果左/右子树高度为-1（说明不是平衡二叉树），返回-1。 确定单层递归的目的 如果左右子树高度差大于1，返回-1，否则返回树高度。 123456789101112131415class Solution {public: int getHeight(TreeNode* root) { if (root == nullptr) return 0; int lheight = getHeight(root-&gt;left); if (lheight == -1) return -1; int rheight = getHeight(root-&gt;right); if (rheight == -1) return -1; if (abs(lheight - rheight) &gt; 1) return -1; else return(max(lheight, rheight) + 1); } bool isBalanced(TreeNode* root) { return (getHeight(root) &gt;= 0); }};","link":"/2022/07/14/DS-Kaoyan-algorithm/"},{"title":"考研操作系统笔记","text":"Through the storm, we will find a way. 第一章 导论1.1 什么是操作系统定义 操作系统是内核（Kernel）：一直运行在计算机上的程序，内核不运行则计算机无法运行。 目的 核心目标：运行程序 面向系统：高效使用计算机 面向用户：方便使用计算机 功能 操作系统是资源分配器 管理所有资源 面对冲突的资源请求，决定如何分配资源，以便系统能有效公平运行 操作系统是控制程序 管理用户程序运行，以防计算机资源的错误使用或使用不当 操作系统是计算机最底层的软件 现代计算机系统 现代计算机系统通常包含一个或多个CPU和内存、若干通过总线相连的设备控制器及其设备、总线、CPU和设备控制器可以并行工作，并竞争内存。 CPU和设备间的交互 每个设备控制器有一个本地缓冲 CPU在内存和本地缓冲之间传输数据 I/O控制器从设备到本地缓冲之间传输数据 控制器通过中断通知CPU完成操作 中断是指当出现需要时，CPU暂时停止当前进程的执行，转而处理新情况的中断处理程序。 1.2 多道程序设计和分时简单批处理系统（单道程序设计）用户将一批作业（批处理作业）提交给操作系统后就不再干预，由操作系统控制它们自动运行。 每个时刻只执行一个作业，自动从一个运行完的作业切换到下一个作业 实现了自动化作业调度（由常驻监控程序Monitor（简单批处理系统的核心）实现） 控制作业传输 调度作业运行 自动从一个运行完的作业转换到下一个作业 可以在无需人工干预的条件下运行作业（不具有交互性） 多道程序系统（多道程序设计）在内存中同时存在多道作业，在管理程序控制下相互穿插运行。 目的：提高CPU利用率 并行和并发并行：微观上，两个或多个作业在同一时刻运行 并发：宏观上，两个或多个作业在同时运行；但微观上，同一时刻只有一个作业在运行，不同作业在不同时间段依次运行 分时系统分时系统是针对交互作业设计出来的，是多道程序设计的延伸。e.g. Unix 联机的多用户交互式操作系统 采用时间片轮转方式使一台计算机为多个用户服务 在单位时间内，每个用户获得一个时间片并运行 保证用户获得足够小的响应时间，并提供交互能力 1.3 操作系统类型 大型机系统 简单批处理系统 多道程序系统 分时系统 桌面系统 适用于PC 嵌入式系统 完全嵌入受控器件内部，为特定应用设计的专用计算机系统 手持（移动）系统 适用于手持设备，如手机、平板 分布式系统 又称松耦合系统 通过网络通信：TCP/IP 目前没有真正意义上的分布式操作系统 多处理器系统 有多个紧密通信的处理器的系统。多个处理器共享计算机总线、内存和外设等。紧耦合系统。 优点：节省资金（因为共享其他设备）、增加可靠性、增加吞吐量 对称多处理（SMP）：每个处理器运行操作系统的相同副本 非对称多处理（ASMP）：各个处理器不对等，一个主处理器，若干从处理器（如骁龙820） 集群系统 通过专用网络连接一群计算机，将这些计算机虚拟化为一台有超强算力的计算机。 1.4 操作系统操作和功能操作双模式用户模式和内核模式 用以解决程序运行中出现的问题：除以零、死循环等，允许OS保护自身和其他系统部件 双模式需要CPU的支持，如果CPU有模式位，则可以在操作系统中实现双模式 内核模式的模式位为0，用户模式的模式位为1 在用户模式中，只能运行用户自编的应用程序 在内核模式中，可以运行OS内核程序（特权指令），包括I/O指令、置中断指令等 用户可以通过系统调用和软件中断执行特权指令 I/O保护I/O指令都是特权指令，防止用户执行非法I/O 内存保护通过硬件支持（基址寄存器+限长寄存器）的存储保护机制，防止内存非法访问 定时器如果用户程序死循环或不调用系统调用，那么操作系统就无法获得CPU的控制权并对系统进行管理 所以引入定时器，在一段时间后发生中断，将CPU控制权返回给操作系统 也需要硬件支持 功能进程管理、内存管理、文件管理、I/O系统管理、其他 第二章 操作系统结构2.1 操作系统服务和接口操作系统以服务形式向程序和用户提供环境执行程序 三种基本服务形式提供给程序的服务形式：系统调用 系统调用可以供程序通过应用程序接口（API）访问 三种常用API：Windows的Win32 API、POSIX系统的POSIX API、Java虚拟机的Java API 提供给用户的服务形式：用户接口、系统程序 用户接口：命令行接口（CLI）、图形接口（GUI） 智能手机采用的人机交互接口有：命令行接口、图形接口、声控接口 系统程序：用以管理、维护操作系统 文件管理（文件资源管理器）、状态信息（这台电脑-&gt;管理）、通信等 2.2 操作系统结构 简单结构（无结构）：MS-DOS、早期Unix 层次结构：每层只能使用相邻低层次的功能和服务（THE、iOS） 微内核（Mach、Windows NT、 Windows 2000） 便于移植、更稳定、更安全（适合服务器） 用户空间和内核空间通信的系统开销增加 ——&gt; 提出了消息传递机制 模块结构：大部分现代操作系统采用（Linux、Solaris） 每个核心部件分开 每个模块在需要时被加载到内核 混合结构：MacOS 2.3 虚拟机定义：虚拟机是通过软件模拟实现，具有完整硬件系统功能，并运行在一个完全隔离环境中的完整计算机系统 常见的虚拟机有三种 高级语言虚拟机（JVM） 用以模拟代码运行，实现跨平台 运行在操作系统上 工作站虚拟机（VMWare Workstation、Virtual Box） 面向工作站和PC，使得多个操作系统可以在一个计算机上使用 客户操作系统运行在宿主操作系统上 服务器虚拟机（阿里云、腾讯云等） 多用户、多操作系统并存 把服务器的物理资源抽象成逻辑资源，让一个物理计算机虚拟化为多个相互隔离的虚拟服务器 直接运行在硬件上 第三章 进程3.1 进程概念进程：一个程序在一个数据集上的一次运行 进程和程序的区别 进程是程序的一个实例，是程序的一次执行；程序是进程的代码部分 进程是动态的，程序是静态的 进程在内存中，程序在外存中 进程的组成进程包括 代码（程序段） 当前活动：程序计数器PC、堆栈(包括函数参数、返回地址、局部变量）、数据（包括全局变量）、堆（进程运行时动态分配的内存） 进程的状态运行态：指令在执行 等待态：等待资源或某些事件发生，满足条件后转化为就绪态 就绪态：等待分配处理器（时间片），满足条件后转化为运行态 新建态：创建进程 终止态：进程执行完毕 进程控制块（PCB）PCB在内核空间中，是进程在操作系统中的唯一标志 PCB中包含了和进程有关的信息：进程状态、程序计数器、CPU寄存器、CPU调度信息、内存管理信息、记账信息、I/O状态信息 进程的上下文切换需要PCB保护和恢复现场 3.2 进程操作进程创建父进程创建子进程，如此轮流创建进程，构成一棵进程树 资源共享方式 父进程子进程共享所有资源 子进程共享父进程资源的子集 父进程和子进程之间无资源共享 执行顺序 父进程和子进程并发执行（默认） 父进程等待，直到子进程执行完成为止（父进程调用wait系统调用） 地址空间 子进程复制父进程的空间（与父进程具有相同的程序和数据）（fork） 子进程装入另一个新程序 fork Linux中用系统调用fork()来创建子进程。fork()创建的子进程和父进程有不同的PID ，但是它们共享相同的代码空间和资源，相当于复制了父进程。 通过fork()的返回值区分父子进程： 如果子进程创建失败，fork()返回-1 如果创建成功，fork()在父进程中返回新创建的子进程的PID，在子进程中返回0 进程终止当进程完成执行最后语句并且通过系统调用exit()请求操作系统删除自身时，进程终止。 进程结束的方式 进程执行最后一项并退出（exit） 进程执行完最后一项并退出 操作系统收回进程的资源 父进程终止子进程的执行（abort） 通常使用这种方式结束进程是由于以下几种原因 子进程超量分配资源 赋予子进程的任务不再需要 父进程终止 父进程可等待子进程的结束（abort） 父进程通过调用wait()系统调用来等待子进程结束 fork()创建子进程之后，父进程和子进程的运行顺序是不固定的，有可能还没有执行子进程，父进程就先结束了。我们需要让子进程先执行，然后再执行父进程，就要用wait()，让父进程等子进程运行完。 进程通信独立与协同进程 独立进程：不会影响另一个进程的执行或被另一个进程执行影响 协同进程：可能影响另一个进程的执行或被另一个进程执行影响 进程间通信（IPC）的两种模式 共享内存：一块内存在多个进程间共享 以最快的速度进行方便的通信，一般用于大数据通信 生产者-消费者 消息传递：建立连接后使用send和receive操作交换信息 用以交换较少数量的数据 消息传递分为直接通信和间接通信 直接通信：需要通信的每个进程必须明确指定通信的接收者或发送者 间接通信：消息导向至信箱并从信箱接收，两个进程只有拥有一个共享信箱时才能通信 进程间采用间接通信方式时，在消息中必须给出信箱名 消息传递分为阻塞（同步）和非阻塞（异步） 阻塞send：发送进程阻塞，直到消息被接收 阻塞receive：接收者进程阻塞，直到有消息可用 非阻塞send：发送进程发送消息并继续操作 非阻塞receive：接收者收到一个有效消息或无效消息 其他Tips 进程的创建和终止都是原子操作 原子性必须需要硬件的支持 进程创建时，进程将被设置为就绪态，不会为其分配CPU 单任务操作系统不需要进行进程上下文切换 第四章 线程4.1 什么是线程线程是在CPU上运行的基本执行单位；进程上的一个代码片段可以被创建为一个线程 进程仍然是资源分配的基本单位；线程本身不拥有系统资源，而是向进程申请资源 引入线程的原因性能角度 操作进程对系统而言开销大 应用角度 进程代码并行执行的需求 硬件角度 充分利用多核处理器的并行特性 加速进程运行 线程和进程的联系和区别代码 进程包含线程 线程是进程中的一段代码 资源 进程是资源分配的基本单位 线程不拥有资源，共享使用进程的资源 调度 线程是基本的调度单位 同一进程中的线程切换不引起进程切换 切换 进程：重量级，上下文切换代价大 线程：轻量级，切换代价小 生命期 进程撤销会导致它的所有线程被撤销 线程撤销不影响进程 线程数据结构线程控制块（TCB） TCB包含在PCB中 含有：线程ID，程序计数器，寄存器集，栈空间 线程的优点 响应度高：线程创建开销小。（e.g. Web服务器） 资源共享 经济性：线程创建和上下文切换比进程快 充分利用多处理（MP）结构 4.2 线程模型用户线程定义：由用户线程库进行管理的线程 用户线程的创建和调度在用户空间中，不需要内核的干预 内核看不见用户线程 内核线程定义：由内核进行管理的线程 需要内核支持，由内核完成调度 由内核进行创建和撤销 多线程模型多对一模型：多个用户线程对应一个内核中的用户进程，用于不支持内核线程的操作系统 内核只看到一个进程，多个线程不能并行运行在多个处理器上 进程内线程切换不会导致进程切换（减少系统开销） 一个线程的系统调用会导致整个进程阻塞 一对一模型：用户线程映射到内核线程（Windows中普遍采用） 并发性好：多个线程可以并行运行在多个处理器上 内核开销大 多对多模型：多个用户线程映射为相等或更小数目的内核线程 并发性和效率兼顾，但增加了复杂度 4.3 线程库线程库为程序员提供API来创建和管理线程 两种模式 用户库（用户线程） 存在于用户空间 调用线程库不会产生系统调用 内核库（内核线程） 存在于内核 操作系统支持 调用线程库会产生系统调用 常见线程库PThreads线程库 线程的POSIX标准 Java线程库 两种创建方法 扩展java.lang.Thread类 实现Runnable接口 由JVM管理 Win32线程库 可能会产生系统调用 Tips 同一个进程中的线程，不能共享堆栈 ‌线程是比进程更小的能独立运行的基本单位 第五章 CPU调度5.1 CPU调度概述三种调度长程调度又称作业调度、高级调度 长程调度将作业由新建状态转换到就绪状态 控制内存中运行进程的数量 处于新建状态的进程一般首先被放到外存的进程池中，经过长程调度放入内存，转换为就绪状态 短程调度又称CPU调度、低级调度 调度程序选择下一个执行进程 中程调度又称交换 将进程在内存和外存之间换进换出，目的是节省内存空间 调度过程调度程序（Scheduler） 根据某种策略（调度算法）选择内存中的一个就绪进程 分派程序（Dispatcher） 负责具体的进程切换工作： 负责把CPU的控制权转交CPU调度程序 切换上下文 切换到用户态 跳转到用户程序的适当位置并重新运行 调度方式非抢占式调度一旦把CPU分配给某进程之后，系统不可以抢占已分配的CPU并分配给其他进程 特点：易实现、系统开销小、适合批处理系统；响应时间长，不适合交互式系统 发生时机： 从运行转到等待 进程终止运行 抢占式调度调度程序可根据某种原则暂停某个正在执行的进程，将已分配给它的CPU重新分配给其他进程 特点：可防止单一进程长时间独占CPU；系统开销大 发生时机： 从运行转到就绪 从等待转到就绪 5.2 先来先服务和短作业优先先来先服务（FCFS）短作业优先（SJF） SJF算法的就绪队列是按照进程的下一个CPU脉冲时间排列 非抢占式 抢占式 被称为最短剩余时间优先调度，缩写为SRTF SJF调度算法拥有最短的平均等待时间 但是存在饥饿问题 5.3 优先级调度和时间片轮转优先级调度（PR）目前主流的操作系统调度算法 抢占式 非抢占式 高相应比优先调度算法 时间片轮转（RR）5.4 多级队列和多处理器调度多级队列调度（MLQ）针对不同的进程使用不同的调度算法：允许系统中存在多个就绪队列，每个就绪队列有自己的调度算法 核心问题 队列数 每个队列的调度算法（每个队列的调度算法可以相同、可以不同） 决定新进程将进入哪个队列的方法 多级反馈队列调度（MLFQ）进程在其运行过程中，能在不同队列间移动 多处理器调度","link":"/2022/08/24/OS-Kaoyan/"},{"title":"考研数据结构笔记","text":"With renewed hope, we continue forward. 第一章 绪论1.1 数据结构的基本概念数据结构三要素 数据的逻辑结构 线性结构：线性表（包含栈、队列、数组） 非线性结构：集合、树、图 数据的存储结构 顺序存储：可以实现随机存取；如顺序表 链式存储：只能实现顺序存取；如邻接表 索引存储 散列存储 数据的运算 1.2 算法和算法评价一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它长。 算法原地工作指的是所需的额外辅助空间是常量，而不是指不需要任何额外辅助空间。 第二章 线性表2.1 线性表的定义和基本操作线性表是具有相同数据类型的n个数据元素的有限序列。是一种逻辑结构。 2.2 线性表的顺序表示（顺序表）线性表中元素的位序是从1开始的，而数组中元素下标是从0开始的。 2.2.1 基本操作 定义 12345#define InitSize 100typedef struct { ElemType *data; int MaxSize, length;} SqList; 插入 在顺序表的第i个位置插入新元素e。 平均时间复杂度为$O(n)$。 12345678910bool ListInsert(SqList &amp;L, int i, ElemType e) { if (i &lt; 1 || i &gt; L.length + 1) return false; // i == 1，即插入到最前面；i == length + 1，即插入到最后面 if (L.length &gt;= MaxSize) return false; // 满了 for (int j = L.length; j &gt;= i; j --) { // 顺序表的第i个位置，即为数组的第i - 1个位置 L.data[j] = L.data[j - 1]; } L.data[j - 1] = e; L.length ++; return true;} 删除 删除顺序表L中第i$（1&lt;=i&lt;=L.length）$个位置的元素，用引用变量e返回。 平均时间复杂度为$O(n)$。 123456789bool delete(SqList &amp;L, int i, ELemType &amp;e) { if (i &lt; 1 || i &gt; L.length) return false; // 判断i的范围是否有效 e = L.data[i - 1]; for (int j = i; j &lt; L.length; j ++) { L.data[j - 1] = L.data[j]; } L.length --; return true;} 按值查找 在顺序表L中查找第一个元素值等于e的元素，返回其位序。 平均时间复杂度为$O(n)$。 1234567int LocateElem(SqList &amp;L, int e) { for (int i = 0; i &lt; L.length; i ++) { if (L.data[i] == e) return i + 1; // 时刻牢记顺序表的位序 == 数组下标 + 1 } return -1; // 表示没找到} 2.3 线性表的链式表示（链表）2.3.1 单链表的定义和基本操作 定义 1234typedef struct LNode { ElemType data; struct LNode * next;}LNode, *LinkList; 头插法建立单链表 从一个空表开始，生成新结点，并将读取到的数据放到新结点的数据域中，然后将新结点插到当前表的表头（头结点之后）。 表中元素的顺序和输入顺序相反。 每个结点插入的时间为$O(1)$，总时间为$O(n)$。 12345678910111213141516// 头插法建立单链表// 表中元素的顺序和输入顺序相反LinkList List_HeadInsert(LinkList &amp;l) { LNode *s; int x; L = (LinkList)malloc(sizeof(LNode)); L -&gt; next = nullptr; scanf(&quot;%d&quot;, &amp;x); while (x != 9999) { // 输入9999以停止输入 s = (LNode*)malloc(sizeof(LNode)); s -&gt; data = x; s -&gt; next = L -&gt; next; L -&gt; next = s; scanf(&quot;%d&quot;, &amp;x); } return L;} 尾插法建立单链表 增加一个尾指针r，使其始终指向链表的尾结点。 时间复杂度和头插法相同。 123456789101112131415161718// 尾插法建立单链表// 设立一个尾指针指向尾结点LinkList List_TailInsert(LinkList &amp;L) { int x; L = (LinkList)malloc(sizeof(LNode)); L -&gt; next = nullptr; LNode *s, *r = L; scanf(&quot;%d&quot;, &amp;x); while (x != 9999) { s = (LNode*)malloc(sizeof(LNode)); s -&gt; data = x; s -&gt; next = nullptr; r -&gt; next = s; r = s; scanf(&quot;%d&quot;, &amp;x); } return L;} 按序号查找结点值 从头往后搜索，如果没找到则返回空。 时间复杂度为$O(n)$。 12345678910111213// 按序号查找结点// 返回结点的指针。如果没找到，就返回最后一个结点的指针域nullptrLNode *GetELem(LinkList &amp;L, int k) { int i = 1; LNode *p = L -&gt; next; if (k == 0) return L; // 如果 k == 0，返回头结点 if (k &lt; 0) return nullptr; // 如果输入不合法，返回空指针 while (p &amp;&amp; i &lt; k) { p = p -&gt; next; i ++; } return p;} 按值查找表结点 从头往后查找，若某结点数据域的值等于给定值e，返回该结点的指针。若没找到则返回空。 时间复杂度为$O(n)$。 123456789// 按值查找表结点LNode *LocateElem(LinkList L, ElemType e) { LNode *p = L -&gt; next; while (p) { if (p -&gt; data == e) return p; p = p -&gt; next; } return nullptr;} 插入结点 将值为x的新结点插入单链表的第i个位置上。先检查插入的合法性，再找到待插位置的前驱结点，即第i-1个结点，再在其后插入。 时间复杂度为$O(n)$。 1234567891011// 插入结点// 将新结点插到第i个位置bool List_Insert(LinkList &amp;L, ElemType x, int i) { LNode * pre = GetELem(L, i - 1); if (pre == nullptr) return false; // 没有第i - 1个结点，插入失败 LNode * s = (LNode*)malloc(sizeof(LNode)); s -&gt; data = x; s -&gt; next = pre -&gt; next; pre -&gt; next = s; return true;} 删除结点 将第i个结点删除。先判断合法性，再查找到第i个结点的前驱结点，修改其后继指针。 时间复杂度为$O(n)$。 1234567891011// 删除结点// 删除第i个结点bool List_Delete(LinkList &amp;L, int i) { LNode * pre = GetELem(L, i - 1); if (pre == nullptr) return false; // 没有第i - 1个结点，删除失败 LNode * s = pre -&gt; next; pre -&gt; next = s -&gt; next; s -&gt; next = nullptr; free(s); return true;} 2.3.2 双链表 定义 双链表结点中有两个指针prior和next，分别用来指向前驱结点和后继结点。 插入 将s结点插入p之后 1234567// 先处理s的前后指针s -&gt; next = p -&gt; next;s -&gt; prior = p;// 再处理s的后继结点的前指针p -&gt; next -&gt; prior = s;// 最后把p的next指向sp -&gt; next = s; 删除 删除p的后继结点q。 123p -&gt; next = q -&gt; next;p -&gt; next -&gt; prior = p;free(q); 2.3.3 循环链表 循环单链表 在循环单链表中，尾结点的next指针指向L，所以表中没有指向nullptr的结点。 判断表空的条件：头结点的next指向头结点。 循环双链表 判断表空的条件：头结点的prior和next都指向头结点。 第三章 栈、队列和数组3.1 栈栈是只允许在一端进行插入或删除操作的线性表。（操作受限的线性表） 栈的数学性质：$n$个不同元素进栈，出栈元素的不同排列的个数为$\\frac{1}{n+1}C_{2n}^{n}$ 3.1.1 顺序栈的定义和基本操作采用顺序存储的栈称为顺序栈。 初始时，top = -1 栈空条件：top == -1 栈满条件：top == MaxSize - 1 栈顶指针top指向栈顶元素。入栈时，先++top，再赋值；出栈时，先取值，再让top--。 定义 12345typedef struct SqStack{ ElemType data[MaxSize]; // stack int top; // pointer to the top of the stack} SqStack; 入栈 1234567bool push(SqStack &amp;s, int x){ if (s.top == MaxSize - 1) return false; s.data[++s.top] = x; // 栈顶指针先加1 再赋值 return true;} 出栈 1234567bool pop(SqStack &amp;s, int &amp;x){ if (stackEmpty(s)) return false; x = s.data[s.top--]; // 先取值 栈顶指针再减1 return true;} 3.1.2 链栈采用链式存储的栈叫做链栈。 优点是便于多个栈共享存储空间以提高效率，且不存在栈满上溢的情况。 规定所有操作都在表头实现。 3.2 队列队列也是一种操作受限的线性表。 3.2.1 队列的顺序存储队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置。（做题时，队头と队尾をよく区別してくれ！） 初始状态：q.front == q.rear == 0（不能用来判断队满） 进队：q.rear = x; q.rear++ 出队：x = q.front; q.front--; 3.2.2 循环队列初始状态：q.front == q.rear 队首指针前进1：q.front = (q.front + 1) % maxsize 队尾指针前进1：q.rear = (q.rear + 1) % maxsize 队空和队满时都有：q.front == q.rear，那么如何区分？ 通常会牺牲一个存储单元，保持其为空，即入队少用一个队列单元。此时约定“队头指针在队尾指针的前一个位置时为队满”，即(q.rear + 1) % maxsize == q.front，队空时仍为q.front == q.rear。 3.2.3 队列的链式存储链队列是一个同时带有队头指针和队尾指针的单链表。 出队时在链表头删除元素，入队时在链表尾插入元素。所以队头指针设在链表的表头位置，队尾指针设在链表的表尾位置。 适用于数据元素变动比较大的情形，而且不存在队列满且产生溢出的问题。 3.3 栈和队列的应用3.3.1 栈的应用 括号匹配 表达式求值（中缀表达式转后缀表达式） 递归 进制转换 迷宫求解 3.3.2 队列的应用 缓冲区 树的层次遍历（图的BFS） 第四章 串KMP Algorithm 第五章 树与二叉树5.1 树的基本概念5.1.1 树的性质 树中的结点数等于度数+1 度为$m$的树中第$i$层上至多有$m^{i-1}$个结点 高度为$h$的$m$叉树至多有$(m^h-1)/(m-1)$个结点（等比数列求和公式） 具有$n$个结点的$m$叉树的最小高度为$\\log_m^{[n(m-1)+1]}$（向上取整） 树的路径长度是树根到每个结点路径长度的总和。 5.2 二叉树的概念5.2.1 二叉树的性质 非空二叉树的叶子结点数等于度为2的结点数加1。即$n_0=n_2+1$ 具有$n$个结点的完全二叉树的高度是$\\log_2^{n+1}$（向上取整） 5.2.2 二叉树的存储顺序存储结构 链式存储结构 在含有$n$个结点的二叉链表中，含有$n+1$个空链域。 5.3 二叉树的遍历和线索二叉树5.3.1 二叉树的遍历 先序遍历 递归写法 12345678void preorderTraversal(TreeNode *root){ if (root == nullptr) return; visit(root); preorderTraversal(root-&gt;left); preorderTraversal(root-&gt;right);} 迭代写法 使用了一个栈作为辅助。首先将根结点入栈，然后每次迭代将栈顶元素出栈，再将其右孩子、左孩子入栈。 顺序很重要，先右孩子入栈，再左孩子入栈，这样出栈的时候才是中左右的顺序。 123456789101112131415161718192021void preorderTraversal_it(TreeNode *root){ stack&lt;TreeNode *&gt; st; vector&lt;int&gt; res; if (root == nullptr) return; st.push(root); while (!st.empty()) { TreeNode *top = st.top(); st.pop(); res.push_back(top-&gt;val); if (top-&gt;right != nullptr) st.push(top-&gt;right); if (top-&gt;left != nullptr) st.push(top-&gt;left); } for (int x : res) cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; endl; return;} 中序遍历 递归写法 12345678void inorderTraversal(TreeNode *root){ if (root == nullptr) return; preorderTraversal(root-&gt;left); visit(root); preorderTraversal(root-&gt;right);} 非递归写法 同样使用一个栈作为辅助。但是和前序遍历不一样的是，出栈顺序是左中右，所以需要调整入栈顺序。首先一路走到树的最左结点，路上访问到的结点都入栈。此时栈顶元素是最左结点，将其出栈，输出；随后的栈顶元素即为其父结点，将其出栈并输出，然后将其右孩子入栈，之后再找到右子树的最左结点，重复以上操作。 cur一直找左孩子，直到找到最左孩子，再继续cur = cur -&gt; left之后cur == nullptr，这时栈顶元素就是它的父亲，也就是整棵树的最左结点。左结点在这个时候出栈并输出。 123456789101112131415161718192021void inorderTraversal_it(TreeNode *root){ stack&lt;TreeNode *&gt; st; vector&lt;int&gt; res; TreeNode *cur = root; while (!cur || !st.empty()) { if (!cur) { st.push(cur); cur = cur-&gt;left; } else { cur = st.top(); st.pop(); res.push_back(cur -&gt; val); // 中间结点入栈 cur = cur -&gt; right; // 右结点入栈。如果cur此时是叶子结点，这句语句之后cur为空，保证了不会死循环 } } for (int x : res) cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; endl; return;} 后序遍历 递归写法 12345678void postorderTraversal(TreeNode *root){ if (root == nullptr) return; preorderTraversal(root-&gt;left); preorderTraversal(root-&gt;right); visit(root);} 非递归写法 只需要在先序遍历的基础上修改一下。 先序遍历是中左右，后序遍历是左右中。所以只需要把先序遍历循环中的两句交换顺序，变成中右左，然后再逆序输出就是后序遍历了。 123456789101112131415161718192021void postorderTraversal_it(TreeNode *root){ stack&lt;TreeNode *&gt; st; vector&lt;int&gt; res; if (root == nullptr) return; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); res.push_back(root -&gt; val); if (root -&gt; left != nullptr) st.push(root -&gt; left); if (root -&gt; right != nullptr) st.push(root -&gt; right); } reverse(res.begin(), res.end()); for (int x : res) cout &lt;&lt; x &lt;&lt; &quot; &quot;; return;} 层次遍历 借助一个队列。把每层的元素从左到右加入队列中，然后出队并输出。出队元素如果有孩子结点，也按照从左到右的顺序继续加入队列中。 123456789101112131415161718192021222324void levelOrder(TreeNode* root){ queue&lt;TreeNode*&gt; q; vecrot&lt;vectot&lt;int&gt;&gt; res; if (root != nullptr) q.push(root); while (!q.empty()) { int size = q.size(); vector&lt;int&gt; level_vals; for (int i = 0; i &lt; size; i ++) { // 循环次数 == 这一层元素的个数 TreeNode* cur = q.front(); level_vals.push_back(cur -&gt; val); if (cur -&gt; left != nullptr) q.push(cur -&gt; left); if (cur -&gt; right != nullptr) q.push(cur -&gt; right); q.pop(); } res.push_back(level_vals); } for (int x : res) cout &lt;&lt; x &lt;&lt; &quot; &quot;; return;} 5.3.2 线索二叉树在含$n$个结点的二叉树中，有$n+1$个空指针，将这些空指针利用起来，指向结点的前驱/后继，即是线索二叉树。 引入线索二叉树是为了加快查找结点前驱和后继的速度。","link":"/2022/07/21/DS-Kaoyan/"},{"title":"最短路问题","text":"いつの日かdistanceも 抱きしめられるようになれるよ 问题分类单源最短路 从一个点到其他所有点的最短距离 不存在负权边 朴素Dijkstra算法 $O(n^2)$ 堆优化版的Dijkstra算法 $O(m\\log n)$ 存在负权边 Bellman-Ford算法 $O(nm)$ SPFA $一般O(m)，最坏O(nm)$ 多源汇最短路 有多个起点到不同点的最短距离 Floyd算法 $O(n^3)$ 模板Dijkstra算法适用于无负权边的图。可以有重边或自环。 算法思想 定义一个distance[]数组，distance[i]表示从起点到点i的距离。 将distance[]初始化，distance[1] = 0，表示起点到自己的距离为0。其余全部赋值为INF，表示还未找到最短距离。 定义一个集合st[]，每当找到一个点i到起点的最短路时，st[i] = true，将点i加入集合中。 迭代n次，每次搜索所有未加入集合中的点，从中找到distance最小的那个点t，将其加入集合中。然后更新distance[]，判断t加入路径之后经过t的新路径距离是否小于原路径。 朴素DijkstraDijkstra求最短路 I不使用任何数据结构进行维护，时间复杂度为$O(n^2)$，适用于稠密图。 实现123456789101112131415161718192021222324252627282930313233343536const int N = 510;int n, m;int g[N][N]; // 邻接矩阵存图int dist[N];bool st[N];int dijkstra(){ memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; n; i++) { int t = -1; for (int j = 1; j &lt;= n; j++) { if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) { t = j; } } st[t] = true; for (int j = 1; j &lt;= n; j++) { dist[j] = min(dist[j], dist[t] + g[t][j]); } } if (dist[n] == 0x3f3f3f3f) return -1; else return dist[n];} 堆优化的DijkstraDijkstra求最短路 II用堆存储所有点到起点的距离，这样每次找distance最小的那个点t的时间复杂度就是$O(1)$ ，而更新其他点的距离的操作变为$O(\\log n)$。本题中点和边数均为$10^5$，所以是稀疏图，用邻接表来存。 实现123456789101112131415161718192021222324252627282930313233343536373839typedef pair&lt;int, int&gt; PII;const int N = 150010;int h[N], e[N], ne[N], w[N], idx;int dist[N];bool st[N];int n, m;int dijkstra(){ memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.first, distance = t.second; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n];} Bellman-Ford算法有边数限制的最短路Bellman-Ford 算法是一种基于松弛（relax）操作的最短路算法，可以求出有负权的图的最短路，并可以对最短路不存在的情况进行判断。适用于有边数限制、有负权边的图。可以用来判断是否有负环。 通常来说，SPFA在各方面都比Bellman-Ford更优。但是如果题中限制了最短路的边数，则只能用Bellman-Ford。 算法思想非常的简单松弛：对于边$(u, v)$，松弛操作对应下面的式子$dist(v)=\\min(dist(v),dist(u)+w(u,v)$也就是如果从源点直接到$v$点的距离大于从源点先到$u$ 再到 $v$，则将最短路从源-&gt;v 更新为 源-&gt;u-&gt;v 对于有 $n$ 个点， $m$ 条边的图，进行 $n - 1$ 次迭代，每次迭代对所有边进行松弛。直到没有边能够松弛了，算法结束。如果松弛次数大于 $n-1$ ，说明图中有负环（因为一共只有 $n$ 个点，任意两个点之间最多有 $n-1$ 条边）。所以，如果我们想知道是否存在源点到目标点的边数最大为 $k$ 的最短路径，则只要进行 $k$ 次迭代。伪代码如下： 123for n for 所有边 a,b,w dist[b] = min(dist[b],back[a] + w) 实现123456789101112131415161718192021222324const int N = 510, M = 10010;int n, m, k;int dist[N];int back[N]; // 因为每次迭代都会松弛所有边，可能会导致串联，所以使用一个备份，其中存的是上一次迭代的diststruct { int a, b, w;}edges[M];void bellman_ford(){ memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; k; i++) { memcpy(back, dist, sizeof dist); for (int j = 0; j &lt; m; j++) { int a = edges[j].a, b = edges[j].b, w = edges[j].w; dist[b] = min(dist[b], back[a] + w); } }} SPFAspfa求最短路spfa判断负环 算法思想spfa是队列优化后的Bellman-Ford。在Bellman-Ford算法中，每一次迭代都会搜索所有的边，判断是否需要松弛。然而很显然，只有在上一轮迭代中松驰过的边才有可能需要松弛，而其他的边在上一轮是没有发生改变的。所以我们使用一个队列来维护那些可能需要松弛的结点，就不需要每次都访问所有点了。 实现1234567891011121314151617181920212223242526272829303132333435363738const int N = 100010;int n, m;int h[N], e[N], ne[N], w[N], idx;int dist[N];bool st[N];int spfa(){ memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue&lt;int&gt; q; q.push(1); st[1] = true; // st用来标记某个点是否进入队列 while (q.size()) { int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) { q.push(j); st[j] = true; } } } } return dist[n];} Floyd算法Floyd求最短路适用于任何图，可以有负权边。但不能有负环。 算法思想基于高深的动态规划。首先图要用邻接矩阵来存。定义一个数组 g[k][x][y] ，表示 $x$ 只经过 $1, 2 \\dots k$ 到 $y$ 的最短距离。所以 g[n][x][y] 就是 $x$ 到 $y$ 的最短距离。所以进行 $n$ 次迭代，每次 g[k][x][y] = min(g[k - 1][x][y], g[k - 1][x][k] + g[k - 1][k][y] 。而实际上，数组的第一维对结果无影响，所以可以省略。 实现1234567void floyd(){ for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);}","link":"/2022/03/09/Shortest-path/"},{"title":"Trie","text":"介绍trie，又称前缀树或字典树，是一种有序树，用来保存关联数组，其中的键通常是字符串。是一种高效的存储和查找字符串的数据结构。 如图所示，如果我想要查找是否有 cat 这个单词，只需要沿着 c -&gt; a -&gt; t 这条路径走。如果路径上有某个结点不存在，则说明不存在这个单词。另外，如果存在某个单词，我们也需要给这个单词最后的那个结点打上一个标记，表示从根节点走到这个结点的路径是一个单词。 例题题目描述维护一个字符串集合，支持两种操作： I x 向集合中插入一个字符串 $x$；Q x 询问一个字符串在集合中出现了多少次。共有 $N$ 个操作，输入的字符串总长度不超过 $10^5$，字符串仅包含小写英文字母。 输入样例1234565I abcQ abcQ abI abQ ab 输出样例123101 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;const int N = 100010;int son[N][26], cnt[N], idx;char str[N];// son[N]用来存树里的结点 ---&gt; 静态链表// son[N][26]用来表示结点的键值（26个小写字母）// cnt[N]用来统计单词出现次数// idx和静态链表中的idx一样，用来表示当前操作的是第几个结点void insert(char* str) { int p = 0; // 从根节点开始 for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; // 将字母映射成整数 if (!son[p][u]) son[p][u] = ++idx; // 如果结点不存在，则创造这个结点，让它指向下一个操作的结点 p = son[p][u]; } // 循环结束后，p就是这个单词的最后一个字母所在结点 cnt[p]++; // 单词出现次数}int query(char* str) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; if (!son[p][u]) return 0; // 如果想要查找的路径上有结点不存在，说明该单词不存在 p = son[p][u]; } return cnt[p];}int main() { int n; scanf(&quot;%d&quot;, &amp;n); while (n--) { char op; scanf(&quot; %c&quot;, &amp;op); // 坑：scanf在读入单个字符时不会过滤回车，例如在读入一个'a'之后，输入回车的话， // 回车会被存放在缓存区中，下一次scanf会自动把回车读入 // 解决办法：在%前加一个空格，会告诉scanf忽略前面的空行，而等待第一个非空行元素读入其中。 if (op == 'I') { scanf(&quot;%s&quot;, str); insert(str); } else { scanf(&quot;%s&quot;, str); printf(&quot;%d\\n&quot;, query(str)); } } return 0;}","link":"/2022/01/28/Trie/"},{"title":"字符串哈希","text":"介绍利用哈希的思想，实现快速判断两个字符串是否相同。 例题题目描述给定一个长度为 $n$ 的字符串，再给定 $m$ 个询问，每个询问包含四个整数 $l_1,r_1,l_2,r_2$，请你判断 $l_1, r_1$和 $l_2, r_2$ 这两个区间所包含的字符串子串是否完全相同。 字符串中只包含大小写英文字母和数字。 输入格式第一行包含整数 $n$ 和 $m$，表示字符串长度和询问次数。 第二行包含一个长度为 $n$ 的字符串，字符串中只包含大小写英文字母和数字。 接下来 $m$ 行，每行包含四个整数 $l_1,r_1,l_2,r_2$，表示一次询问所涉及的两个区间。 注意，字符串的位置从 $1$ 开始编号。 输出格式对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 Yes，否则输出 No。 每个结果占一行。 输入样例123458 3aabbaabb1 3 5 71 3 6 81 2 1 2 输出样例123YesNoYes 题解根据哈希的思想，我们选择一个类似进制转换的哈希函数。 如 aabb 这个字符串，其映射值为：$$(a * P^0+a * P^1+b * P^3+b * P^4)\\bmod Q$$本题里，我们将其从前往后按照前缀的方式存到 h[] 中，那么有： 1234h[1] = 'a' 的映射值h[2] = 'aa' 的映射值h[3] = 'aab' 的映射值h[4] = 'aabb' 的映射值 而映射时有几个注意点： $P$ 通常取 $133$ 或 $13331$ ，经验证明这样很少发生碰撞。 字母不能映射成 $0$ 否则会发生冲突 ：如果a -&gt; 0 那么 aa -&gt; 0 我们要想知道 $[l_1, r_1]$ 和 $[l_2, r_2]$ 是否相同，那么只要判断二者的哈希值是否相等。那么如何判断二者是否相等呢？ 问题就转化为：已知 h[l1], h[r1] 的值，如何求得 $[l_1, r_1]$ 这一段的哈希值？ 答案是：将 h[l1] 左移 $r-l+1$ 位，它与 h[r1] 的差值就是我们想要求的。如 aa 的哈希值右移两位就是 aa00 ，然后用 aabb 的哈希值减去 aa00 ，就得到 bb 的哈希值。代码如下： h[r] - h [l - 1] * p[r - l + 1] 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned long long ULL;const int N = 100010, P = 131;int n, m;ULL h[N], p[N];char str[N];ULL get(int l, int r) { return h[r] - h [l - 1] * p[r - l + 1];}int main() { scanf(&quot;%d%d%s&quot;, &amp;n, &amp;m, str + 1); // 从 str[1]开始存 p[0] = 1; // 预处理h[N]和p[N] for (int i = 1; i &lt;= N; i ++) { p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + str[i]; } while (m--) { int l1, r1, l2, r2; scanf(&quot;%d%d%d%d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2); if (get(l1, r1) == get(l2, r2)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); } return 0;}","link":"/2022/02/25/StringHashing/"},{"title":"By making a song can I keep the memory?","text":"我的2021年终总结 随着考研告一段落，2021年就这样悄无声息地过去了。而我也在周期性地陷入迷茫，像死鱼一样躺了几天之后，终于想起已经时至年尾，该写些什么来虚假地总结和纪念一下这过去的平凡又乏味的一年了。 尽管我每年都会写年终总结，但每次都不知从何下笔，从取标题开始就被难倒。毕竟只是一个死宅大学生而已，一年里又能发生些什么值得写的事呢？ 姑且容我流水账般回忆一下这一年里发生过的，给我留下印象的事吧。 烟花三月，终于下了一趟扬州。第一次尝试青旅，运气很好，遇见了能够一起吃饭观光的小学弟。算是我的社交恐惧症治愈之路上的第一个疗程吧。 五月和老同学们去了无锡和苏州。有点可惜的是，去的时候赶上节假日，所以到处都是人山人海，以至于没有去成苏州博物馆。以后还要找个时间去一次。 之后就是颓废的暑假。七月在家浪费了一个月，依然是日复一日地做着我浪费生命的老一套。八月开始有了些危机感，复习进度捡起来一些。 回学校之后的时间就好像按下了加速键。每天重复着早起去图书馆，晚上十一点回宿舍的日子。还没等我反应过来，手机上显示的时间就从十月变成了十一月、十二月。 虽然我对于考研并不是抱着玩玩的心态去应付的，但也不到「如果考不上这辈子就完了」的程度。所以尽管我没有哪一天是没去学习的，但没有尽全力这一点我也是心知肚明。可能对我来说，所谓的尽全力根本不存在吧。 所以上考场时的状态不佳也是我自食恶果。但是即使自我感觉再差，过去的事也已经过去，这里就不谈了吧。 今年网易云的年终报告，我听得最多的歌是《Reflexion, allegretto, you》，听了七百多遍。我今年最庆幸的事就是二刷了《利兹与青鸟》，发现了三年前第一次看时没发现的美好。一周内看了四遍，还买了BD，让我找回了当年看君名时的热情。 ED我也听了很多遍。当前奏的吉他声响起时，我的脑海里总是浮现出飘飞的水蓝色裙摆、游曳的夏日光斑和摇摇欲坠的未来。 上大学之后，体感时间流逝得越来越快。回看前几年的年终总结，焦虑和迷茫总是主题。而当下正处在转折点的我，依然在踌躇满志和混吃等死的叠加态中撕扯着，迎来了2022年。 Feeling so anxious each spring time We are flapping about like plastic bags How would I sing? Golden reflections of our life In the afternoon sunlight Chocolates melt in my pocket By making a song can I keep the memory? I just came to love it now","link":"/2022/01/02/2021Summary/"},{"title":"死、宝石、夕阳与春雪","text":"她边说边泛起一种焦灼感。然而，就像向别人描述死、宝石的闪光和夕阳的优美一样，这乃是最难的事情。 前言今天终于把三岛由纪夫的《春雪》读完了。 这是我读的第三本三岛。前两本是《金阁寺》和《假面的告白》。 《金阁寺》是高中的时候读的。读的是唐译本。一方面觉得文字极其精致，一方面也确实掉入了华丽辞藻编织出的陷阱里。 简而言之，没读懂，囫囵吞枣。这本薄薄的，被称作三岛的代表作的小说，在我脑海中留下的印象单薄却持久：那只屹立在金阁寺顶上，在时间和空间的永恒流动中岿然不动的黄金凤凰。 《假面的告白》是几个月前读的。读的是陈译本。这是三岛作为作家，所发表的第一部小说。文字的华美从这时就已经让人哑然。 这本自传性小说，也确实让我得以一窥这位伟大作家的真实。所有这本书的读者肯定都忘不了，那副《圣塞巴斯蒂安殉教图》。我也是从这时候才略微领会三岛对于「美」的追求。 健康、死亡。 这两者都是三岛所追求的美的一环。对于生者——从三岛自己就能看出来——他向往健硕的、威严的、如同太阳与铁的不可逆的肉体。但他更喜欢的，或者说，觉得更美的，则是这不可逆的、象征着生的肉体被死亡所吞噬。 日本人所谓的「物哀」，指的是对于萧条、衰败的景物产生的哀伤之情。而三岛将这种感情投射到人，发展出了独属于他的美学。 所以我在读之前也很容易地猜到了，《春雪》的结局必然是悲剧。 三岛的美学 没有什么东西比已达成的恋情更加不值一提了。 清显和聪子明明两情相悦，为何最后偏偏沦落到一人剃度，一人病逝？ 且抛开三岛的「暴烈」不谈。 清显年方十七八，面对比他大两岁的青梅竹马聪子，在男性和新晋贵族身份的两道枷锁的禁锢下，当然渴望在恋情的角力中掌握主导权。他跟聪子的几次拉扯，虽不理智，但是合理。二人的感情在共赏春雪的时刻达到高潮，这是三岛为读者创造的「美」。 塞林格说：爱是想触碰又收回手。 而清显显然不这样认为。 在聪子和王爷订下婚约后，他才发觉「我热恋着聪子」。在镰仓的海边，在那名为「不可为」的夜幕的包裹之下，三岛将他的美学之幕揭开——「为所不可为」。 这份相互折磨的爱，越是危险，越让人感到欲罢不能。于清显，于聪子，于读者，于三岛，都是这样。 所有人都享受着这份漆黑夜色中的耳鬓厮磨，尽管天空即将破晓、美好面临毁灭也无法收手。因为当这份世俗的美被毁灭，原地重新诞生的将是永恒的美，也是三岛一生所追求的美——「死亡」。 瞎扯《春雪》的阅读体验，实在是我从来都没有经历过的。 首先提一下，这次读的是文洁若的译本。感觉比前两次好读些。 花了一个多月读了三分之二，昨天和今天一口气读完了最后三分之一。在读到最后时，内心也被一种巨大且不可名状的悲伤所填满。以至于读完之后还久久不能平静，整个下午都无心做其他事。 读《春雪》之前，我对三岛的认知是「用华丽的文字包裹简单的故事」。 但是现在看来并非如此，在华丽的文字之下，包裹的是同样华丽的故事。 没有一处描写是无用的，登场的众多人物，每个人的形象都跃然纸上。 借明治维新而成为新兴贵族的松枝家，色厉内荏的松枝侯爵与蹴鞠世家，吃了二十七代皇粮却逐渐衰微的绫仓伯爵。这二人的对手戏，如果深挖的话，想必也是可以对日本贵族制有更加清晰的认识的吧。可惜我学疏才浅，做不到了。 从鹿儿岛来的学伴饭沼、服侍绫仓家几十年的老妪蓼科，两人分别服侍着故事的两位主角，却抱着完全不同的态度。饭沼怒清显不争，无比怀念旧时代，而蓼科则是无条件服从聪子，实质却在谋划十几年的复仇。二人对比，深层次剖析的话，也会很有趣吧。 … 可细细品味的地方太多了。等我把丰饶之海四部读完，多了解一些背景知识，一定再读一遍。 摘抄 清显从海潮的奔腾和漫长时间的流逝中，突然察觉到自己不久也会走入老境，而泛起一阵子窒息的感觉。他从来没有想过要获得什么老年人的智慧。他想的只是怎样才能在年轻的时候就溘然死去，而且尽可能不感觉痛苦。宛若一件华丽绸和服随便脱下来扔在桌子上，不知不觉又滑落在昏暗的地板上那么优雅。 三岛对于死亡的描写太美了。 此刻，忽然觉得天光暗了下来，一群飞鸟从天涯海角涌过来，叫声四起，直逼头顶，清显就举枪勾动了扳机。这不单单是无情的射击，而是心中充满不可言状的愤怒和悲哀，与其说是对着群鸟，莫如说是向着太空那只巨大的蓝眼开的枪。 群鸟一齐被打了下来，眼看着一阵带血的龙卷风呐喊着把天和地连接起来了。所以这么说，那是因为无数的鸟儿嘶鸣着，滴着鲜血，密密麻麻地聚集成一根粗大的望不见顶端的柱子，向着地面的一点俯冲下来，就仿佛是水量极大的瀑布带着吼声和血色，没完没了地从天上落了下来。看上去，确实酷似那连续不动的龙卷风。 这段读起来超有画面感。 恋爱中的男人，他的心是容纳不下恋爱之外的任何事物的。甚至对别人的悲痛，也都丧失了同情心。 两个小伙子心里所拥抱的两个截然不同的世界的影子，将其尖端突出地显示在煤油灯那黄雾般的光圈中。一个因恋爱而卧病，一个为坚固的现实而学习。清显恍如在梦境里，他被海藻缠住了脚，在混沌的爱之海中泅水；本多则向往着牢固地建立在地面上的井井有条的理智的建筑物。 情感和理智，毁灭和秩序。","link":"/2021/06/12/harunoyuki/"},{"title":"ただ力の抜けた光る方へ","text":"我的22考研记录 今天是2021年8月1日。从三月份开始准备，到现在考研进程也已过半。 想着不妨写些东西，一是对前半段的复盘，二是督促自己，三是给以后留个回忆。 择校之前一直无法定下目标院校，在各大高校之间徘徊。一开始是北邮、东南，后来是华科、武大、浙大。不过其实我不太想去北邮，只是因为我校考北邮上岸的很多，所以我下意识觉得应该比较好考而已。 上大学前，我对大学的幻想大多来自汪曾祺先生在其散文中介绍的西南联大。 我想象中的大学，应该更具人文气息。而根据我本科在理工科大学经历的这三年来看，其显然过于冷峻了。 大学之大，不在其面积，而在其包容。学科建设全面一些的大学，我认为是会更加丰富且多元一些的。 所以我很想读一读综合类大学，这是其一。 其二就是，我很想去上海。也不知道哪里来的上海情结，反正就是特别有好感。 说来惭愧，高三的时候很想考华师。当时还跟好朋友约好了，她考交大，我考华师，到时候就是邻居了。 结果两个人都没考上，自然也没做成邻居。 而三年过去了，我还是很想去上海。我想去看各种艺术展，想去梅奔看演唱会，想去cp，想参加上影节。 还是有些985情结。而交大和复旦，我感觉高攀不起。于是华师显然是最好的选择，计算机水平不错，考的人又少。 何况还有意外之喜——华师考的是数二英二。英语倒是无所谓，但是之前一直按照数一备考的我突然感觉松了一口气。数二比数一少了概率论、级数、线面积分之类又多又难的内容，对于我这种被数学按在地上摩擦了一辈子的数学废物来说简直如同天降福音。 「就它了，」在华师官网上看到「数学二」三个字时，我心想，「不要太适合我。」 那么定下目标院校的我，有没有做出相应的努力，好好学习呢？ 呵呵。 于是我浪费了整个七月的时间。 规划八月 现在看来，其实放暑假之前，我在学校里的学习状态还算好，进度也还可以。但是一到暑假就一如往常地陷入了颓废的境地。 既然七月已经被浪费了，那么八月就要加倍努力追上来。每天学习10小时吧。 为了不再只是嘴上说说，姑且列个计划表吧，感觉这样比较有用。 到八月底，应该完成的： 高数强化 计组一轮（8/15） 操作系统一轮（8/23） 数据结构一轮（8/30） 英语刷完16年以前的阅读真题（8/27） 政治每天一小时以内，学到哪算哪 同时也该准备一下九月的PAT了。（战略性放弃，先管初试吧） 今天就先写到这，之后视情况再更新。 九月 既然开学了，能够复习的时间肯定是要少于八月的。 而且返校的那天也要浪费一天。 到九月底，应该完成的： 线代强化 高数880 计网二轮 计组二轮 操作系统二轮 数据结构二轮 英语阅读二刷（优先级低） 时间轴8/15 更新： 今天把计组过完了。打算接下来再按章总结，同时开始复习OS。 英语做到了14年。13年的阅读只错了一个，感觉还不错。 高数目前到一元函数积分学。感觉应该增加做题的时间，减少看视频的时间。 这一周由于胃痛的缘故，学习时间比上周大大减少…上周好不容易对自己有了点信心，又消磨殆尽了。 新的一周，希望专注力能再提高一些，希望胃痛能缓和。 8/23 更新： 操作系统一轮结束。 果然还是比计组友好不少啊。我甚至还做了笔记，居然才花了计组一半的时间。 今天看着操作系统只剩下最后一节，突然就开始提不起劲，以至于下午基本都在摸鱼，晚上才把这一节看完。 明天开始数据结构。之前已经看到第四章了，所以应该两三天就能看完。然后进入二轮，以及增加数学的时间。 高数到常微分方程了。 关于自己老是犯低级错误，算错、看错符号之类的，我也许找到原因了。 还是一直以来困扰着我的问题。大脑活动停不下来，永远被无关紧要的事情占据。 就像进程调度的SJF算法，一直在处理最短的任务，把其他的进程都饿死了。 而我也是，难以把注意力放到眼前重要的事情上面。 比如读书时，思绪读着读着就飞走了，从获取信息变成了只是用视线扫过文字而已。 比如做题时，式子化简之后抄下来，大脑直接放弃思考要不要变号，就原封不动地抄下来。 我不知道这种问题是从何而来，也不知道怎么做才能改善。想来也许是小时候，一边吃饭一边看电视，过早地让自己一心二用，导致没有培养起来专心的能力。以及微博之类的碎片信息流，大概也是一部分原因。 所以最近在尝试冥想正念，让自己什么也不想，排除掉在脑海中过于活跃的杂乱信息。以及在碎片时间尽量不用手机，减少无用信息的摄入。 还有英语，这个就很舒适了。 13年错1个，14年错2个，15年错1个。不知道是我变强了还是阅读变简单了，我现在对英语的信心是前所未有的强。做完阅读之后再尝试做几篇完型吧，做得好的话，说不定真能上85。 不过有点可惜，没有一年是全对的。16年的还没做，不过听说这年比较难。 我也许到极限了。 我是指睡眠时间。 这段时间以来每天睡6小时，中午睡半小时左右。 而我昨天尝试着再缩短一下这个时间。定了5小时的闹钟，但是完全起不来，还是在床上多躺了一个小时。 6小时的睡眠时间是我在高中就尝试过的。当时从哪看到说，人的睡眠周期是一个半小时，睡眠最好是这个时间的倍数。事实证明，我睡6小时确实比睡6个半~7小时精神点。 所以打算今天试试4个半小时睡眠。如果失败的话，那就证明我的极限就是6小时了。 哇，4个半小时，听起来好吓人。真的能做到吗，不会猝死吧？ 8/30 更新： 时间终于来到了八月底。 各项任务也是ギリギリ完成了，还算不错。 今天是开学第一天。不知不觉就大四了，完全没有实感。课虽然不是很多，但总归还是会有影响，只希望影响不要太大。 数学到二重积分了，也就是高数的最后一章。接下来就边刷880边线代。线代感觉没时间再看视频了，直接看书做题吧。进度太慢了，之后要增加学数学的时间。 说是这么说，但还是不愿意自己做题。碰到难点的题就不太想思考。也许是对数学的恐惧积重难返吧。 英语。前几天把16年的阅读刷完了，错了两个。就很遗憾，一次全对都没有，多少有点气馁了。然后把完型给写了，居然全对。不过也不知道是这年阅读比较简单还是我真的挺强。总之这下也是给了我不少信心。如果今年阅读简单点的话，也许85还是挺稳的？（我就随便想想） 接下来打算把英语先放一段时间，挪出时间给数学和408。等到十月再开始作文。 感觉即使看了很多方法论，我做题还是靠语感。读不明白的长难句就多读几遍，一般都能读懂。所以二刷阅读真的有必要吗？ 数据结构。其实早该完成的，毕竟只剩下三章，一天一章完全没有难度。但是还是太摸了，这几天学习状态都不怎么好，所以拖到了现在。 这样的话，408总算是一刷结束了。这一套学下来，果然还是DS最友好，我一刷的正确率也最高。然后计网和OS差不多吧，计组毫无疑问的最难了。 政治。马原部分的视频看完了，1000题也做了些。之后的部分就不看视频了，直接做题吧。纸质书 + Anki每天刷。 有些焦虑。看到其他人408都开始刷真题了，数学也在二刷。随着剩下的时间一天天缩短，我产生「如果没考上怎么办」的想法的频率也高了起来。这种时候也只能强行让自己不去想了。毕竟路是自己选的，总该好好走完。高考没能达成的目标，过了四年还没法达成的话，也太没用了吧。 对了，我果然做不到一天只睡四个半小时。 1/1 更新： 本来还以为能多记一点的，结果开学后根本没时间。 考研就这样悄无声息地结束了。 虽然自觉考得很差，但是已经结束了，那就随它去吧。不想再想了，这种经历不想再有第二次了。 出成绩了再来更新。 2/23 更新： 败了，彻彻底底地败了。 考得比想象中还差。 但是因为已经做好心理准备了，所以看到成绩的那一刻也没什么波动。 这也说明我很清楚地知道自己没有尽力吧。 基础从一开始就没打好，心情浮躁，眼高手低，懒得动手，懒得思考。 以至于数学卷子发下来之后，大脑一片空白。下午的专业课，自以为已经掌握得很好了，但做过三四次的题依然不会。 一开始下定决心考研，除了想读书以外，还希望借此机会改掉自己无法专注、喜欢逃避现实的毛病。 但是很可惜，并没有改掉。我依然是自己厌恶的那个自己。 啊，这种话我已经说过多少次了呢？每一次都痛定思痛，每一次都死不悔改。 现在想来，也许这毛病是从小就有的吧。但是小学和初中还算学有余力，所以没有暴露出来。高中开始就比较明显了。上大学之后越来越明显，也许我已经丧失了专注学习的能力。 但我还是想再上几年学。 所以再来一年吧。","link":"/2021/08/01/kaoyan/"},{"title":"网易云音乐上传歌词&amp;翻译","text":"初めから チグハグだったけど 前言前几天听推荐的时候听到了しおんあい的「私の街」这首歌。 嗯，感觉旋律不错。想看看歌词，点开一看，居然没有翻译！ 那就自己来吧。毕竟现在没歌词/翻译的歌还挺少见的，难得有机会，那我当然是跃跃欲试。 作为一个翻译过几万字（虽然也不是什么严肃内容）的翻译爱好者，一篇歌词而已，那不是信手拈来？ 抱着这种心态，飞快地翻译完并提交了。 然后就没过审核。 可恶啊 就这样，我的歌词翻译之路走到了尽头。 本文完。（ 过了两天，我发现しおんあい桑发新歌了。 这首也挺好听的 所以我又手痒了。 歌词部分获取歌词本文以「Tallest Liar」这首歌为例。 首先用Google搜索「Tallest Liar しおんあい」。 一般来说，如果这首歌出了一段时间，那都是能搜到现成的歌词的。 比如J-Lyric，歌ネット这些网站，一般都会有歌词。这里推荐J-Lyric，因为歌ネット不让复制。 但是这首歌比较新，当时才刚出两天。没有现成的歌词。 「那就自己动手！考验听力的时候到了！」 你以为我会这么说吗？怎么可能，我听中文歌都不一定能听懂歌词的。 于是求助万能的油管。 这首歌是有PV的，而PV里是有歌词的。 那就抄下来呗。 新建txt，一句一行，保存。 接下来就是让歌词滚动起来了。 打轴试了几个打轴工具，我比较推荐灯里的歌词滚动姬 它的一个优点是：加载音频时可以用外链，而不一定要上传本地文件。（没有网易云会员我也下载不下来啊） 使用方法就不详细介绍了，反正把刚刚的txt文件传上去，打就完事了。 打完轴之后的成品如下： 上传打开网易云网页端，然后点这个上传歌词。 翻译部分网易云官方推荐上传双语歌词，原文和翻译在同一行，中间用空格隔开。 可以。 但千万别。 我试了，结果就是这样。 哦，行吧。 那就先提交歌词呗。 这次审核还挺快的，第二天就过了。 然后上传翻译，审核更快了，几个小时就过了。 最终效果 总结就，看见自己的翻译还挺有成就感的。 哦，顺便说一下，网易云的审核人员大概是既不懂日文，也不懂中文吧。 这种垃圾翻译都给过","link":"/2021/06/10/netease-music/"},{"title":"Can we play a love song","text":"長い冬が終わる瞬間 笑顔で迎えたいから 我终于决定好好写博客了。 其实早就想自己搭个博客，来抒发自己无处安放的表达欲。而我也确实曾经用Hexo和GitHub搭过一个，但是由于惯例的三分钟热度，搭好之后就无限搁置了。 而这次的念头来自昨天，无意中看到了别人的博客。而我也确实从他的文章中感觉到，这是个有趣的人。 不同于音乐和影像，文字是有其独特魅力的。在自我表达方面，文字并不弱于任何一种媒介。而文字的门槛，也是最低的。不需要懂乐理，不需要懂光影和构图，只要接受过正常教育的人，多少能扯个几句话出来。 以前用过没加好友的小号的QQ空间写日志来着，其实还挺顺手，毕竟只是写字而已，也不需要什么花里胡哨的功能。后来用Notion，确实好看点，还支持Markdown，写起来也舒服。但是这两个都有个问题，那就是没法给别人看。而且身为程序员没个博客像话吗 其实也不太想给别人看。毕竟我们资深社恐，最擅长的就是把所有话都憋在心里。 但是我不想再社恐了。 前几天重看了一遍「四叠半神话大系」。上一次看还是高中吧，当时看只觉得森见牛逼，汤浅牛逼，这就是动画该有的表现方式！ 但是经过这一次二刷，我才更加体会到被困在四叠半大小的空间内的无所适从。 虽然人与人之间的A.T.Field坚不可摧，不同的人永远无法相互理解。但我还是想尝试一下，把真实的自己一点点、一点点地揭开。 所以心血来潮，昨天花了一晚上，买了域名，配置了Hexo。 这个博客以后应该会长期更新吧。目前的话，是有这么几个想法： 写写随笔 学习笔记 技术相关 那就先写到这了，希望这次不要再三分钟热度。 毕竟域名是花了钱的！","link":"/2021/06/09/Can-we-play-a-love-song/"}],"tags":[{"name":"日语","slug":"日语","link":"/tags/%E6%97%A5%E8%AF%AD/"},{"name":"想法","slug":"想法","link":"/tags/%E6%83%B3%E6%B3%95/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"考研","slug":"考研","link":"/tags/%E8%80%83%E7%A0%94/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"三岛由纪夫","slug":"三岛由纪夫","link":"/tags/%E4%B8%89%E5%B2%9B%E7%94%B1%E7%BA%AA%E5%A4%AB/"},{"name":"读后感","slug":"读后感","link":"/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"name":"音乐","slug":"音乐","link":"/tags/%E9%9F%B3%E4%B9%90/"}],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"读书","slug":"读书","link":"/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"分享","slug":"分享","link":"/categories/%E5%88%86%E4%BA%AB/"}]}